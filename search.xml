<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>A Primer on Hardware Prefetching</title>
    <url>/2025/02/05/A-Primer-on-Hardware-Prefetching/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>预取要干的事情：</p>
<ol>
<li>预测地址</li>
<li>预测何时预取</li>
<li>选择数据放在何处</li>
</ol>
<p>覆盖率衡量预取成功的显式处理器请求的比例（即，预取消除的需求缺失的比例）。准确性衡量的是预取器发出的访问中有用的部分（即，正确预取占所有预取的比例）</p>
<p>目前大部分处理器将预取数据放入缓存或者额外的缓冲区，这种策略称为非绑定策略</p>
<h1 id="指令预取"><a href="#指令预取" class="headerlink" title="指令预取"></a><strong>指令预取</strong></h1><h2 id="NEXT-LINE-PREFETCHING"><a href="#NEXT-LINE-PREFETCHING" class="headerlink" title="NEXT-LINE PREFETCHING"></a>NEXT-LINE PREFETCHING</h2><p>利用了空间局部性，每次处理器请求预取，他就从下级存储的数据转到缓存，然后预取下一个块</p>
<p><img src="/2025/02/05/A-Primer-on-Hardware-Prefetching/1729870525497.png" alt="1729870525497"></p>
<h2 id="FETCH-DIRECTED-PREFETCHING"><a href="#FETCH-DIRECTED-PREFETCHING" class="headerlink" title="FETCH-DIRECTED PREFETCHING"></a>FETCH-DIRECTED PREFETCHING</h2><p><img src="/2025/02/05/A-Primer-on-Hardware-Prefetching/1729870866685.png" alt="1729870866685"></p>
<p>分支预测定向与曲奇重用分支预测器探索未来控制流，这些技术使用分支预测器进行递归预测，找到地址</p>
<p><img src="/2025/02/05/A-Primer-on-Hardware-Prefetching/1729870959425.png" alt="1729870959425"></p>
<p><strong>Fetch-directed instruction prefetching (FDIP)</strong>：这个技术是最好的一批，FDIP将BP和IF解耦，通过fetch target queue (FTQ)，预取器使用FTQ从L2获取指令块，将他们放在全相连的缓存区，该缓冲区由指令获取单元与L1	缓存并行访问，为了避免其与L1重复，可以使用空闲的L1端口探测FTQ地址，看看是否存在，如果存在，就不进行预取，</p>
<h2 id="DISCONTINUITY-PREFETCHING"><a href="#DISCONTINUITY-PREFETCHING" class="headerlink" title="DISCONTINUITY PREFETCHING"></a>DISCONTINUITY PREFETCHING</h2><p>主要针对函数调用，获取分支和陷阱中断等进行预取</p>
<p>观察到服务器程序具有重复函数的深度调用堆栈后，图预取预测即将到来的函数堆栈，而不仅仅只是下一个不连续行为</p>
<p><img src="/2025/02/05/A-Primer-on-Hardware-Prefetching/1729872165002.png" alt="1729872165002"></p>
<p>而上图这个就是相当于只预测下一个不连续</p>
<h2 id="PRESCIENT-FETCH"><a href="#PRESCIENT-FETCH" class="headerlink" title="PRESCIENT FETCH"></a>PRESCIENT FETCH</h2><h2 id="TEMPORAL-INSTRUCTION-FETCH-STREAMING"><a href="#TEMPORAL-INSTRUCTION-FETCH-STREAMING" class="headerlink" title="TEMPORAL INSTRUCTION FETCH STREAMING"></a>TEMPORAL INSTRUCTION FETCH STREAMING</h2><p>Temporal instruction fetch streaming (TIFS)：记录Cache缺失顺序，然后进行预取</p>
<p><img src="/2025/02/05/A-Primer-on-Hardware-Prefetching/1729872496166.png" alt="1729872496166"></p>
<p>只是适用于单个控制流</p>
<h2 id="RETURN-ADDRESS-STACK-DIRECTED-INSTRUCTION-PREFETCHING"><a href="#RETURN-ADDRESS-STACK-DIRECTED-INSTRUCTION-PREFETCHING" class="headerlink" title="RETURN-ADDRESS STACK-DIRECTED INSTRUCTION PREFETCHING"></a>RETURN-ADDRESS STACK-DIRECTED INSTRUCTION PREFETCHING</h2><p>返回地址堆栈定向指令预取（RDIP）[26]使用额外的程序上下文信息来提高预测准确性和前瞻性。RDIP基于两个观察：(1)在调用堆栈中捕获的程序上下文与L1指令缺失密切相关；(2)返回地址堆栈（RAS）已经存在于所有高性能处理器中，它简洁地总结了程序上下文。RDIP将预取操作与由RAS内容形成的签名相关联。它将签名和相关的预取地址存储在约64kb的签名表中，在每次调用和返回操作时都要查看签名表以触发预取。RDIP实现了理想L1缓存70%的潜在加速，在一组服务器工作负载上比无预取器基准高出11.5%。</p>
<h2 id="PROACTIVE-INSTRUCTION-FETCH"><a href="#PROACTIVE-INSTRUCTION-FETCH" class="headerlink" title="PROACTIVE INSTRUCTION FETCH"></a>PROACTIVE INSTRUCTION FETCH</h2><p>主动指令获取[27]将TIFS设计修改为(1)记录提交指令序列访问的缓存块序列（而不是缓存中丢失的指令获取）和(2)分别记录在中断&#x2F;trap处理程序上下文中执行的流。该设计的一个关键创新是指令序列的压缩表示，它使用位向量来有效地编码预取地址之间的空间局域性。后续工作[28]将预取元数据集中在跨核共享的结构中，这大大降低了在多核共享元数据的同构设计中的存储成本。集中化将每核元数据减少到最小容量，使预取器甚至适用于具有小核的多核设计（例如，在移动&#x2F;嵌入式平台中使用的核）。</p>
<p><img src="/2025/02/05/A-Primer-on-Hardware-Prefetching/1729872855349.png" alt="1729872855349"></p>
<h1 id="数据预取"><a href="#数据预取" class="headerlink" title="数据预取"></a>数据预取</h1><p>数据访问模式多样，访问模式复杂，</p>
<p>分为四类</p>
<h2 id="STRIDE-AND-STREAM-PREFETCHERS-FOR-DATA"><a href="#STRIDE-AND-STREAM-PREFETCHERS-FOR-DATA" class="headerlink" title="STRIDE AND STREAM PREFETCHERS FOR DATA"></a>STRIDE AND STREAM PREFETCHERS FOR DATA</h2><p>这种预取器主要针对连续布局的数据，如数组和矩阵，但对于基于指针的数据结构不太行</p>
<p>stride 预取器关键的挑战就是区分多个交错的跨行序列，比如矩阵向量积，下图是每次load跟踪步幅，每个表保存load的最后一个地址，其实就是最新的addr，然后stride就是和之前的相减，每当连续两次观察到相同的stride，使用最一次的地址和stride计算预取地址</p>
<p><img src="/2025/02/05/A-Primer-on-Hardware-Prefetching/1729911213595.png" alt="1729911213595"></p>
<p>然后第二个问题就是检查到strided stream要预取多少块，这个参数被称为预取深度</p>
<h2 id="ADDRESS-CORRELATING-PREFETCHERS"><a href="#ADDRESS-CORRELATING-PREFETCHERS" class="headerlink" title="ADDRESS-CORRELATING PREFETCHERS"></a>ADDRESS-CORRELATING PREFETCHERS</h2><p>上一种遇到链表类似的结构就寄了，这类是针对这种情况的，基于算法倾向于以相同的方式重复遍历数据结构，从而导致反复出现的缓存缺失序列，这个利用了temporal correlation.：即最近访问的地址很可能在不久的将来再次被访问</p>
<h3 id="JUMP-POINTERS"><a href="#JUMP-POINTERS" class="headerlink" title="JUMP POINTERS"></a>JUMP POINTERS</h3><p>关联预取器是专门针对指针跟踪访问模式的硬件和软件机制的泛化。这些早期的机制依赖于跳转指针的概念，该指针在数据结构遍历中允许大的前向跳转。例如，链表中的一个节点可以用在链表中向前10个节点的指针进行扩充；预取器可以跟随跳转指针以获得对正在执行的主遍历的前瞻性。</p>
<p>依赖于跳转指针的预取器通常需要软件或编译器支持来注释指针。，内容导向预取器[47,48]避免注释，而是尝试解引用和预取任何看起来形成有效虚拟地址的负载值。虽然跳转指针机制对于特定的数据结构遍历（例如，链表遍历）非常有效，但它们的主要缺点是必须仔细平衡跳转指针推进遍历的距离，以便在不跳过太多元素的情况下提供足够的前瞻性。跳转指针的距离很难调优，而且指针本身的存储成本也很高</p>
<h3 id="PAIR-WISE-CORRELATION"><a href="#PAIR-WISE-CORRELATION" class="headerlink" title="PAIR-WISE CORRELATION"></a>PAIR-WISE CORRELATION</h3><p>本质上，基于关联的硬件预取器是一个查找表，它将一个地址映射到另一个可能在访问序列中紧随其后的地址。虽然这种关联可以捕获顺序关系和跨步关系，但它更通用，例如，捕获指针的地址和它所指向的地址之间的关系。</p>
<p>然而，地址相关的预取器依赖于重复；它们无法预取以前从未引用过的地址（与跨步预取器相反）。此外，地址相关预取器需要巨大的状态，因为它们需要存储每个地址的后继地址。</p>
<h3 id="MARKOV-PREFETCHER"><a href="#MARKOV-PREFETCHER" class="headerlink" title="MARKOV PREFETCHER"></a>MARKOV PREFETCHER</h3><p>马尔可夫预取器存储了几个先前观察到的后继者，当观察到触发器地址丢失时，所有这些后继者都被预取。通过预取几个可能的后继地址，马尔可夫预取器牺牲精度（正确预取占所有预取的比例）来提高覆盖范围</p>
<p><img src="/2025/02/05/A-Primer-on-Hardware-Prefetching/1729912849204.png" alt="1729912849204"></p>
<p>表中的条目包含要预取的后继地址集和可选的置信度或替换策略信息</p>
<p>马尔可夫预取器的设计灵感来自于对片外访问序列的马尔可夫模型的概念化。模型中的每个状态对应于一个触发地址，可能的后继状态对应于随后的错过地址。一阶马尔可夫模型中的转移概率对应于每个后继者失败的可能性。查找表的目标是存储最常遇到的触发器具有最高转移概率的后继者。然而，现有的硬件建议没有明确计算触发或转移概率；每个触发地址和后继地址都使用最近最少使用（LRU）替换启发式地进行管理。</p>
<p>有两个因素限制了马尔可夫预取器的有效性：(1)预读和内存级并行性是有限的，因为预取器只尝试预测下一次错过；(2)覆盖范围受到片上相关表容量的限制。</p>
<h3 id="IMPROVING-LOOKAHEAD-VIA-PREFETCH-DEPTH"><a href="#IMPROVING-LOOKAHEAD-VIA-PREFETCH-DEPTH" class="headerlink" title="IMPROVING LOOKAHEAD VIA PREFETCH DEPTH"></a>IMPROVING LOOKAHEAD VIA PREFETCH DEPTH</h3><p>一种直接的方法就是获取更多地址，还有就是使用预测地址递归执行表查找来发出更深的预取，</p>
<p>与其连续找不如折叠预取表，每个预取触发器旁边存短序列的后续程序，然而，更深层次的问题是，这样的表组织必须为每个表项中提供的存储固定最大预取深度。</p>
<p>Chou和合著者观察到，在乱序核中，指令窗口经常导致几个片外失误并发[56]。当这组miss被处理时，执行会停止。一旦这些错误返回，指令窗口就可以前进，并且可以计算相关的地址，从而允许并行地发出下一组错误。它们将这些组中发出的失败次数的平均值称为应用程序的内存级并行性。</p>
<h3 id="IMPROVING-LOOKAHEAD-VIA-DEAD-BLOCK-PREDICTION"><a href="#IMPROVING-LOOKAHEAD-VIA-DEAD-BLOCK-PREDICTION" class="headerlink" title="IMPROVING LOOKAHEAD VIA DEAD BLOCK PREDICTION"></a>IMPROVING LOOKAHEAD VIA DEAD BLOCK PREDICTION</h3><p>第二个方法就是为每个预取操作选较早的触发时间，</p>
<p>死块预测[51,54,60,61,62]是基于一个关键的观察，即缓存块大部分时间都在缓存死区中[63,64,65]，也就是说，它们仍然处于缓存中，但在失效或移除之前不会被再次访问。</p>
<p>死缓存块占用存储空间，但不会提供进一步的缓存命中。DBCP试图预测对缓存块最后一次访问，也就是检测死块，</p>
<p>他依赖两个预测，首先就是必须预测缓存块何时失效，这个事件可以通过code correlation [51, 54, 62], or time keeping发现，代码相关预测就是识别缓存快被移除之前访问缓存的最后一条指令，也就是，在该快变为死块之前访问，代码相关性依赖于每次缓存快进入缓存，他们往往会被相同的load和store序列访问，从分配块的初始丢失，到访问序列，最后到块失效时的最后一次访问。</p>
<p>其优点就是可以从缓存块学习到的访存序列可以应用于预测其他地址的死亡事件</p>
<p>另外，计时机制试图预测缓存块死亡的时间，而不是指示其死亡的特定访问[61]。这种方法的观察结果是，块的生命周期（以时钟周期衡量）在每次进入缓存时趋于相似。在这样的设计中，马尔可夫预取表增加了一个额外的字段，表明块最后一次进入缓存时的生存期。然后，在某个合适的安全范围（例如，比先前的寿命长一倍）之后，该块被预测为死块。</p>
<p>一旦预测到死亡事件，就必须预测一个合适的预取候选项来代替它。早期的死块预取器使用类似马尔可夫的预测表来达到这个目的[51,61]。后来的提案[54]依赖于更复杂的时间流预测器</p>
<h3 id="ADDRESSING-ON-CHIP-STORAGE-LIMITATIONS"><a href="#ADDRESSING-ON-CHIP-STORAGE-LIMITATIONS" class="headerlink" title="ADDRESSING ON-CHIP STORAGE LIMITATIONS"></a>ADDRESSING ON-CHIP STORAGE LIMITATIONS</h3><p>马尔可夫预取器限制其有效性的第二个关键方面是相关表的有限片上存储容量</p>
<p>提高马尔可夫预取器有效性的一种方法是提高片上相关表的存储效率，标签相关预取器[66]在相关表项中只存储标签而不是完整的缓存块地址。大型程序不太行</p>
<p>第二种方法是将相关表重新定位到主存，消除片上相关表的容量限制，然而，将相关表移出芯片会增加预取元数据的访问延迟，从几个时钟周期增加到芯片外内存引用的延迟</p>
<p>为了提高效率，片外关联表必须提供足够的前瞻性，以隐藏较长的元数据访问延迟一种方法是设计预取器来记录将来并行组（epoch）中内存引用的地址，如EBCP[57]。第二种方法是增加预取深度[52]；即使第一个要预取的地址块不及时，后面的地址也会预取成功。增加预取深度的一种概括是时间流[42]，它通过针对任意长度的流（即实际上无限的预取深度）来分摊片外元数据引用[67]。</p>
<h3 id="GLOBAL-HISTORY-BUFFER"><a href="#GLOBAL-HISTORY-BUFFER" class="headerlink" title="GLOBAL HISTORY BUFFER"></a>GLOBAL HISTORY BUFFER</h3><p>Nesbit和Smith在他们的全局历史缓冲区[68]中引入了一个关键的进步，就是将关联表分成两个结构：一个历史缓冲区，它按照发生的顺序在循环缓冲区中记录缺失的序列，一个索引表，它提供从地址（或其他预取触发器）到历史缓冲区中的位置的映射。历史缓冲区允许单个预取触发器指向任意长度的流。图3.3（来自[68]）说明了全局历史缓冲区的组织。</p>
<p><img src="/2025/02/05/A-Primer-on-Hardware-Prefetching/1729926738315.png" alt="1729926738315"></p>
<p>当miss发生时，GHB引用索引表，查看是否有任何信息与miss地址相关联。如果找到一个条目，检查历史缓冲区条目，看它是否仍然包含丢失的地址（条目可能已经被覆盖）。如果是，历史缓冲区中的下几个条目包含预测的流（也就是A,C,B,D,C）。历史缓冲区条目也可以用指向其他历史缓冲区位置的链接指针来增强，以使历史遍历能够根据多个顺序进行（例如，每个链接指针可以指示先前发生的相同的丢失地址，从而增加预取宽度和深度）。</p>
<p>通过改变存储在索引表中的键和历史缓冲区条目之间的链接指针，GHB设计可以利用将触发事件与预测的预取流关联起来的各种属性。Nesbit和Smith引入了GHB X&#x2F;Y形式的GHB变体分类法，其中X表示流如何本地化（即链接指针如何连接应该连续预取的历史缓冲区条目），Y表示相关方法（即查找过程如何定位候选流）[68,69]。本地化可以是全局(G)或单个PC （PC）</p>
<p>在全局本地化下，连续记录的历史缓冲区条目形成一个流。与每个历史表项相关联的指针要么指向先前出现的相同的miss地址（如上面讨论的那样，方便更高的预取宽度），要么是未使用的。在每台PC本地化下，索引表和链接指针都基于触发访问的PC连接历史缓冲区条目；一个流是通过遵循连接由同一触发PC发出的连续未命中的链接指针形成的。相关方法可以是地址相关（AC）或增量相关（DC）</p>
<p>GHB组织下的一个挑战是确定流何时结束，也就是说，预取器何时不应再获取历史缓冲区中指示的额外地址。</p>
<h3 id="STREAM-CHAINING"><a href="#STREAM-CHAINING" class="headerlink" title="STREAM CHAINING"></a>STREAM CHAINING</h3><p>流可以通过辅助查找机制将单独存储的流链接在一起来扩展，该机制可以预测从一个流到下一个流的关系[58,59]。流链接将不同pc形成的流链接在一起，以创建更长的预取序列[59]。流链依赖于连续pc本地化流之间存在时间相关性的洞察力；也就是说，相同的两个流倾向于连续地重复出现。更一般地说，可以想象流之间的有向图，指示哪个后续流最有可能跟随每个前一个流。流链使用下一个流指针扩展每个索引表项，该指针指示在此流之后使用的索引表项，以及一个置信度计数器。通过将单个pc本地化的流链接在一起，流链可以从单个触发器访问中获得更正确的预取。</p>
<h3 id="TEMPORAL-MEMORY-STREAMING"><a href="#TEMPORAL-MEMORY-STREAMING" class="headerlink" title="TEMPORAL MEMORY STREAMING"></a>TEMPORAL MEMORY STREAMING</h3><p>临时内存流[42]采用GHB存储组织，但将索引表和历史缓冲区都放在芯片外的主存中，允许它记录和重播任意长度的流，即使对于大型工作集的工作负载也是如此。</p>
<p>然而，Wenisch和合著者表明，索引表更新带宽可以通过采样索引表更新来管理，只执行历史表写入的随机子集[67,70]。他们的研究表明，占覆盖范围大部分的流要么很长，要么频繁重复。对于长数据流，索引表项很有可能在数据流开始的几次访问中被记录下来，相对于数据流的长数据流主体，牺牲了可以忽略不计的覆盖范围。对于频繁的流，即使在第一次遍历流时可能没有记录索引表项，但随着流的重复出现，记录所需项的概率迅速接近1。图3.4（来自[67]）说明了为什么抽样是有效的。</p>
<p><img src="/2025/02/05/A-Primer-on-Hardware-Prefetching/1729928033173.png" alt="1729928033173"></p>
<h3 id="IRREGULAR-STREAM-BUFFER"><a href="#IRREGULAR-STREAM-BUFFER" class="headerlink" title="IRREGULAR STREAM BUFFER"></a>IRREGULAR STREAM BUFFER</h3><p>虽然采样可以减少维护片外流元数据的开销，但查找延迟仍然很高，限制了短流的预取前瞻性。此外，片外存储排除了类似ghb的地址相关流的pc定位；在片外历史缓冲区中跟踪条目之间的链接指针太慢了</p>
<p>ISB引入了一个新的地址空间概念，即结构地址空间，它只对预取器可见。</p>
<p>两个片上表维护物理地址和结构地址之间的双向映射。</p>
<p>这些映射与TLB中的填充和替换一起从片上表转移到片外备份存储，确保片上结构包含处理器当前可以访问的地址集的元数据。</p>
<h1 id="SPATIALLY-CORRELATED-PREFETCHING"><a href="#SPATIALLY-CORRELATED-PREFETCHING" class="headerlink" title="SPATIALLY CORRELATED PREFETCHING"></a>SPATIALLY CORRELATED PREFETCHING</h1><p>利用了数据布局的规律性和重复性，虽然时间相关性依赖于重复出现的缺失序列，而不考虑特定的缺失地址，但空间相关性依赖于在时间上彼此相邻的内存访问的相对偏移量的模式。</p>
<p>空间相关性是由于数据结构布局的规律性而产生的，因为程序经常在内存中使用具有固定布局的数据结构（例如，面向对象编程语言中的对象，具有固定大小字段的数据库记录，堆栈帧）。许多高级编程语言将数据结构与缓存行和页面边界对齐，进一步提高了布局的规律性。</p>
<p>空间相关性的优势之一是相同的布局模式经常在内存中的许多对象中重复出现。因此，一旦学习了空间相关模式，就可以用来预取许多对象，从而使利用空间相关的预取器具有很高的存储效率（即，可以经常重用紧凑的模式来预取许多地址）。此外，与地址相关性（依赖于对特定地址的重复丢失）相反，空间模式可以应用于以前从未被引用过的地址，因此可以消除冷缓存丢失。</p>
<p>触发事件必须(1)提供一个键来查找描述要预取的相对位置的相关布局模式，(2)提供计算这些相对地址的基础地址。</p>
<p>直接读SMS那篇文章</p>
<h1 id="EXECUTION-BASED-PREFETCHING"><a href="#EXECUTION-BASED-PREFETCHING" class="headerlink" title="EXECUTION-BASED PREFETCHING"></a>EXECUTION-BASED PREFETCHING</h1><p>我们简要介绍的最后一类数据预取器既不依赖于缺失序列中的重复，也不依赖于数据布局；相反，基于执行的预取器寻求在指令执行和退出之前探索程序的指令序列，以发现地址计算和解引用指针。这种预取器的主要目标是比指令执行本身运行得更快，在处理器内核之前运行，同时仍然使用实际的地址计算算法来识别预取候选者。因此，这些机制根本不依赖于重复。相反，它们依赖的机制要么是总结地址计算而忽略计算的其他方面，要么是直接猜测值，要么是利用暂停周期和空闲处理器资源在指令退役之前进行探索。</p>
<p>主要就是提前执行然后猜</p>
<p>建议看runahead</p>
]]></content>
      <categories>
        <category>计算机体系结构</category>
      </categories>
  </entry>
  <entry>
    <title>A Primer on Memory Consistency</title>
    <url>/2025/02/05/A-Primer-on-Memory-Consistency/</url>
    <content><![CDATA[<h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h1><blockquote>
<p>The goal of this chapter is to explain enough about coherence to understand how consistency models interact with coherent caches, but not to explore specific coherence protocols or implementations, which are topics we defer until the second portion of this primer in Chapters 6–9.</p>
</blockquote>
<h2 id="MEMORY-CONSISTENCY"><a href="#MEMORY-CONSISTENCY" class="headerlink" title="MEMORY CONSISTENCY"></a>MEMORY CONSISTENCY</h2><p>内存一致性根据load和sw定义了正确的共享内存行为,并不涉及缓存一致性</p>
<p>假设一门课最初在152教室,开学前一天,教务处把他变为252,干这个事情的人收到消息,准备向学生发布信息,检查更新的时间表,比如网站管理员太忙了,没立即发布新教室，一个同学收到短信立即去检查教师，这时候仍然是152，尽管网上的时间表最终被更新到252号房间，注册员也按照正确的顺序写了“写”，但这位勤奋的学生却按照不同的顺序观察，因此走错了房间。内存一致性模型就是定义这种行为是否正确</p>
<blockquote>
<p>we need to define shared memory correctness—that is, which shared memory behaviors are allowed—so that programmers know what to expect and implementors know the limits to<br>what they can provide</p>
</blockquote>
<p>共享内存正确性由内存一致性模型指定，或者更简单地说，由内存模型指定。内存模型指定使用共享内存执行的多线程程序所允许的行为。对于使用特定输入数据执行的多线程程序，内存模型指定动态加载可能返回的值以及内存可能的最终状态。与单线程执行不同，通常允许多个正确的行为，这使得理解内存一致性模型变得微妙。</p>
<p>第3章介绍了内存一致性模型的概念，并介绍了最强大、最直观的一致性模型——顺序一致性（SC）。本章首先阐述了指定共享内存行为的必要性，并精确定义了什么是内存一致性模型。接下来将深入研究直观的SC模型，该模型指出，多线程执行应该看起来像每个组成线程的顺序执行的交错，就好像线程在单核处理器上进行时间复用一样。除了这种直觉之外，本章还将SC形式化，并以简单而积极的方式探索实现SC的一致性，最后以MIPS R10000案例研究告终</p>
<p>在第4章中，专注于x86和SPARC系统实现的内存一致性模型。这种一致性模型称为总存储顺序（TSO），其动机是希望在将结果写入缓存之前，使用先入先出的写缓冲区来保存已提交存储的结果。这种优化违反了SC，但保证了足够的性能优势，从而激发了架构来定义TSO，从而允许这种优化。在本章中，我们将展示如何从我们的SC形式化中形式化TSO， TSO如何影响实现，以及SC和TSO如何比较</p>
<p>最后，第5章介绍了“宽松”或“弱”内存一致性模型。如果一个线程更新10个数据项，然后更新一个同步标志，程序员通常不关心数据项是否按顺序更新，而只关心在更新标志之前更新所有数据项。宽松模型试图捕捉这种增加的排序灵活性，以获得更高的性能或更简单的实现。</p>
<h2 id="CACHE-COHERENCE"><a href="#CACHE-COHERENCE" class="headerlink" title="CACHE COHERENCE"></a>CACHE COHERENCE</h2><p>如果多个参与者（例如，多个核心）访问数据的多个副本（例如，在多个缓存中），并且至少有一次访问是写操作，则可能出现一致性问题。考虑一个类似于内存一致性示例的示例。学生查看在线课程表，发现计算机体系结构课程在152教室（读取数据），并将此信息复制到她的笔记本（缓存数据）。随后，大学注册官决定将班级移至252室，并更新在线时间表（写入数据）。学生的数据副本现在已经过期了。</p>
<p>如果她去152号房，她会找不到她的班级。不连贯的例子来自计算世界，但不包括计算机体系结构，包括陈旧的web缓存和程序员使用未更新的代码库。</p>
<p>使用一致性协议可以防止对陈旧数据（不一致性）的访问，一致性协议是由系统内的分布式参与者集实现的一组规则。相干协议有许多变体，但遵循几个主题</p>
<p>第6章介绍了缓存一致性协议的总体情况，并为后续章节的具体一致性协议奠定了基础。本章涵盖了大多数相干协议共享的问题，包括缓存控制器和内存控制器的分布式操作以及常见的MOESI相干状态：修改(M)、拥有(O)、独占(E)、共享(S)和无效(I)。重要的是，本章还介绍了我们的表驱动方法，用于呈现具有稳定（例如MOESI）和瞬态相干状态的协议</p>
<blockquote>
<p>Transient states are required in real implementations because modern systems rarely permit atomic transitions from one stable state to another (e.g., a read miss in state Invalid will spend some time waiting for a data response before it can enter state Shared).</p>
</blockquote>
<p>第7章涵盖snoop缓存一致性协议，直到最近才主导商业市场。在手波级别，窥探协议很简单。当缓存丢失发生时，内核的缓存控制器将为共享总线进行仲裁并广播其请求。共享总线确保所有控制器以相同的顺序观察所有请求，因此所有控制器可以协调它们各自的分布式操作，以确保它们保持全局一致的状态。</p>
<p>然而，窥探变得复杂，因为系统可能使用多个总线，而现代总线不能自动处理请求。现代总线具有仲裁队列，并且可以发送单播、管道延迟或乱序的响应。所有这些特征导致了更多的瞬态一致态。第七章总结了Sun UltraEnterprise E10000和IBM Power5的案例研究</p>
<p>第8章深入研究了目录缓存一致性协议，缓存丢失请求来自下一级缓存（或内存）控制器的内存位置，下一级缓存（或内存）控制器维护一个目录，该目录跟踪哪些缓存保存哪些位置。根据所请求内存位置的目录条目，控制器向请求者发送响应消息，或将请求消息转发给当前缓存内存位置的一个或多个参与者。每个消息通常有一个目的地（即，没有广播或多播），但是瞬态相干状态大量存在，因为从一个稳定相干状态转换到另一个稳定相干状态可以生成许多与系统中参与者数量成比例的消息。</p>
<p>第9章深入研究更复杂的系统模型和优化，重点关注窥探和目录协议中常见的问题。最初的主题包括处理指令缓存、多级缓存、透写缓存、（tlb）、（DMA）、虚拟缓存</p>
<h1 id="Coherence-Basics"><a href="#Coherence-Basics" class="headerlink" title="Coherence Basics"></a>Coherence Basics</h1><p>本书用的模型</p>
<p><img src="/2025/02/05/A-Primer-on-Memory-Consistency/1730445518843.png" alt="1730445518843"></p>
<p>不一致什么时候发生</p>
<p><img src="/2025/02/05/A-Primer-on-Memory-Consistency/1730445675692.png" alt="1730445675692"></p>
<p>一致性协议做的就是在Time3让core2观察到的数据是core1的数据，而不是来自内存的老数据</p>
<h2 id="DEFINING-COHERENCE"><a href="#DEFINING-COHERENCE" class="headerlink" title="DEFINING COHERENCE"></a>DEFINING COHERENCE</h2><p>我们首选的相干定义的基础是单写入多读取（SWMR）不变量。对于任何给定的内存位置，在任何给定的时刻，要么有一个核心可以写它（也可以读它），要么有一些核心可以读它。因此，永远不会有这样的情况：一个内核可以写入给定的内存位置，而其他内核可以同时读取或写入该位置。查看此定义的另一种方式是考虑，对于每个内存位置，内存位置的生命周期被划分为多个epoch。在每个epoch中，要么单个内核具有读写访问权限，要么若干内核（可能为零）具有只读访问权限。图2.3展示了一个示例内存位置的生命周期，它分为四个epoch，以保持SWMR不变性。</p>
<p>除了SWMR不变量外，一致性还要求给定内存位置的值被正确传播。为了解释为什么值很重要，让我们重新考虑图2.3中的例子。即使SWMR不变式成立，如果在第一个只读epoch， core 2和core 5可以读取不同的值，那么系统是不一致的。同样，core1没有读到core3写入的最新数据，这种情况也是不一致</p>
<p><img src="/2025/02/05/A-Primer-on-Memory-Consistency/1730446001109.png" alt="1730446001109"></p>
<blockquote>
<p>Coherence invariants</p>
<ol>
<li>Single-Writer, Multiple-Read (SWMR) Invariant. For any memory location A, at any<br>given (logical) time, there exists only a single core that may write to A (and can also read it)<br>or some number of cores that may only read A.</li>
<li>Data-Value Invariant. The value of the memory location at the start of an epoch is the same<br>as the value of the memory location at the end of its last read–write epoch.</li>
</ol>
</blockquote>
<blockquote>
<p>注意：第二句话的意思就是core1读的数据应该来自core3写的数据的位置，缓存一致性是架构不可见的</p>
</blockquote>
<h1 id="Memory-Consistency-Motivation-and-Sequential-Consistency"><a href="#Memory-Consistency-Motivation-and-Sequential-Consistency" class="headerlink" title="Memory Consistency Motivation and Sequential Consistency"></a>Memory Consistency Motivation and Sequential Consistency</h1><h2 id="PROBLEMS-WITH-SHARED-MEMORY-BEHAVIOR"><a href="#PROBLEMS-WITH-SHARED-MEMORY-BEHAVIOR" class="headerlink" title="PROBLEMS WITH SHARED MEMORY BEHAVIOR"></a>PROBLEMS WITH SHARED MEMORY BEHAVIOR</h2><p>首先从一个例子开始：大多数程序员会期望内核C2的寄存器r2应该得到值NEW。然而，在今天的一些计算机系统中，r2可以是0。硬件可以通过对核心C1的存储S1和S2重新排序，使r2的值为0。在本地（即，如果我们只看C1的执行而不考虑与其他线程的交互），这种重新排序似乎是正确的，因为S1和S2访问不同的地址。</p>
<p><img src="/2025/02/05/A-Primer-on-Memory-Consistency/1730446984705.png" alt="1730446984705"></p>
<p><img src="/2025/02/05/A-Primer-on-Memory-Consistency/1730447217006.png" alt="1730447217006"></p>
<p>还有一个例子</p>
<p><img src="/2025/02/05/A-Primer-on-Memory-Consistency/1730447306750.png" alt="1730447306750"></p>
<p>大家期待的结果：</p>
<p><img src="/2025/02/05/A-Primer-on-Memory-Consistency/1730447367289.png" alt="1730447367289"></p>
<p>实际两者都可以为0</p>
<p>内存一致性模型，或者更简单地说，内存模型，是对使用共享内存执行的多线程程序所允许的行为的规范。对于使用特定输入数据执行的多线程程序，它指定了动态加载可能返回的值以及内存的最终状态。与单线程执行不同，通常允许多个正确的行为，正如我们将看到的顺序一致性</p>
<h2 id="CONSISTENCY-VS-COHERENCE"><a href="#CONSISTENCY-VS-COHERENCE" class="headerlink" title="CONSISTENCY VS. COHERENCE"></a>CONSISTENCY VS. COHERENCE</h2><p>缓存一致性不等于内存一致性。</p>
<p>内存一致性实现可以使用缓存一致性作为有用的“黑盒”。</p>
<h2 id="BASIC-IDEA-OF-SEQUENTIAL-CONSISTENCY-SC"><a href="#BASIC-IDEA-OF-SEQUENTIAL-CONSISTENCY-SC" class="headerlink" title="BASIC IDEA OF SEQUENTIAL CONSISTENCY (SC)"></a>BASIC IDEA OF SEQUENTIAL CONSISTENCY (SC)</h2><p>Lamport首先将单处理器（核心）称为顺序处理器，如果“执行的结果与按照程序指定的顺序执行的操作相同”。然后，如果“任何执行的结果都与所有处理器（核心）的操作以某种顺序执行的结果相同，并且每个处理器（核心）的操作按照其程序指定的顺序出现在该顺序中”，他称之为多处理器顺序一致性。这种操作的总顺序称为内存顺序。在SC中，内存顺序尊重每个核心的程序顺序，但其他一致性模型可能允许内存顺序并不总是尊重程序顺序。</p>
<p><img src="/2025/02/05/A-Primer-on-Memory-Consistency/1730448867624.png" alt="1730448867624"></p>
<p>上图p表示程序顺序,m表示内存顺序,op1 &lt;m op2表示内存顺序中OP1先于OP2,op1&lt;p op2表示在给定的核心,op1程序顺序先于op2,在SC模型中,内存顺序尊重程序顺序,尊重”意味着op1 &lt;p op2意味着op1 &lt;m op2</p>
<p><img src="/2025/02/05/A-Primer-on-Memory-Consistency/1730449179860.png" alt="1730449179860"></p>
<h2 id="A-LITTLE-SC-FORMALISM"><a href="#A-LITTLE-SC-FORMALISM" class="headerlink" title="A LITTLE SC FORMALISM"></a>A LITTLE SC FORMALISM</h2><p>我们采用Weaver和Germond[17（附录D）]的形式：L(a)和S(a)分别表示加载和存储，以解决a的问题。命令&lt;p和&lt;m分别定义程序和全局内存顺序。程序顺序&lt;p是每个核的总顺序，它捕获每个核在逻辑上（顺序）的顺序。全局内存顺序&lt;m是所有内核内存操作的总顺序</p>
<blockquote>
<p>An SC execution requires:All cores insert their loads and stores into the order &lt;m respecting their program order,<br>regardless of whether they are to the same or different addresses (i.e., a&#x3D;b or a≠b). There are four<br>cases:</p>
<p><img src="/2025/02/05/A-Primer-on-Memory-Consistency/1730449461351.png" alt="1730449461351"></p>
<p>Every load gets its value from the last store before it (in global memory order) to the same<br>address:<br>Value of L(a) &#x3D; Value of MAX &lt;m {S(a) | S(a) &lt;m L(a)}, where MAX &lt;m denotes “latest in<br>memory order.”</p>
</blockquote>
<p>也即是每个load的值来自全局顺序最近相同地址的数据</p>
<p><img src="/2025/02/05/A-Primer-on-Memory-Consistency/1730449652267.png" alt="1730449652267"></p>
<p>“X”表示这些操作必须按程序顺序执行。</p>
<h2 id="NAIVE-SC-IMPLEMENTATIONS"><a href="#NAIVE-SC-IMPLEMENTATIONS" class="headerlink" title="NAIVE SC IMPLEMENTATIONS"></a>NAIVE SC IMPLEMENTATIONS</h2><p>两种方法</p>
<p><strong>The Multitasking Uniprocessor</strong></p>
<p>首先，可以通过在单个顺序核心（单处理器）上执行所有线程来实现多线程用户级软件的SC。线程T1的指令在核心C1上执行，直到上下文切换到线程T2，等等。在上下文切换时，任何挂起的内存操作必须在切换到新线程之前完成。检查显示所有SC规则都得到遵守。</p>
<p><strong>The Switch</strong></p>
<p>其次，可以使用一组核心Ci、单个开关和内存来实现SC，如图3.3所示。假设每个核心按其程序顺序一次向交换机提供一个内存操作。每个核心可以使用任何不影响其向交换机呈现内存操作的顺序的优化。</p>
<p><img src="/2025/02/05/A-Primer-on-Memory-Consistency/1730457312942.png" alt="1730457312942"></p>
<p>这些实现性能随着核心增加不一定会增加</p>
<h2 id="A-BASIC-SC-IMPLEMENTATION-WITH-CACHE-COHERENCE"><a href="#A-BASIC-SC-IMPLEMENTATION-WITH-CACHE-COHERENCE" class="headerlink" title="A BASIC SC IMPLEMENTATION WITH CACHE COHERENCE"></a>A BASIC SC IMPLEMENTATION WITH CACHE COHERENCE</h2><p>缓存一致性使SC实现可以完全并行地执行无冲突的加载和存储（如果两个操作位于相同的地址，并且至少其中一个是存储，则两个操作会发生冲突）。此外，创建这样一个系统在概念上很简单。</p>
<p>在这里，我们将相干性主要视为实现第2章的单写多读（SWMR）不变量的黑盒。我们通过稍微打开相干块框来展示简单的一级（L1）缓存来提供一些实现直觉：</p>
<p>使用状态修改(M)来表示一个内核可以写入和读取的L1块，使用状态共享(S)来表示一个或多个内核只能读取的L1块，并使用GetM和GetS分别表示在M和S中获取块的一致性请求。</p>
<p><img src="/2025/02/05/A-Primer-on-Memory-Consistency/1730457798027.png" alt="1730457798027"></p>
<p>图3.4(b)稍微“打开”内存系统黑盒子，显示每个核心连接到自己的L1缓存（我们将在后面讨论多线程）。如果B具有适当的一致性权限（状态M for store或S for load），则存储系统可以响应加载或存储到块B</p>
<p>此外，如果相应的L1缓存具有适当的权限，则内存系统可以并行响应来自不同内核的请求。</p>
<p>例如，图3.5(a)描述了四个内核各自寻求执行内存操作之前的缓存状态。这四个操作不冲突，可以由它们各自的L1缓存来满足，因此可以并发执行。如图3.5(b)所示，我们可以任意排序这些操作以获得合法的SC执行模型。更一般地说，可以由L1缓存满足的操作总是可以并发地完成，因为coherence的单写多读不变性确保了它们不冲突。</p>
<p><img src="/2025/02/05/A-Primer-on-Memory-Consistency/1730457922381.png" alt="1730457922381"></p>
<h2 id="OPTIMIZED-SC-IMPLEMENTATIONS-WITH-CACHE-COHERENCE"><a href="#OPTIMIZED-SC-IMPLEMENTATIONS-WITH-CACHE-COHERENCE" class="headerlink" title="OPTIMIZED SC IMPLEMENTATIONS WITH CACHE COHERENCE"></a>OPTIMIZED SC IMPLEMENTATIONS WITH CACHE COHERENCE</h2><p>大多数真正的核心实现都比我们的基本SC实现要复杂得多。内核采用预取、推测执行和多线程等特性来提高性能和容忍内存访问延迟。这些特性与内存接口交互，现在我们讨论这些特性如何影响SC的实现</p>
<p><strong>Non-Binding Prefetching</strong></p>
<p>块B的非绑定预取是向一致性内存系统请求更改块B在一个或多个缓存中的一致性状态，最常见的是，预取是由软件、核心硬件或缓存硬件请求的，以改变一级缓存中B的状态，以允许load（例如，B的状态是M或S）或通过发出一致性请求（例如GetS和GetM）来load和store（B的状态是M）</p>
<blockquote>
<p>Importantly, in no case does a non-binding prefetch change the state of a register or data in block B.</p>
</blockquote>
<p>非绑定预取的效果仅限于图3.4中的“cache-coherent memory system”块内，使得非绑定预取对内存产生影响等同于无操作，<strong>只要加载和存储是按程序顺序执行的，以什么顺序获得一致性权限并不重要</strong></p>
<p>可以在不影响内存一致性模型的情况下进行非绑定预取。这对于内部缓存预取（例如，流缓冲区）和更激进的内核都很有用。</p>
<p>Non-Binding Prefetching：预取来的数据单独放一个空间，</p>
<p><strong>Speculative Cores</strong></p>
<p>考虑一个按程序顺序执行指令的核心，但也执行分支预测，其中后续指令（包括加载和存储）开始执行，但可能会因分支错误预测而被丢弃（即，使其效果无效）。这些丢弃的加载和存储可以看起来像非绑定预取，使这种推测是正确的，因为它对 SC 没有影响。分支预测之后的加载可以呈现给 L1 缓存，其中它要么未命中（导致非绑定 GetS 预取）要么命中，然后将值返回到寄存器。如果加载被丢弃，核心会丢弃寄存器更新，从而消除加载的任何功能影响——就好像它从未发生过一样。缓存不会撤消非绑定预取，因为这样做不是必需的，并且如果重新执行加载，预取块可以提高性能。对于store，核心可能会提前发出非绑定 GetM 预取，但它不会将store呈现给缓存，直到store被保证提交。（store buffer）</p>
<p>感觉说的意思就是分支预测错误路径的load发出请求，可以类似于预取</p>
<p><strong>Dynamically Scheduled Cores</strong></p>
<p>也就是乱序执行的CPU核，</p>
<p>然而，在多核处理器的上下文中，动态调度引入了一个新的问题：内存 consistency 的推测。考虑一个希望动态重新排序两个加载指令 L1 和 L2 的核心（例如，因为在计算 L1 地址之前计算 L2 地址）。许多核心将会在 L1 之前推测性地执行 L2 ，它们预测这种重新排序对其他核心不可见，这将违反 SC。</p>
<p>对 SC 的推测需要核心验证预测是否正确。 Gharachorloo 等人 [8] 提出了两种执行此检查的技术。首先，在核心推测性地执行 L2 之后，但在它提交 L2 之前，核心可以检查推测性访问的块是否没有离开缓存。只要块保留在缓存中，它的值就不会在加载执行和提交之间发生变化。为了执行此检查，核心跟踪 L2 加载的地址，并将其与被驱逐的块和传入的 coherence 请求进行比较。传入的 GetM 表明另一个核心可以观察 L2 乱序，并且此 GetM 将暗示错误推测并丢弃推测执行。</p>
<p>第二种检查技术是在核心准备好提交加载时重放每个推测性加载（注2）[2, 17]。如果提交时加载的值不等于先前推测加载的值，则预测不正确。在示例中，如果重放的 L2 加载值与 L2 的原始加载值不同，则加载-加载重新排序导致执行明显不同，推测执行必须被丢弃。</p>
<p><strong>Non-Binding Prefetching in Dynamically Scheduled Cores</strong></p>
<p>动态调度的核心可能会遇到程序顺序不正确的加载和存储缺失。例如，假设程序顺序是加载 A，存储 B，然后存储 C。核心可能会“乱序”启动非绑定预取，例如，首先是 GetM C，然后是并行的 GetS A 和 GetM B。 SC 不受非绑定预取顺序的影响。 SC 只要求核心的加载和存储（看起来）按程序顺序访问其一级缓存。Coherence 要求一级缓存块处于适当的状态以接收加载和存储。</p>
<p>重要的是，SC（或任何其他内存 consistency 模型）：</p>
<ul>
<li>规定加载和存储（出现）应用于 coherent 内存的顺序，但不规定 coherence 活动的顺序。</li>
</ul>
<p><strong>Multithreading</strong></p>
<p>SC 实现可以容纳多线程——粗粒度、细粒度或同时的。 每个多线程核心应该在逻辑上等同于多个（虚拟）核心，它们通过一个交换机共享每个一级缓存，其中缓存选择接下来要服务的虚拟核心。 此外，每个缓存实际上可以同时服务多个非冲突请求，因为它可以假装它们是按某种顺序服务的。 一个挑战是确保线程 T1 在存储对其他核心上的线程“可见”之前无法读取同一核心上另一个线程 T2 写入的值。 因此，虽然线程 T1 可以在线程 T2 以内存顺序插入存储后立即读取该值（例如，通过将其写入状态 M 的缓存块），但它无法从处理器核心中的共享加载存储队列中读取该值。</p>
<h1 id="TSO"><a href="#TSO" class="headerlink" title="TSO"></a>TSO</h1><p>继续考虑这个例子，</p>
<p><img src="/2025/02/05/A-Primer-on-Memory-Consistency/1730461038218.png" alt="1730461038218"></p>
<p>假设多核处理器具有顺序核心，其中每个核心都有一个单入口写入缓冲区并按以下顺序执行代码。</p>
<ol>
<li>核心 C1 执行存储 S1，但在其写缓冲区中缓冲新存储的 NEW 值。</li>
<li>同样，核心 C2 执行存储 S2 并将新存储的 NEW 值保存在其写缓冲区中。</li>
<li>接下来，两个核心执行各自的加载 L1 和 L2，并获得旧值 0。</li>
<li>最后，两个核心的写缓冲区使用新存储的值 NEW 更新内存。</li>
</ol>
<p>最后的结果就是（0，0）正如我们在上一章中看到的，这是 SC 禁止的执行结果。没有写缓冲区，硬件就是 SC，但有了写缓冲区，它就不是了，这使得写缓冲区在多核处理器中在架构上是可见的。</p>
<h2 id="4-2-TSO-X86-的基本思想"><a href="#4-2-TSO-X86-的基本思想" class="headerlink" title="4.2 TSO&#x2F;X86 的基本思想"></a>4.2 TSO&#x2F;X86 的基本思想</h2><p><img src="https://file+.vscode-resource.vscode-cdn.net/c%3A/Users/Legion/Desktop/arch_note/%E7%AE%80%E5%8D%95%E7%9A%84%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/1730374094456.png" alt="1730374094456"></p>
<p>本地的store和load需要按照顺序，但全局不需要按照顺序</p>
<p><img src="/2025/02/05/A-Primer-on-Memory-Consistency/1730461402725.png" alt="1730461402725"></p>
<p>程序员（或编译器）可以通过在核心 C1 上的 S1 和 L1 之间以及核心 C2 上的 S2 和 L2 之间插入 FENCE 指令来阻止图 4.2d 中的执行。在核心 Ci 上执行 FENCE 可确保 Ci 上 FENCE 之前的内存操作（按程序顺序）按照内存顺序放置在 Ci 上 FENCE 之后的内存操作之前。使用 TSO 的程序员很少使用 FENCE（又名内存屏障），因为 TSO 对大多数程序“做正确的事”。尽管如此，FENCE 在下一章讨论的宽松模型中发挥着重要作用。</p>
<p>TSO 确实允许一些非直观的执行结果。表 4.3 说明了表 4.1 中程序的修改版本，其中核心 C1 和 C2 分别制作 x 和 y 的本地副本。许多程序员可能假设如果 r2 和 r4 都等于 0，那么 r1 和 r3 也应该为 0，因为存储 S1 和 S2 必须在加载 L2 和 L4 之后插入到内存顺序中。然而，图 4.3 展示了一个执行，显示 r1 和 r3 绕过每个核心写入缓冲区中的值 NEW。事实上，为了保持单线程顺序语义</p>
<p>，每个核心都必须按照程序顺序看到自己存储的效果，即使存储还没有被其他核心观察到。因此，在所有 TSO 执行下，本地副本 r1 和 r3 将始终设置为 NEW 值。</p>
<p><img src="/2025/02/05/A-Primer-on-Memory-Consistency/1730461478140.png" alt="1730461478140"></p>
<h1 id="Relaxed-Memory-Consistency"><a href="#Relaxed-Memory-Consistency" class="headerlink" title="Relaxed Memory Consistency"></a>Relaxed Memory Consistency</h1><p>本文介绍RVWMO模型</p>
<p><img src="https://file+.vscode-resource.vscode-cdn.net/c%3A/Users/Legion/Desktop/arch_note/%E7%AE%80%E5%8D%95%E7%9A%84%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/1730374321974.png" alt="1730374321974"></p>
<p>在RVWMO下，从同一hart中的其他内存指令的角度来看，在单个hart上运行的代码似乎是按顺序执行的，但是来自另一个hart的内存指令可能会观察到来自第一个hart的内存指令以不同的顺序执行。因此，多线程代码可能需要显式的同步，以保证不同内存指令之间的顺序。基本的RISC-V ISA为这个目的提供了一个FENCE指令，在2.7节中描述，而原子扩展“a”额外定义了load-reserved&#x2F;storeconditional和原子读-修改-写指令。</p>
<h2 id="17-1-Definition-of-the-RVWMO-Memory-Model"><a href="#17-1-Definition-of-the-RVWMO-Memory-Model" class="headerlink" title="17.1. Definition of the RVWMO Memory Model"></a>17.1. Definition of the RVWMO Memory Model</h2><p><img src="/2025/02/05/A-Primer-on-Memory-Consistency/1730471256394.png" alt="1730471256394"></p>
<h3 id="17-1-1-Memory-Model-Primitives"><a href="#17-1-1-Memory-Model-Primitives" class="headerlink" title="17.1.1. Memory Model Primitives"></a>17.1.1. Memory Model Primitives</h3><p>注：ac表示指令顺序后的指令不能先于这条指令执行，rl表示指令顺序前的指令不能后于这条指令</p>
<p>如下图，注：LDAR代表load具有acquire语义，STLR代表store具有release语义。</p>
<p><img src="https://wximg.eefocus.com/forward?url=https://mmbiz.qpic.cn/sz_mmbiz_png/v29lLKYGWtt1JrFbE9mAeNiaID69UicvuAMBL2d3pnGyMUsUfQ9Z1smmIzWYa1hsc2KK4fyRGqrEZ601NKG99I4A/640?wx_fmt=png&s=2239a3" alt="img"></p>
<p><img src="https://wximg.eefocus.com/forward?url=https://mmbiz.qpic.cn/sz_mmbiz_png/v29lLKYGWtt1JrFbE9mAeNiaID69UicvuA0CjtxQlKr6nXiaVfI8mb5hMu2hBpdLvJPI2hoK5fvdS7LgUYkQPW3OA/640?wx_fmt=png&s=7ff2d2" alt="img"></p>
<p>内存操作的程序顺序反映了生成每次加载和存储的指令在该处理器的动态指令流中逻辑布局的顺序；即，一个简单的有序处理器执行该处理器指令的顺序。</p>
<p>不对齐的加载或存储指令可以分解为一组任意粒度的组件内存操作。XLEN&lt;64的FLD或FSD指令也可以分解为一组任意粒度的组件内存操作。由这些指令产生的存储器操作并不按照程序顺序彼此排序，但是它们通常按照程序顺序按照前面和后面的指令产生的存储器操作进行排序。原子扩展“A”根本不需要执行环境来支持不对齐的原子指令。但是，如果通过不对齐的原子性颗粒PMA支持不对齐的原子，则原子性颗粒中的AMOs不会被分解，基本isa中也不会定义负载和存储，也不会在F、D和Q扩展中定义不超过XLEN位的负载和存储。</p>
<blockquote>
<p>The decomposition of misaligned memory operations down to byte granularity facilitates emulation on implementations that do not natively support misaligned accesses. Such implementations might, for example, simply iterate over the bytes of a misaligned access one by one.</p>
</blockquote>
<p>如果LR指令在程序顺序上先于SC指令，并且中间没有其他LR或SC指令，则称LR指令和SC指令成对；相应的内存操作也被称为成对的（除了SC失败的情况，没有生成存储操作）。第14.2节定义了决定SC是否必须成功、可能成功或必须失败的完整条件列表。</p>
<p>Load和store操作也可以携带一个或多个顺序注释，这些注释来自以下集合：“acquire-RCpc”、“acquire-RCsc”、“release-RCpc”和“release-RCsc”。带有aq集的AMO或LR指令具有“acquire-RCsc”注释。带有rl集的AMO或SC指令有一个“release-RCsc”注释。具有aq和rl集的AMO、LR或SC指令同时具有“acquire-RCsc”和“release-RCsc”注释。</p>
<blockquote>
<p>For convenience, we use the term “acquire annotation” to refer to an acquire-RCpc annotation or an acquire-RCsc annotation. Likewise, a “release annotation” refers to a release-RCpc annotation or a release-RCsc annotation. An “RCpc annotation” refers to an acquire-RCpc annotation or a releaseRCpc annotation. An RCsc annotation refers to an acquire-RCsc annotation or a release-RCsc annotation.</p>
</blockquote>
<p>在内存模型文献中，术语“RCpc”表示与处理器一致的同步操作的释放一致性，术语“RCsc”表示与顺序一致的同步操作的释放一致性。</p>
<p>尽管有许多不同的获取和发布注释的定义，RCpc注释目前只在隐式分配给每个标准扩展“Ztso”的内存访问时使用（第18章）。此外，尽管ISA目前不包含本机加载获取或存储释放指令，也不包含其RCpc变体，但RVWMO模型本身被设计为向前兼容，以便在将来的扩展中将上述任何或全部添加到ISA中。</p>
<p>RCpc语义”代表“Acquire-RCpc”或“Release-RCpc”。“RCsc语义”代表“Acquire-RCsc”或“Release-RCsc”。Load(store)可以携带任何一种ACQUIRE(RELEASE)语义，而RMW只能携带RCsc语义。这些语义有如下保序：</p>
<p>ACQUIRE -&gt; Load,Store   (ACQUIRE代表ACQUIRE-RCsc和ACQUIRE-RCpc)</p>
<p>Load,Store -&gt; RELEASE (RELEASE 代表RELEASE-RCsc和RELEASE-RCpc)</p>
<p>RELEASE-RCsc -&gt; ACQUIRE-RCsc  (注意RELEASE-RCpc -&gt; ACQUIRE-RCpc不成立)</p>
<p>从上述保序公式可以看出：</p>
<p>带有RELEASE-RCpc的older store指令的写数据可以直接被forward给带有ACQUIRE-RCpc的同地址younger load指令。</p>
<p>如果它们两个是不同地址，那么在younger load指令会先于older store指令出现在global memory order上。</p>
<p>上述这两点是RCsc不允许的，RCsc具有更强的保序行为。 <strong>为什么RCsc和RCpc有这两点区别</strong> ，看它们的全称就知道了。</p>
<p>“RCpc”代表release consistency with processor-consistent synchronization operations。</p>
<p>“RCsc”代表release consistency with sequentially consistent synchronization operations。</p>
<p> <strong>RCpc语义有processor-consistent特性</strong> 。Processor consistency(PC)表示一个Core的store操作按顺序达到其它Core，但不一定同时达到其它Core。TSO模型是PC的特殊情况，其中每个Core都可以立即看到自己的Store操作，但是当任何其它Core看到Store操作时，所有其它Core都可以看到它，这个属性称为write atomicity。</p>
<p> <strong>RCsc语义有sequentially consistent特性</strong> 。Sequential consistency (SC)模型中，memory order保留了每个core的program order。也就是SC模型为同一个线程的两个指令间的所有四种load和store组合(Load -&gt; Load, Load -&gt; Store, Store -&gt; Store, and Store -&gt; Load)保留了顺序。</p>
<p>因此RCpc和RCsc在行为上还是有些区别，RCsc语义可以让RVWMO模型像SC(Sequential Consistency)模型行为一样，RCpc语义可以让RVWMO像TSO(Total Store Order)内存模型行为一样， <strong>这极大方便了其它<a href="https://www.eefocus.com/baike/1552575.html">CPU</a>内存模型的代码移植到RISC-V CPU上运行</strong> 。比如要迁移MIPS R10000的代码到RISC-V CPU上，可以使用RCsc的load和store指令。要迁移Intel&#x2F;<a href="https://www.eefocus.com/manufacturer/1000225/">AMD</a>的代码到RSIC-V CPU上，可以使用RCpc的load和store指令。</p>
<p>如下图，注：LDAR代表load具有acquire-RCsc语义，STLR代表store具有release-RCsc语义。LDAPA代表load具有acquire-RCpc语义。</p>
<p><img src="/2025/02/05/A-Primer-on-Memory-Consistency/1730471145989.png" alt="1730471145989"></p>
<h3 id="17-1-2-Syntactic-Dependencies"><a href="#17-1-2-Syntactic-Dependencies" class="headerlink" title="17.1.2. Syntactic Dependencies"></a>17.1.2. Syntactic Dependencies</h3><p>语法依赖关系是根据指令的源寄存器、指令的目标寄存器以及指令从源寄存器到目标寄存器携带依赖关系的方式来定义的。</p>
<p><strong>源寄存器定</strong>义：一般来说，如果满足下列任何条件之一，寄存器R(除X0)就是指令A的源寄存器：</p>
<ul>
<li>在指令A的操作码中，rs1、rs2或rs3被设置为R；</li>
<li>A是CSR指令，在A的操作码中，csr被设置为R。如果A是CSRRW或CSRRWI，需要rd不是x0；</li>
<li>R是CSR，且是指令A的隐式源寄存器；</li>
<li>R是CSR，它是A的另一个源寄存器别名；</li>
</ul>
<p><strong>目的寄存器定义</strong>：一般来说，如果满足下列任何条件之一，寄存器R(除x0)就是指令A的目的寄存器：</p>
<ul>
<li>在指令A的操作码中，rd被设置为R；</li>
<li>A是CSR指令，在A的操作码中，CSR被设置为R。如果A为CSRRS或CSRRC，需要rs1不是x0.如果A为CSRRSI或CSRRCI，需要umm[4:0]不是0；</li>
<li>R是CSR，且是指令A的隐式目的寄存器；</li>
<li>R是CSR，它是A的另一个目的寄存器别名；</li>
</ul>
<p><strong>语法依赖定义</strong>：如果以下任何一个条件成立，那么指令j通过i的目的寄存器s和指令j的源寄存器r在语法上依赖于指令i。</p>
<ul>
<li>s和r是同一个，且在i和j之间排序的程序指令没有r作为目的寄存器；</li>
<li>在指令i和指令j之间有指令m，使得以下所有条件都成立：<ul>
<li>指令m的目的寄存器q和指令j的源寄存器r在语法上存在依赖；</li>
<li>指令m的源寄存器p和指令i的目的寄存器s在语法上存在依赖；</li>
<li>指令m的p和q存在依赖；</li>
</ul>
</li>
</ul>
<p>对于内存访问操作中， <strong>Syntactic Dependencies(语法依赖)可以分为syntactic address dependency(地址依赖)，syntactic data dependency(数据依赖)和syntactic control dependency(控制依赖)</strong> 。</p>
<p>为了说明这个三个依赖的不同之处，假设有a和b两个内存操作，i和j分别是生成a和b的指令。</p>
<p><strong>地址依赖</strong>：如果r是j的地址源操作数，并且j通过源寄存器r对i有语法依赖，则b有语法地址依赖于a。</p>
<p>指令i (操作a)：lw <strong>r</strong>,0(r1)</p>
<p>指令j (操作b)：sw  r2,0( <strong>r</strong> )</p>
<p><strong>数据依赖</strong>：如果b是一个store操作，r是j的数据源寄存器，j通过源寄存器r对i有语法依赖，那么b对a有语法数据依赖。</p>
<p>指令i (操作a)：lw <strong>r</strong>,0(r1)</p>
<p>指令j (操作b)：sw  <strong>r</strong>,0(r0)</p>
<p><strong>控制依赖</strong>：如果在i和j之间有一条指令m，m是一条分支或间接跳转指令，并且m在语法上依赖于i，则b在语法控制上依赖于a。</p>
<p>指令i (操作a)：lw <strong>r</strong>,0(r0)</p>
<p>指令m：bne <strong>r</strong>,r1,next</p>
<p>指令j (操作b)：sw  r3,0(r4)</p>
<h3 id="17-1-3-Preserved-Program-Order"><a href="#17-1-3-Preserved-Program-Order" class="headerlink" title="17.1.3. Preserved Program Order"></a>17.1.3. Preserved Program Order</h3><p>任何给定的程序执行的全局内存顺序都尊重每个hart的部分（但不是全部）程序顺序。全局内存顺序必须遵守的程序顺序的子集称为保留程序顺序，全局必须尊重本地</p>
<p>保留程序顺序的完整定义如下（请注意，AMOs同时是加载和存储）：内存操作a在保留程序顺序中先于内存操作b（因此也在全局内存顺序中），如果a在程序顺序中先于b，则a和b都访问常规主存（而不是I&#x2F;O区域），并且以下任何一种情况都有效：</p>
<p>Overlapping-Address Orderings：（其实不太理解这个名词？）</p>
<p>a操作在程序顺序中先于b操作，a和b都访问常规主存，不包含I&#x2F;O区域， <strong>如果存在以下任何一个条件</strong> ，那么a操作和b操作在全局内存顺序中的顺序也不会变。</p>
<ol>
<li>b是store，且a和b访问重叠的内存地址。</li>
<li>a和b是load，x是a和b同时读取的字节，且在a和b程序顺序之间没有store操作访问x，a和b返回x的值由不同的内存操作写入。</li>
<li>a是由AMO或SC指令生成的，b是一个load，b返回由a写入的值。</li>
</ol>
<p><strong>关于第一点</strong> ，load或store操作永远不能与后面访问重叠内存位置的store操作进行重排序。从微体系架构的角度来看，一般来说，如果投机是无效的，则很难或不可能撤回投机重排序的store操作，因此模型直接不允许这种行为。不过另一方面，store可以forward数据给后面的load操作，这种情况通常发生在store的数据暂时存放在store buffer里，之后load命中store buffer，就直接load数据走了。</p>
<p><strong>关于第二点</strong> ，其实就是要求同一个hart中，younger的load返回的值不能比同地址older load返回的值更老。这通常被称为“CoRR”(Coherence for Read-Read pairs)，或者SC模型(sequential consistency)的要求一部分， <strong>RVWMO需要强制执行CoRR排序</strong>。如下代码所示，不管程序如何执行，(f)返回的值肯定比(d)的新。</p>
<p><img src="/2025/02/05/A-Primer-on-Memory-Consistency/1730473060752.png" alt="1730473060752"></p>
<p>其实就是AMO或成功的SC必须要全局可见后，才能将值返回给后续的load操作。</p>
<p>这三个原则也适用于内存访问之间只有部分重叠的情况，而且基地址也不一定相同的。例如，当使用不同大小的操作访问同一个地址区间时，就可以发生这种情况。当使用非对齐的内存访问时，重叠地址的规则可以独立地应用于每个地址的内存访问。</p>
<p><strong>Explicit Synchronization</strong></p>
<p> <strong>显示同步指的是</strong> ：a操作在程序顺序中先于b操作，a和b都访问常规主存，不是I&#x2F;O区域，如果存在以下任何一个条件，那么a操作和b操作在全局内存顺序中的顺序也不会变。</p>
<ol>
<li><strong>a和b之间有FENCE指令。</strong></li>
<li><strong>a拥有acquire语义。</strong></li>
<li><strong>b拥有release语义。</strong></li>
<li><strong>a和b都有RCsc语义。</strong></li>
<li><strong>a和b是配对的。</strong></li>
</ol>
<p><strong>关于第四点</strong>：如果单独使用RCpc语义，就不会强制store release到load acquire的顺序，这有助于移植在TSO或RCpc内存模型下编写的代码。为了确保store release到load acquire的顺序，代码必须使用RCsc的语义。</p>
<p>在全局内存顺序中，SC必须出现在与其配对的LR之后。由于固有的语法数据依赖，通常使用LR&#x2F;SC来执行原子读-修改-写操作。但其实即使store的值在语法上不依赖于成对LR返回的值，这一点也适用。</p>
<p><strong>Syntactic Dependencies</strong></p>
<ol start="9">
<li>b has a syntactic address dependency on a</li>
<li>b has a syntactic data dependency on a</li>
<li>b is a store, and b has a syntactic control dependency on a</li>
</ol>
<p><strong>Pipeline Dependencies</strong></p>
<p>a操作在程序顺序中先于b操作，a和b都访问常规主存，不是I&#x2F;O区域，如果存在以下任何一个条件，那么a操作和b操作在全局内存顺序中的顺序也不会变。</p>
<ol>
<li>b是load，在a和b程序顺序之间存在一个store m，m的地址或数据依赖于a，b返回的值是m写的值。</li>
<li>b是store，在a和b程序顺序之间存在一些指令m，m的地址依赖于a。</li>
</ol>
<p>这两点几乎在所有真实处理器pipeline上都存在的</p>
<p><strong>关于第一点</strong>：是想表明如果old的store的地址或数据还未知的话，load是不能从store转发数据的。也就是必须等a确定执行完之后，得到了m的地址或数据了，才会执行b，所以a和b的全局顺序肯定是保证的。如下图所示。</p>
<p><img src="/2025/02/05/A-Primer-on-Memory-Consistency/1730473628480.png" alt="1730473628480"></p>
<p>(f)在(e)的数据确定之前是不能被执行的，因为(f)必须返回(e)写的值，并且在(d)有机会执行之前，旧的值不能被(e)的回写所破坏，因此，(f)将不会在(d)之前执行，也就是它们俩的顺序是固定的。</p>
<p><strong>关于第二点</strong>：它与第一点规则有着类似的观察：在可能访问同一地址的所有older load被执行之前，store不能在memory中确定执行。因为store如果提前执行的话，那么旧的值被覆盖了，那么older的load就无法读取到了。同样的，除非知道前面的指令不会由于地址解析失败而导致异常，都则通常不能执行store操作，从这个意义上说，这个一点是之前语法依赖里的控制依赖的某种特殊情况。如下图所示。</p>
<p><img src="/2025/02/05/A-Primer-on-Memory-Consistency/1730473885536.png" alt="1730473885536"></p>
<p>在(e)的地址被解析完之前，(f)不能执行，因为结果可能是地址匹配，也就是a1等于0。因此，在(d)被执行并确认(e)地址是否确实重叠之前，(f)不能被发到内存去执行的，也就是(d)和(f)的顺序是固定的。</p>
<h3 id="17-1-4-Memory-Model-Axioms"><a href="#17-1-4-Memory-Model-Axioms" class="headerlink" title="17.1.4. Memory Model Axioms"></a><strong>17.1.4. Memory Model Axioms</strong></h3><blockquote>
<p>An execution of a RISC-V program obeys the RVWMO memory consistency model only if there exists a global memory order conforming to preserved program order and satisfying the load value axiom, the atomicity axiom, and the progress axiom.</p>
</blockquote>
<p><strong>load value公理</strong></p>
<p>loadA读到的每个字节来自于store写入该字节的值，loadA可以读到store的值来自于以下两种场景：</p>
<ul>
<li><strong>在全局内存顺序中，在loadA之前的store写该字节</strong></li>
<li><strong>在program order中，在loadA之前的store写该字节 (可以forward)</strong></li>
</ul>
<p>全局内存顺序排在loadA之前的store，loadA肯定可以观察到。另外第二点意思是现在几乎所有的CPU实现中都存在store buffer，store操作的数据可能会暂时存放在这里面，而且还没有全局可见，后续younger的load其实就可以提前forward里面的写数据来执行。因此，对于其它hart来说，在全局内存顺序上将观察到load在store之前执行。</p>
<p>我们可以看下面经典的一个例子，假如这段程序是在具有store buffer的hart上运行的，那么最终结果可能是：a0&#x3D;1，a1&#x3D;0，a2&#x3D;1，a3&#x3D;0。</p>
<p><img src="/2025/02/05/A-Primer-on-Memory-Consistency/1730474359557.png" alt="1730474359557"></p>
<p>程序一种执行顺序如下：</p>
<ul>
<li>执行并进入第一个hart的store buffer；</li>
<li>执行并转发store buffer中(a)的返回值1；</li>
<li>执行，因为所有先前的load（即(b)）已完成；</li>
<li>执行并从内存中读取值0；</li>
<li>执行并进入第二个hart的store buffer；</li>
<li>执行并转发store buffer中(e)的返回值1；</li>
<li>执行，因为所有先前的load（即(f)）已经完成；</li>
<li>执行并从内存中读取值0；</li>
<li>从第一个hart的store buffer中写到内存；</li>
<li>(e)从第二个hart的store buffer中写到内存；</li>
</ul>
<p>然而，即使(b)在全局内存顺序上先于(a)和，(f)先于(e)，在本例中唯一合理的可能性是(b)返回由(a)写入的值，(f)和(e)也是如此，这种情况的结合促使了load value公理定义中的第二种选择。即使(b)在全局内存顺序上在(a)之前，(a)仍然对(b)可见，因为(b)执行时(a)位于store buffer中。因此，即使(b)在全局内存顺序上先于(a), (b)也应该返回由(a)写的值，因为(a)在程序顺序上先于(b)。(e)和(f)也是如此。</p>
<p><strong>atomicity公理</strong></p>
<p>如果r和w是分别由hart h中对齐的LR和SC指令生成的成对load和store操作，s是对字节x的store，r返回由s写的值，那么在全局内存顺序中，s必须位于w之前，并且在全局内存顺序中，除了h之外不能有其它hart的同地址store出现在s之后和w之前。</p>
<p><strong>简单说，就是如果r从s读到数据了，那么s和w之间不可能穿插其它hart的store数据了，但允许本hart穿插其它同地址store数据，由此来确保一个hart使用LR和SC的原子性</strong> 。</p>
<p><img src="/2025/02/05/A-Primer-on-Memory-Consistency/1730474927618.png" alt="1730474927618"></p>
<p>RISC-V包含两种类型的原子操作：AMO和LR&#x2F;SC对，它们的行为有所不同。LR&#x2F;SC的行为就好像旧的值返回给hart，hart对它进行修改，并写回主存，这中间不被其它hart的store打断，否则就是失败的。AMO的行为就好像是在内存中直接进行的，因此AMO本质上就是原子性的。</p>
<p><strong>progress公理</strong></p>
<p><strong>在全局内存顺序中，任何内存操作都不能在其他内存操作的无限序列之前进行</strong> 。</p>
<p>这个公理保证程序终究可以往前执行，确保来自一个hart的store最终在有限的时间内对系统中的其它hart可见，并且来自其它hart的load最终能够读取这些值。如果没有这个规则，例如spinlock在一个值上无限自旋是合法的，即使有来自其它一个hart的store等到解锁该自旋锁。</p>
<h1 id="第六章：Coherence-协议"><a href="#第六章：Coherence-协议" class="headerlink" title="第六章：Coherence 协议"></a>第六章：Coherence 协议</h1><p>在本章中，我们回到了我们在第 2 章中介绍的 cache coherence 主题。我们在第 2 章中定义了 coherence，以便理解 coherence 在支持 consistency 方面的作用，但我们没有深入研究特定的 coherence 协议是如何工作的，或者它们是如何实现的。本章先一般性地讨论了 coherence 协议，然后我们将在接下来的两章中讨论特定的协议分类。我们从 6.1 节开始介绍 coherence 协议如何工作的整体情况，然后在 6.2 节展示如何指定 (specify) 协议。我们在第 6.3 节中介绍了一个简单而具体的 coherence 协议示例，并在第 6.4 节中探讨了协议设计空间。</p>
<h2 id="6-1-整体情况"><a href="#6-1-整体情况" class="headerlink" title="6.1 整体情况"></a>6.1 整体情况</h2><p>Coherence 协议的目标是通过强制执行 (enforce) 第 2.3 节中介绍、并在此重申的不变量来保持 coherence。</p>
<ol>
<li><strong>单写多读 (Single-Writer, Multiple-Reader (SWMR)) 不变量。</strong> 对于任何内存位置 A，在任何给定的（逻辑）时间，仅存在一个核心可以读写 A、或一些核心可以只读 A。</li>
<li><strong>数据值 (Data-Value) 不变量。</strong> 一个时间段 (epoch) 开始时的内存位置的值，与其最后一个读写时间段 (epoch) 结束时的内存位置的值相同。(这句话的意思就是读到的数据必须是最新写入的数据的位置,比如B核写入位置0,但还内写入内存,然后A核读位置0,必须要求读的是B核的数据)</li>
</ol>
<p>为了实现这些不变量，我们将每个存储结构（即，每个 cache 和 LLC&#x2F;memory）关联到一个称为 <strong>coherence 控制器 (coherence controller)</strong> 的有限状态机。这些 coherence controllers 的集合 (collection) 构成了一个分布式系统。其中，控制器相互交换消息，以确保对于每个块，SWMR 和 Data-Value 不变量始终保持不变。这些有限状态机之间的交互由 coherence protocol 指定。</p>
<p>Coherence controllers 有几个职责。Cache 中的 coherence controller，我们称之为  <strong>缓存控制器 (cache controller)</strong> ，如图 6.1 所示。Cache controller 必须为来自两个来源的请求提供服务。在 “ <strong>核心侧 (core side)</strong> ”，cache controller 与处理器核心连接。控制器接受来自核心的 loads 和 stores，并将 load values 返回给核心。一次 cache miss、会导致控制器发出一个 coherence  <strong>请求 (request)</strong> （例如，请求只读权限）、来启动一个 coherence  <strong>事务 (transaction)</strong> ，其中，这个请求包含了核心所访问位置的块。这个 coherence 请求通过互连网络发送到一个或多个 coherence controllers。一个事务由一个请求和为满足请求而交换的其他消息（例如，从另一个 coherence controller 发送到请求者的数据响应消息）组成。作为每个事务的一部分，发送的事务和消息的类型、取决于特定的 coherence 协议。</p>
<p><img src="/2025/02/05/A-Primer-on-Memory-Consistency/1730558186724.png" alt="1730558186724"></p>
<p>在 cache controller 的 “ <strong>网络侧 (network side)</strong> ”，cache controller 通过互连网络与系统的其余部分连接。控制器接收它必须处理的 coherence 请求和 coherence 响应。与核心侧一样，如何处理传入的 coherence 消息、取决于特定的 coherence 协议。</p>
<p>LLC&#x2F;memory 处的 coherence 控制器，我们称之为  <strong>内存控制器 (memory controller)</strong> ，如图 6.2 所示。内存控制器类似于缓存控制器，只是它通常只有一个网络侧。因此，它不会发出 coherence 请求（为了 loads 或 stores）、或接收 coherence 响应。其他代理（例如 I&#x2F;O 设备）的行为，可能类似于缓存控制器、内存控制器、或两者都是，取决于它们的特定要求。</p>
<p><img src="/2025/02/05/A-Primer-on-Memory-Consistency/1730558199185.png" alt="1730558199185"></p>
<p>每个 coherence 控制器都会实现一组 有限状态机（逻辑上，每个块都有一个独立但相同的有限状态机），并根据块的状态接收和处理 <strong>事件 (events)</strong> （例如，传入的 coherence 消息）。</p>
<h2 id="6-2-指定-Coherence-协议"><a href="#6-2-指定-Coherence-协议" class="headerlink" title="6.2 指定 Coherence 协议"></a>6.2 指定 Coherence 协议</h2><blockquote>
<p>如果想读懂之后内容,这部分必须会</p>
</blockquote>
<p>我们通过指定 (specify) coherence 控制器来指定 coherence 协议。我们可以通过多种方式指定 coherence 控制器，但是 coherence 控制器的特定行为适合用表格规范来表示 [9]。如表 6.1 所示，我们可以将一个控制器指定为一张表，其中行对应于块状态 (states)，列对应于事件 (events)。我们将表中的一个 state&#x2F;event 条目称为一次 <strong>转换 (transition)</strong> ，与块 B 相关的事件 E 的转换包括</p>
<ul>
<li>(a) E 发生时采取的动作 (actions)，和</li>
<li>(b) 块 B 的下一个状态。</li>
</ul>
<p><strong>也就是 这种格式:做的事情&#x2F;下一个状态</strong></p>
<p>我们将转换格式表示为 “action&#x2F;next state”，如果下一个状态是当前状态，我们可以省略 “next state” 部分。作为表 6.1 中的转换示例，如果从核心接收到块 B 的 store 请求、并且块 B 处于只读状态 (RO)，则该表显示控制器的转换将是执行动作 “issue coherence request for read-write permission (to block B)”，并将块 B 的状态更改为 RW。</p>
<p><img src="/2025/02/05/A-Primer-on-Memory-Consistency/1730558345683.png" alt="1730558345683"></p>
<p>为简单起见，表 6.1 中的示例故意做得不完整，但它说明了表格规范方法捕获 coherence 控制器行为的能力。要指定 coherence 协议，我们只需要完全指定缓存控制器和内存控制器的表即可。</p>
<p>Coherence 协议之间的差异在于控制器规范之间的差异。这些差异包括不同的块状态 (block states)、事务 (transactions)、事件 (events) 和转换 (transitions)。在 6.4 节中，我们通过探索每个方面的选项、来描述 coherence 协议的设计空间，但我们首先来指定一个简单、具体的协议。</p>
<h2 id="6-3-一个简单的-Coherence-协议示例"><a href="#6-3-一个简单的-Coherence-协议示例" class="headerlink" title="6.3 一个简单的 Coherence 协议示例"></a>6.3 一个简单的 Coherence 协议示例</h2><p>为了帮助理解 coherence 协议，我们现在提出一个简单的协议。我们的系统模型是第 2.1 节中的基线系统模型，但互连网络仅限于共享总线：一组共享的连线 (wires)，核心可以在这些连线上发出消息并让所有核心和 LLC&#x2F;memory 观察到它。</p>
<p>每个缓存块可以处于两种<strong>稳定 (stable)</strong> 的 coherence 状态之一：<strong>I(nvalid)</strong> 和  <strong>V(alid)</strong> 。LLC&#x2F;memory 中的每个块也可以处于两种 coherence 状态之一：I 和 V。在 LLC&#x2F;memory 中，</p>
<ul>
<li>状态 I 表示所有缓存都将该 block 保持在状态 I，</li>
<li>状态 V 表示有一个缓存将 block 保持在状态 V。</li>
</ul>
<p>缓存块也有一个单一的<strong>瞬间 (transient)</strong> 状态，即  <strong>IV^D</strong> ，将在下面讨论。在系统启动时，所有的缓存块和 LLC&#x2F;memory 块都处于状态 I。每个核都可以向其缓存控制器发出 load 和 store 请求；当缓存控制器需要为另一个块腾出空间时，它会隐式生成一个 <strong>Evict Block</strong> 事件。缓存中未命中的 loads 和 stores 会启动 coherence 事务，如下所述，以获得缓存块的 valid 拷贝。像本入门书中的所有协议一样，我们假设了一个 <strong>写回缓存 (writeback cache)</strong> ；也就是说，当 store 命中时，它将 store 值仅写入（局部）缓存、并等待将整个块写回 LLC&#x2F;memory、以响应 Evict Block 事件。</p>
<p>我们使用三种类型的<strong>总线消息 (bus messages)</strong> 实现了两种类型的  <strong>coherence 事务 (coherence transactions)</strong> ：</p>
<ul>
<li><strong>Get 消息</strong> 用于请求一个 block，</li>
<li><strong>DataResp 消息</strong> 用于传输一个 block 的数据，</li>
<li><strong>Put 消息</strong> 用于将 block 写回内存控制器。</li>
</ul>
<blockquote>
<p>译者注：两种事务是指  <strong>Get 事务</strong> 、 <strong>Put 事务</strong> 。</p>
</blockquote>
<p>在一次 load 或 store miss 时，缓存控制器通过发送 Get 消息、并等待相应的 DataResp 消息、来启动 Get 事务。Get 事务是原子的，因为在缓存发送 Get 和该 Get 的 DataResp 出现在总线上之间，没有其他事务（Get 或 Put）可以使用总线。在 Evict Block 事件中，缓存控制器将带有整个缓存块的 Put 消息发送到内存控制器。</p>
<p>我们在图 6.3 中说明了稳定 coherence 状态之间的转换。我们使用前缀 “ <strong>Own</strong> ” 和 “ <strong>Other</strong> ” 来区分由给定缓存控制器发起的事务的消息、以及由其他缓存控制器发起的事务的消息。请注意，如果给定的缓存控制器具有处于状态 V 的块，并且另一个缓存使用 Get 消息（表示为  <strong>Other-Get</strong> ）请求它，则 owning cache 必须用一个块去响应（使用 DataResp 消息，图中未显示）、并转换到状态 I。</p>
<p><img src="/2025/02/05/A-Primer-on-Memory-Consistency/1730558825446.png" alt="1730558825446"></p>
<p>表 6.2 和 6.3 更详细地指定了协议。表中的阴影条目表示不可能的转换。例如，缓存控制器不应该在总线上看到它自己对于一个块的 Put 请求，其中，该请求在其缓存中处于状态 V（因为它应该已经转换到了状态 I）。</p>
<p><img src="/2025/02/05/A-Primer-on-Memory-Consistency/1730558868504.png" alt="1730558868504"></p>
<p><img src="/2025/02/05/A-Primer-on-Memory-Consistency/1730558875859.png" alt="1730558875859"></p>
<p>瞬间状态 IV^D 对应于状态 I 中的块，该块在转换到状态 V 之前正在等待数据（通过 DataResp 消息,也就是等待数据阶段）。当稳定状态之间的转换不是原子的之时，会出现瞬间状态。在这个简单的协议中，单个消息的发送和接收是原子的，但是从内存控制器获取一个块需要发送一个 Get 消息、并接收一个 DataResp 消息，两者之间有一个中间的间隙 (gap)。IV^D 状态指示协议正在等待 DataResp。我们将在 6.4.1 节更深入地讨论瞬间状态。</p>
<p>这种 coherence 协议在许多方面都过于简单且效率低下，但介绍该协议的目的是了解如何指定协议。在介绍不同类型的 coherence 协议时，我们在整本书中都使用了这种规范方法。</p>
<h2 id="6-4-Coherence-协议设计空间概述"><a href="#6-4-Coherence-协议设计空间概述" class="headerlink" title="6.4 Coherence 协议设计空间概述"></a>6.4 Coherence 协议设计空间概述</h2><p>如第 6.1 节所述，coherence 协议的设计者必须为系统中每种类型的 coherence 控制器选择状态 (states)、事务 (transactions)、事件 (events) 和转换 (transitions)。<strong>稳定状态</strong>的选择在很大程度上独立于 coherence 协议的其余部分。例如，有两类不同的 coherence 协议，称为 <strong>监听 (snooping)</strong> 、和 <strong>目录 (directory)</strong> ，架构师可以根据相同的稳定状态集、设计不同的监听协议或目录协议。我们将在 6.4.1 节中讨论独立于协议的稳定状态。同样，<strong>事务的选择</strong>也很大程度上独立于具体的协议，我们将在 6.4.2 节讨论事务。然而，与稳定状态和事务的选择不同，<strong>事件、转换和特定的瞬间状态，高度依赖于 coherence 协议</strong>，不能孤立地讨论。因此，在第 6.4.3 节中，我们讨论了 coherence 协议中的一些主要的设计决策。</p>
<h3 id="6-4-1-状态"><a href="#6-4-1-状态" class="headerlink" title="6.4.1 状态"></a>6.4.1 状态</h3><p>在只有一个参与者 (actor) 的系统中（例如，没有 coherent DMA 的单核处理器），缓存块的状态是 valid 或 invalid。如果需要区分块是 <strong>脏的 (dirty)</strong> ，则缓存块可能有两种可能的 valid 状态。脏块具有比该块的其他拷贝更近期的写入值。例如，在具有写回式 L1 缓存的两级缓存层次结构中，L1 中的块相对于 L2 缓存中的陈旧拷贝可能是脏的。</p>
<p>具有多个参与者的系统也可以只使用这两个或三个状态，如第 6.3 节所述，但我们经常想要区分不同类型的 valid 状态。我们希望在其状态中编码缓存块的四个特征： <strong>有效性 (validity)</strong> 、 <strong>脏性 (dirtiness)</strong> 、 <strong>独占性 (exclusivity)</strong> 、和<strong>所有权 (ownership)</strong> [10]。后两个特征是具有多个参与者的系统所独有的。</p>
<ul>
<li><strong>Validity</strong> ：一个<strong>有效 (valid)</strong> 的块具有该块的最新值。该块可以被读取，但只有在它同时是独占的情况下才能被写入。</li>
<li><strong>Dirtiness</strong> ：就像在单核处理器中一样，如果一个缓存块的值是最新的值、且这个值与 LLC&#x2F;memory 中的值不同，那么这个缓存块就是<strong>脏 (dirty)</strong> 的，且缓存控制器负责最终使用这个新值去更新 LLC&#x2F;memory。<strong>干净 (clean)</strong> 一词通常用作脏的反义词。</li>
<li><strong>Exclusivity</strong> ：如果一个缓存块是系统中该块的唯一私有缓存拷贝，则该缓存块是独占的（注1）（即，除了可能在共享 LLC 中之外，该块不缓存在其他任何地方）。</li>
<li><strong>Ownership</strong> ：如果缓存控制器（或内存控制器）负责响应对该块的 coherence 请求，那么它就是该块的 <strong>所有者 (owner)</strong> 。在大多数协议中，始终只有一个给定块的所有者。在不将块的所有权交给另一个 coherence 控制器的情况下，已拥有的块可能不会被从缓存中逐出（由于容量或冲突 miss）、以腾出空间给另一个块。在某些协议中，非拥有的块可能会被静默地驱逐（即，不发送任何消息）。</li>
</ul>
<p>在本节中，我们首先讨论一些常用的稳定状态（当前未处于一致性事务中的块的状态），然后讨论使用瞬间状态来描述当前处于事务中的块。</p>
<blockquote>
<p>原书作者注1：这里的术语可能会令人困惑，因为已经有一个称为 “Exclusive” 的缓存 coherence 状态，但还有其他缓存 coherence 状态在此处定义的意义上是 exclusive 的。</p>
</blockquote>
<blockquote>
<p>译者注：这边作者是想说，一个是协议里 “Exclusive” 状态的定义，另一个是缓存块 “exclusive” 性质的定义。</p>
</blockquote>
<h4 id="稳定状态-Stable-States"><a href="#稳定状态-Stable-States" class="headerlink" title="稳定状态 (Stable States)"></a>稳定状态 (Stable States)</h4><p>许多 coherence 协议使用 Sweazey 和 Smith [10] 首次引入的经典五态 MOESI 模型的一个子集。这些 MOESI（通常发音为 “MO-sey” 或 “mo-EE-see”）状态指的是缓存中块的状态，最基本的三个状态是 MSI；可以使用 O 和 E 状态，但它们不是基本的。这些状态中的每一个都具有前面描述的特征的不同组合。</p>
<ul>
<li><strong>M(odified)</strong> ：该块是有效的、独占的、拥有的，并且可能是脏的。该块可以被读取或写入。该缓存具有块的唯一有效拷贝，且该缓存必须响应对块的请求，并且 LLC&#x2F;memory 中的该块的拷贝可能是陈旧的。</li>
<li><strong>S(hared)</strong> ：该块有效，但不独占、不脏、不拥有。该缓存具有块的只读拷贝。其他缓存可能具有该块的有效只读拷贝。</li>
<li><strong>I(nvalid)</strong> ：该块无效。该缓存要么不包含该块，要么包含可能无法读取或写入的陈旧拷贝。在本入门书中，我们不区分这两种情况，尽管有时前一种情况可以表示为 “不存在 (Not Present)” 状态。</li>
</ul>
<p>最基本的协议仅使用 MSI 状态，但有理由添加 O 和 E 状态以优化某些情况。当我们想要讨论带有和不带有这些状态的监听和目录协议时，我们将在后面的章节中讨论这些优化。现在，这里是 MOESI 状态的完整列表：</p>
<ul>
<li><strong>M(odified)</strong></li>
<li><strong>O(wned)</strong> ：该块是有效的、拥有的、并且可能是<strong>脏</strong>的，但不是独占的。该缓存具有该块的<strong>只读</strong>拷贝，并且必须响应对该块的请求。其他缓存可能具有该块的只读副本，但它们不是所有者。LLC&#x2F;memory 中的该块的拷贝可能是陈旧的。</li>
<li><strong>E(xclusive)</strong> ：该块是有效的、独占的、且干净的。该缓存具有该块的<strong>只读</strong>拷贝。没有其他缓存拥有该块的有效拷贝，并且 LLC&#x2F;memory 中的该块的拷贝是最新的。在本入门书中，我们认为当该块处于独占状态时，它是拥有 (owned) 的，尽管在某些协议中独占状态不被视为所有权 (ownership) 状态。当我们在后面的章节中介绍 MESI 监听和目录协议时，我们将讨论是否把独占的块视为所有者的问题。</li>
<li><strong>S(hared)</strong></li>
<li><strong>I(nvalid)</strong></li>
</ul>
<p>我们在图 6.4 中展示了 MOESI 状态的维恩图。维恩图显示了哪些状态共享哪些特征。</p>
<ul>
<li>除了 I 之外的所有状态都是有效的。</li>
<li>M、O 和 E 是所有权 (ownership) 状态。</li>
<li>M 和 E 都表示独占性，因为没有其他缓存具有该块的有效拷贝。</li>
<li>M 和 O 都表示该块可能是脏的。</li>
</ul>
<p>回到第 6.3 节中的简单示例，我们观察到协议有效地将 MOES 状态压缩为 V 状态。</p>
<p><img src="/2025/02/05/A-Primer-on-Memory-Consistency/1730559433331.png" alt="1730559433331"></p>
<p>MOESI 状态虽然很常见，但并不是一套详尽的稳定状态。例如，F (Forward) 状态类似于 O 状态，只是它是<strong>干净</strong>的（即 LLC&#x2F;memory 中的拷贝是最新的）。有许多其他可能的 coherence 状态，但我们在本入门书中，会将注意力集中在著名的 MOESI 状态上。</p>
<h4 id="瞬间状态-Transient-States"><a href="#瞬间状态-Transient-States" class="headerlink" title="瞬间状态 (Transient States)"></a>瞬间状态 (Transient States)</h4><p>到目前为止，我们只讨论了当块没有当前 coherence 活动时出现的稳定状态，并且在提到协议（例如，“具有 MESI 协议的系统”）时，仅使用这些稳定状态。然而，正如我们在 6.3 节的例子中看到的那样，在从一种稳定状态到另一种稳定状态的转换过程中，可能存在瞬间状态。在 6.3 节中，我们有瞬间状态 IV^D（在 I 中，正在进入 V，等待 DataResp）。在更复杂的协议中，我们可能会遇到几十种瞬间状态。我们使用符号 XY^Z 对这些状态进行编码，这表示该块正在从稳定状态 X 转换到稳定状态 Y，并且在发生 Z 类型的事件之前不会完成转换。<strong>例如，在后面章节的一个协议中，我们使用 IM^D 来表示一个块先前在 I 中，一旦 D (Data) 消息到达该块，它将变为 M。</strong></p>
<h4 id="LLC-Memory-中的块状态"><a href="#LLC-Memory-中的块状态" class="headerlink" title="LLC&#x2F;Memory 中的块状态"></a>LLC&#x2F;Memory 中的块状态</h4><p>到目前为止，我们讨论的状态（稳定的和瞬间的）都与缓存中的块有关。LLC 和内存中的块也有与之相关的状态，有两种通用的方法来命名 LLC 和内存中的块的状态。命名约定的选择不会影响功能或性能；这只是一个规范问题，可能会使不熟悉该约定的架构师感到困惑。</p>
<ul>
<li><strong>以缓存为中心 (Cache-centric)</strong> ：在我们认为最常见的这种方法中，LLC 和内存中的块状态是缓存中该块状态的聚合 (aggregation)。例如，如果一个块在所有缓存中都处于 I 状态，则该块的 LLC&#x2F;memory 状态为 I。如果一个块在一个或多个缓存中处于 S 状态，则 LLC&#x2F;memory 状态为 S。如果一个块在单个缓存中处于 M 状态，则 LLC&#x2F;memory 状态为 M。</li>
<li><strong>以内存为中心 (Memory-centric)</strong> ：在这种方法中，LLC&#x2F;memory 中块的状态对应于内存控制器对该块的权限（而不是缓存的权限）。例如，如果一个块在所有缓存中都处于 I 状态，则该块的 LLC&#x2F;memory 状态为 O（不是 I，如在以缓存为中心的方法中那样），因为 LLC&#x2F;memory 的行为类似于该块的所有者。如果一个块在一个或多个缓存中处于 S 状态，则 LLC&#x2F;memory 状态也是 O，出于同样的原因。但是，如果一个块在单个缓存中处于 M 或 O 状态，则 LLC&#x2F;memory 状态为 I，因为 LLC&#x2F;memory 有该块的无效拷贝。</li>
</ul>
<p>本入门书中的所有协议都使用<strong>以缓存为中心的名</strong>称来表示 LLC 和内存中的块状态。</p>
<h4 id="维护块状态"><a href="#维护块状态" class="headerlink" title="维护块状态"></a>维护块状态</h4><p>系统实现必须维护与缓存、LLC 和内存中的块相关联的状态。对于缓存和 LLC，这通常仅需要将 per-block 的缓存状态进行扩展、至多几位，因为稳定状态的数量通常很少（例如，MOESI 协议的 5 个状态需要每个块 3 位）。Coherence 协议可能有更多的瞬间状态，但只需要为那些有未决 (pending) coherence 事务的块维护这些状态。实现通常通过向未命中状态处理寄存器 (miss status handling registers, MSHR) 添加额外的位，或添加用于跟踪这些未决事务 [4] 的类似结构、来维护这些瞬间状态。</p>
<p>对于内存而言，更大的总容量似乎会带来重大挑战。然而，许多当前的多核系统会维护一个 inclusive LLC，这意味着 LLC 会维护缓存在系统中任何位置的每个块的拷贝（甚至是 “独占” 的块）。使用 inclusive LLC，则内存不需要 <strong>explicitly</strong> 表示 coherence 状态。如果一个块驻留在 LLC 中，则它在内存中的状态与它在 LLC 中的状态相同。如果块不在 LLC 中，则其在内存中的状态为  <strong>implicitly Invalid</strong> ，因为 inclusive LLC 的缺失意味着该块不在任何缓存中。侧边栏讨论了在具有 inclusive LLC 的多核出现之前，内存状态是如何保持的。上面对内存的讨论假设了系统具有单个多核芯片，本入门书的大部分内容也是如此。具有多个多核芯片的系统可能会受益于内存逻辑上的显式 coherence 状态。</p>
<h4 id="原书侧边栏：在多核之前：在内存中保持一致性状态"><a href="#原书侧边栏：在多核之前：在内存中保持一致性状态" class="headerlink" title="原书侧边栏：在多核之前：在内存中保持一致性状态"></a>原书侧边栏：在多核之前：在内存中保持一致性状态</h4><p>传统地，pre-multicore 协议需要维护每个内存块的 coherence 状态，并且它们不能使用第 6.4.1 节中解释的 LLC。我们简要讨论了几种维持这种状态的方法以及相关的工程权衡。</p>
<p><strong>用状态位扩充每个内存块。</strong> 最通用的实现是向每个内存块添加额外的位、以保持 coherence 状态。如果内存中有 N 个可能的状态，那么每个块需要 log_2(N) 个额外的位。尽管这种设计是完全通用的并且在概念上很简单，但它有几个缺点。首先，额外的位可能会以两种方式增加成本。使用现代的面向块的 DRAM 芯片很难添加两个或三个额外位，这些芯片通常至少需要 4 位宽，而且通常更宽。此外，内存中的任何变化都会妨碍使用商用 DRAM 模块（例如 DIMM），这会显著增加成本。幸运的是，对于每个块只需要几位状态的协议，可以使用修改后的 ECC 代码来存储这些状态。通过在更大的粒度上维护 ECC（例如，512 位、而不是 64 位），可以释放足够的代码空间来 “隐藏” 少量额外的位，同时，还能使用商用 DRAM 模块 [1, 5, 7]。第二个缺点是，将状态位存储在 DRAM 中、意味着获取状态会导致完整的 DRAM 延迟，即使在最新版本的、块存储在其他缓存中的情况下、也是如此。在某些情况下，这可能会增加缓存到缓存 coherence 传输的延迟。最后，将状态存储在 DRAM 中意味着所有状态更改都需要一个 DRAM read-modify-write 周期，这可能会影响功率和 DRAM 带宽。</p>
<p><strong>在内存中为每个块添加单个状态位。</strong> Synapse [3] 使用的一个设计选项是，使用与每个内存块相关联的单个位来区分两个稳定状态（I 和 V）。很少有块处于瞬间状态，并且可以通过小型专用结构来维持这些状态。该设计是更完整的第一个设计的子集，存储成本最低。</p>
<p><strong>Zero-bit logical OR。</strong> 为了避免修改内存，我们可以让缓存按需重建 (reconstruct) 内存状态。一个块的内存状态、是关于每个缓存中块状态的函数，因此，如果所有缓存聚合它们的状态，它们就可以确定内存状态。系统可以通过让所有核心发送 “IsOwned?”（注a）来推断内存是否是块的所有者。信号发送到逻辑或门（或门树），其输入数量等于缓存的数量。如果此 OR 的输出为高，则表示缓存是所有者；如果输出低，那么内存就是所有者。该解决方案避免了在内存中维护任何状态的需要。然而，使用逻辑门、或 wired-OR 来实现一个快速 OR、可能很困难。</p>
<blockquote>
<p>原书作者注a：不要将此 IsOwned 信号与 Owned 缓存状态相混淆。IsOwned 信号由处于所有权状态的缓存置位 (asserted)，该状态包括 Owned、Modified 和 Exclusive 缓存状态。</p>
</blockquote>
<h3 id="6-4-2-TRANSACTIONS"><a href="#6-4-2-TRANSACTIONS" class="headerlink" title="6.4.2 TRANSACTIONS"></a>6.4.2 TRANSACTIONS</h3><p>大多数协议都有一组相似的事务，因为 coherence 控制器的基本目标是相似的。例如，几乎所有协议都有一个事务来获得对块的共享（只读）访问。在表 6.4 中，我们列出了一组常见事务，并且对于每个事务，我们描述了发起事务的请求者的目标。这些事务都是由缓存控制器发起的、以响应来自其相关核心的请求。在表 6.5 中，我们列出了核心可以向其缓存控制器发出的请求，以及这些核心请求如何引导缓存控制器启动 coherence 事务。</p>
<p><img src="/2025/02/05/A-Primer-on-Memory-Consistency/1730560163916.png" alt="1730560163916"></p>
<p><img src="/2025/02/05/A-Primer-on-Memory-Consistency/1730560177262.png" alt="1730560177262"></p>
<p>尽管大多数协议使用一组类似的事务，但它们在 coherence 控制器如何交互、以执行事务、这一方面存在很大差异。正如我们将在下一节中看到的，在某些协议（例如，监听协议）中，缓存控制器通过向系统中的所有 coherence 控制器广播 GetS 请求来启动 GetS 事务，并且当前该块的所有者的控制器、会用包含所需数据的消息、来响应请求者。相反，在其他协议（例如，目录协议）中，缓存控制器通过向特定的预定义 coherence 控制器发送单播 GetS 消息来发起 GetS 事务，该 coherence 控制器可以直接响应、或者可以将请求转发到将响应请求者的另一个 coherence 控制器。</p>
<h3 id="6-4-3-主要协议设计选项"><a href="#6-4-3-主要协议设计选项" class="headerlink" title="6.4.3 主要协议设计选项"></a>6.4.3 主要协议设计选项</h3><p>设计 coherence 协议有许多不同的方法。即使对于同一组状态和事务，也有许多不同的可能协议。协议的设计决定了每个 coherence 控制器上可能发生的事件和转换；与状态和事务不同，没有办法提供独立于协议的可能事件或转换的列表。</p>
<p>尽管 coherence 协议有巨大的设计空间，但有两个主要的设计决策会对协议的其余部分产生重大影响，我们接下来将讨论它们。</p>
<h4 id="Snooping-vs-Directory"><a href="#Snooping-vs-Directory" class="headerlink" title="Snooping vs. Directory"></a>Snooping vs. Directory</h4><p>Coherence 协议主要有两类：监听和目录。我们现在对这些协议进行简要概述，并将它们的深入介绍分别推迟到第 7 章和第 8 章。</p>
<ul>
<li><strong>监听协议</strong> ：缓存控制器通过向所有其他 coherence 控制器广播请求消息来发起对块的请求。Coherence 控制器集体 “做正确的事”，例如，如果他们是所有者，则发送数据以响应另一个核心的请求。监听协议依靠互连网络以 consistent 的顺序将广播消息传递到所有核心。大多数监听协议假定请求按 total order 到达，例如，通过 shared-wire 总线。但更高级的互连网络和更宽松的顺序也是可能的。</li>
<li><strong>目录协议</strong> ：缓存控制器通过将块单播到作为该块所在的内存控制器来发起对块的请求。内存控制器维护一个目录，该目录保存有关 LLC&#x2F;memory 中每个块的状态，例如当前所有者的身份或当前共享者的身份。当对块的请求到达主目录时，内存控制器会查找该块的目录状态。例如，如果请求是 GetS，则内存控制器查找目录状态以确定所有者。如果 LLC&#x2F;memory 是所有者，则内存控制器通过向请求者发送数据响应来完成事务。如果缓存控制器是所有者，则内存控制器将请求转发给所有者缓存；当所有者缓存接收到转发的请求时，它通过向请求者发送数据响应来完成事务。</li>
</ul>
<p>监听与目录的选择涉及权衡取舍。监听协议在逻辑上很简单，但它们无法扩展到大量核心，因为广播无法扩展。目录协议是可扩展的，因为它们是单播的，但许多事务需要更多时间，因为当 home 不是所有者时，它们需要发送额外的消息。此外，协议的选择会影响互连网络（例如，经典的监听协议需要请求消息的 total order）。</p>
<h4 id="Invalidate-vs-Update"><a href="#Invalidate-vs-Update" class="headerlink" title="Invalidate vs. Update"></a>Invalidate vs. Update</h4><p>Coherence 协议中的另一个主要设计决策是决定核心写入块时要做什么。这个决定与协议是监听还是目录无关。有两种选择。</p>
<ul>
<li><strong>Invalidate protocol</strong> ：当一个核心希望写入一个块时，它会启动一个 coherence 事务以使所有其他缓存中的拷贝无效。一旦拷贝失效，请求者就可以写入块，而另一个核心不可能读取块的旧值。如果另一个核心希望在其副本失效后读取该块，它必须启动一个新的 coherence 事务来获取该块，并且它将从写入它的核获得一个副本，从而保持 coherence。</li>
<li><strong>Update protocol</strong> ：当一个核心希望写入一个块时，它会启动一个 coherence 事务来更新所有其他缓存中的副本，以反映它写入块的新值。</li>
</ul>
<p>再一次，在做出这个决定时需要权衡取舍。更新协议减少了核心读取新写入块的延迟，因为核心不需要启动并等待 GetS 事务完成。但是，更新协议通常比无效协议消耗更多的带宽，因为更新消息大于无效消息（地址和新值，而不仅仅是地址）。此外，更新协议使许多 memory consistency models 的实现变得非常复杂。例如，当多个缓存必须对一个块的多个拷贝、应用多个更新时，保持写原子性（第 5.5 节）变得更加困难。由于更新协议的复杂性，它们很少被实现；<strong>在本入门书中，我们将重点介绍更为常见的无效协议。</strong></p>
<h4 id="混合设计"><a href="#混合设计" class="headerlink" title="混合设计"></a>混合设计</h4><p>对于这两个主要的设计决策，一种选择是开发一种混合设计。有些协议结合了监听和目录协议 [2, 6] 的各个方面，还有一些协议结合了无效和更新协议 [8] 的各个方面。设计空间丰富，架构师不受限于遵循任何特定的设计风格。</p>
<h1 id="监听一致性协议"><a href="#监听一致性协议" class="headerlink" title="监听一致性协议"></a>监听一致性协议</h1><h2 id="7-1-监听简介"><a href="#7-1-监听简介" class="headerlink" title="7.1 监听简介"></a>7.1 监听简介</h2><p>监听协议基于一个想法：所有一致性控制器以相同的顺序观察（监听）一致性请求，并集体“做正确的事”以保持一致性。 通过要求对给定块的所有请求按顺序到达，监听系统使分布式一致性控制器能够正确更新共同表示缓存块状态的有限状态机。</p>
<p>传统的监听协议将请求广播到所有一致性控制器，包括发起请求的控制器。 一致性请求通常在有序的广播网络上传播，例如总线。 有序广播确保每个一致性控制器以相同顺序观察相同系列的一致性请求，即存在一致性请求的总顺序 (total order)。 由于总顺序包含所有每个块的顺序，因此该总顺序保证所有一致性控制器都可以正确更新缓存块的状态。</p>
<p>为了说明以相同的每个块顺序 (per-block order) 处理一致性请求的重要性，请考虑表 7.1 和 7.2 中的示例，其中核心 C1 和核心 C2 都希望在状态 M 中获得相同的块 A。在表 7.1 中，所有三个一致性控制器观察一致性请求的相同的每个块顺序，并共同维护单写多读（SWMR）不变量。块的所有权从 LLC&#x2F;内存到核心 C1 再到核心 C2。作为每个观察到的请求的结果，每个一致性控制器独立地得出关于块状态的正确结论。相反，表 7.2 说明了如果核心 C2 观察到与核心 C1 和 LLC&#x2F;内存不同的每个块的请求顺序，可能会出现不一致性。首先，我们遇到核心 C1 和核心 C2 同时处于状态 M 的情况，这违反了 SWMR 不变量。接下来，我们有一种情况，没有一致性控制器认为它是所有者，因此此时的一致性请求不会收到响应（可能导致死锁）。</p>
<p><img src="/2025/02/05/A-Primer-on-Memory-Consistency/1730705771926.png" alt="1730705771926"><img src="/2025/02/05/A-Primer-on-Memory-Consistency/1730705780081.png" alt="1730705780081"></p>
<p>传统的监听协议在所有块中创建了一个总的一致性请求顺序，即使一致性只需要每个块的请求顺序。 具有总顺序可以更容易地实现需要内存引用的总顺序的内存连贯性模型 (memory consistency model)，例如 SC 和 TSO。 考虑表 7.3 中涉及两个块 A 和 B 的示例； 每个块只被请求一次，因此系统很容易观察每个块的请求顺序。 然而，由于核心 C1 和 C2 观察到 GetM 和 GetS 请求乱序，因此该执行违反了 SC 和 TSO 内存连贯性模型。</p>
<p><img src="/2025/02/05/A-Primer-on-Memory-Consistency/1730705945605.png" alt="1730705945605"></p>
<p>原书侧边栏：监听如何依赖于一致性请求的总顺序 乍一看，读者可能会认为表 7.3 中的问题的出现是因为在周期 1 中块 A 的 SWMR 不变量被违反，因为 C1 有一个 M 副本，而 C2 仍然有一个 S 副本。 但是，表 7.4 说明了相同的示例，但强制执行一致性请求的总顺序。 此示例在第 4 周期之前是相同的，因此具有相同的明显 SWMR 违规。 然而，就像众所周知的“森林中的树”一样，这种违规行为不会引起问题，因为它没有被观察到（即“没有人听到它”）。 具体来说，因为核心以相同的顺序看到两个请求，所以 C2 在看到块 B 的新值之前使块 A 无效。因此，当 C2 读取块 A 时，它必须获取新值，因此产生正确的 SC 和 TSO 执行。 传统的监听协议使用一致性请求的总顺序来确定何时在基于监听顺序的逻辑时间内观察到特定请求。 在表 7.4 的例子中，由于总顺序，核心 C1 可以推断 C2 将在 B 的 GetS 之前看到 A 的 GetM，因此 C2 在收到一致性消息时不需要发送特定的确认消息。 这种对请求接收的隐式确认 (implicit acknowledgment) 将监听协议与我们在下一章研究的目录协议区分开来。</p>
<p><img src="/2025/02/05/A-Primer-on-Memory-Consistency/1730706398306.png" alt="1730706398306"></p>
<p>要求以<strong>总顺序</strong>观察广播一致性请求对于用于实现传统监听协议的互连网络具有重要意义。<strong>由于许多一致性控制器可能同时尝试发出一致性请求，互连网络必须将这些请求序列化为某种总顺序</strong>。然而，网络决定了这个顺序，这个机制被称为协议的序列化顺序点 (<strong>serialization ordering poin</strong>t)。在一般情况下，一致性控制器发出一致性请求，网络在序列化点对该请求进行排序并将其广播给所有控制器，发射控制器 (issuing controller) 通过监听从控制器接收到的请求流来了解其请求的排序位置。作为一个具体而简单的例子，考虑一个使用总线来广播一致性请求的系统。一致性控制器必须使用仲裁逻辑来确保一次在总线上只发出一个请求。该仲裁逻辑充当序列化点，因为它有效地确定了请求在总线上出现的顺序。一个微妙但重要的一点是，一致性请求在仲裁逻辑序列化它的瞬间就被排序，但控制器可能只能通过监听总线以观察在它自己的请求之前和之后出现哪些其他请求来确定这个顺序。因此，一致性控制器可以在序列化点确定之后的几个周期内观察总请求顺序。</p>
<p>到目前为止，我们只讨论了一致性请求，而不是对这些请求的响应。这种看似疏忽的原因是监听协议的关键方面围绕着请求。响应消息几乎没有限制。他们可以在不需要支持广播也不需要任何顺序要求的单独互连网络上 travel。由于响应消息携带数据，因此比请求长得多，因此能够在更简单、成本更低的网络上发送它们有很大的好处。值得注意的是，响应消息不会影响一致性事务的序列化。从逻辑上讲，无论响应何时到达请求者，当请求被排序时，都会发生一个由广播请求和单播响应组成的一致性事务。请求出现在总线上和响应到达请求者之间的时间间隔确实会影响协议的实现（例如，在这个间隙期间，是否允许其他控制器请求此块？如果是，请求者如何响应?)，但不影响事务的序列化。（注1）</p>
<p>原书作者注1：这种一致性事务的逻辑序列化类似于处理器核心中指令执行的逻辑序列化。 即使核心执行乱序执行，它仍然按程序顺序提交（序列化）指令。</p>
<h2 id="7-2-基准监听协议"><a href="#7-2-基准监听协议" class="headerlink" title="7.2 基准监听协议"></a>7.2 基准监听协议</h2><h3 id="7-2-1-高层次协议规范"><a href="#7-2-1-高层次协议规范" class="headerlink" title="7.2.1 高层次协议规范"></a>7.2.1 高层次协议规范</h3><p>基准协议只有三个稳定状态：M、S 和 I。这样的协议通常称为 MSI 协议。 与第 6.3 节中的协议一样，该协议假定一个回写缓存。 一个块由 LLC&#x2F;内存拥有，除非该块在状态 M 的缓存中。在介绍详细规范之前，我们首先说明协议的更高层次的抽象，以了解其基本行为。 在图 7.1 和 7.2 中，我们分别展示了缓存和内存控制器的稳定状态之间的转换。</p>
<p><img src="https://file+.vscode-resource.vscode-cdn.net/c%3A/Users/Legion/Desktop/arch_note/A-Primer-on-Memory-Consistency/1730706349539.png" alt="1730706349539"></p>
<p><img src="/2025/02/05/A-Primer-on-Memory-Consistency/1730707063592.png" alt="1730707063592"></p>
<p>需要注意三个符号问题。 首先，在图 7.1 中，弧被标记为在总线上观察到的一致性请求。 我们有意省略了其他事件，包括加载、存储和一致性响应。 其次，缓存控制器上的一致性事件被标记为“Own”或“Other”，以表示观察请求的缓存控制器是否是请求者。 第三，在图 7.2 中，我们使用以<strong>缓存为中心</strong>的符号来指定内存中的块的状态（例如，内存状态 M 表示存在状态为 M 的块的缓存）。</p>
<blockquote>
<p>可以看之前的LLC块状态节来了解cache-centric</p>
</blockquote>
<h3 id="7-2-2-简单的监听系统模型：原子请求，原子事务"><a href="#7-2-2-简单的监听系统模型：原子请求，原子事务" class="headerlink" title="7.2.2 简单的监听系统模型：原子请求，原子事务"></a>7.2.2 简单的监听系统模型：原子请求，原子事务</h3><p>图 7.3 说明了简单的系统模型，它几乎与图 2.1 中介绍的基准系统模型相同。唯一的区别是图 2.1 中的通用互连网络被指定为总线。每个核心都可以向其缓存控制器发出加载和存储请求；当缓存控制器需要为另一个块腾出空间时，它会选择一个块来驱逐。总线促进了被所有一致性控制器监听的一致性请求的总顺序。与前一章中的示例一样，该系统模型具有简化一致性协议的原子性属性。具体来说，该系统实现了两个原子性属性，我们将其定义为原子请求 (Atomic Request) 和原子事务 (Atomic Transaction)。 Atomic Request 属性声明一致性请求在其发出的当个周期中排序。此属性消除了在发射请求 (issue request) 和排序请求 (order request) 之间（由于另一个核心的一致性请求）而导致块状态发生变化的可能性。 Atomic Transaction 属性指出一致性事务是原子的，因为对同一块的后续请求可能不会出现在总线上，直到第一个事务完成之后（即，直到响应出现在总线上之后）。由于一致性涉及对单个块的操作，因此系统是否允许对不同块的后续请求不会影响协议。尽管比大多数当前系统更简单，但该系统模型类似于 1980 年代成功的机器 SGI Challenge [5]。</p>
<p><img src="/2025/02/05/A-Primer-on-Memory-Consistency/1730707253212.png" alt="1730707253212"></p>
<p>表 7.5 和 7.6 给出了简单系统模型的详细一致性协议。 与第 7.2.1 节中的高层次描述相比，最显着的区别是在缓存控制器中添加了两个瞬间状态 (transient state)，在内存控制器中添加了一个瞬间状态。 该协议的瞬间状态很少，因为简单系统模型的原子性约束极大地限制了可能的消息交织的数量。</p>
<p><img src="/2025/02/05/A-Primer-on-Memory-Consistency/1730707390370.png" alt="1730707390370"></p>
<p><img src="/2025/02/05/A-Primer-on-Memory-Consistency/1730707400416.png" alt="1730707400416"></p>
<p>表中的阴影条目表示不可能的（或至少是错误的）转换。 例如，缓存控制器永远不应该收到它没有请求的块（即，在其缓存中处于状态 I 的块）的 Data 消息。 类似地，Atomic Transaction 约束阻止另一个核心在当前事务完成之前发出后续请求； 由于此约束，无法出现标记为“(A)”的表条目。 空白条目表示不需要任何操作的合法转换。 这些表省略了许多理解协议所不需要的实现细节。 此外，在本协议和本章的其余协议中，我们省略了另一个核心事务的 Data 对应的事件； 一个核心从不采取任何行动来响应在总线上观察另一个核心事务的 Data。</p>
<p>与所有 MSI 协议一样，可以在状态 S 和 M 中执行加载（即命中），而存储仅在状态 M 中命中。在加载和存储未命中时，缓存控制器分别通过发送 GetS 和 GetM 请求来启动一致性事务。 瞬间状态 IS^D、IM^D 和 SM^D 表示请求消息已发送，但尚未收到数据响应（Data）。 在这些瞬间状态下，因为请求已经被排序，所以事务已经被排序并且块在逻辑上分别处于状态 S、M 或 M。（注2） 但是，加载或存储必须等待数据到达。（注3） 一旦数据响应出现在总线上，缓存控制器就可以将数据块复制到缓存中，根据需要转换到稳定状态 S 或 M，并执行挂起的加载或存储。</p>
<p>数据响应可能来自内存控制器或具有处于状态 M 的块的另一个缓存。具有处于状态 S 的块的缓存可以忽略 GetS 请求，因为需要内存控制器响应，但必须使 GetM 请求上的块无效，以强制执行一致性不变量。 具有处于状态 M 的块的缓存必须响应 GetS 和 GetM 请求，发送数据响应并分别转换到状态 S 或状态 I。</p>
<p>LLC&#x2F;内存有两种稳定状态，M 和 IorS，以及一种瞬间状态 IorS^D。 在状态 IorS 中，内存控制器是所有者并响应 GetS 和 GetM 请求，因为此状态表明没有缓存具有状态 M 的块。在状态 M 中，内存控制器不响应数据，因为缓存处于状态 M 是所有者并且拥有数据的最新副本。 但是，状态 M 中的 GetS 意味着缓存控制器将转换到状态 S，因此内存控制器还必须获取数据、更新内存并开始响应所有未来的请求。 它通过立即转换到瞬间状态 IorS^D 并等待直到它从拥有它的缓存中接收到数据来做到这一点。</p>
<p>当缓存控制器由于替换决定而驱逐一个块时，这会导致协议的两种可能的一致性降级：从 S 到 I 和从 M 到 I。在这个协议中，S-to-I 降级在该块被从缓存中逐出，而不与其他一致性控制器进行任何通信。通常，只有在所有其他一致性控制器的行为保持不变时，才有可能进行静默状态转换；例如，不允许无声地驱逐拥有的区块。 M-to-I 降级需要通信，因为块的 M 副本是系统中唯一有效的副本，不能简单地丢弃。因此，另一个一致性控制器（即内存控制器）必须改变其状态。为了替换处于状态 M 的块，缓存控制器在总线上发出 PutM 请求，然后将数据发送回内存控制器。在 LLC，当 PutM 请求到达时，块进入状态 IorS^D，然后在 Data 消息到达时转换到状态 IorS。（注4） Atomic Request 属性简化了缓存控制器，通过在 PutM 在总线上排序之前阻止可能降级状态的干预请求（例如，另一个核心的 GetM 请求）。类似地，Atomic Transaction 属性通过阻止对块的其他请求，直到 PutM 事务完成并且内存控制器准备好响应它们来简化内存控制器。</p>
<p>在本节中，我们将展示一个系统执行示例，以展示一致性协议在常见场景中的行为方式。 我们将在后续部分中使用此示例来理解协议并突出它们之间的差异。 该示例仅包括一个块的活动，并且最初，该块在所有缓存中处于状态 I，在 LLC&#x2F;内存处处于状态 IorS。</p>
<p>在此示例中，如表 7.7 所示，核心 C1 和 C2 分别发出load和store指令，这些指令在<strong>同一块</strong>上未命中。 核心 C1 尝试发出 GetS，核心 C2 尝试发出 GetM。 我们假设核心 C1 的请求恰好首先被序列化，并且 Atomic Transaction 属性阻止核心 C2 的请求到达总线，直到 C1 的请求完成。 内存控制器在周期 3 响应 C1 完成事务。然后，核心 C2 的 GetM 在总线上被序列化； C1 使其副本无效，并且内存控制器响应 C2 以完成该事务。 最后，C1 发出另一个 GetS。 所有者 C2 以数据响应并将其状态更改为 S。C2 还将数据的副本发送到内存控制器，因为 LLC&#x2F;内存现在是所有者并且需要块的最新副本。 在此执行结束时，C1 和 C2 处于状态 S，LLC&#x2F;内存处于状态 IorS。</p>
<p><img src="/2025/02/05/A-Primer-on-Memory-Consistency/1730708269441.png" alt="1730708269441"></p>
<h3 id="7-2-3-基准监听系统模型：非原子请求、原子事务"><a href="#7-2-3-基准监听系统模型：非原子请求、原子事务" class="headerlink" title="7.2.3 基准监听系统模型：非原子请求、原子事务"></a>7.2.3 基准监听系统模型：非原子请求、原子事务</h3><p>我们在本章其余部分中使用的基准监听系统模型与简单的监听系统模型不同，它允许非原子请求。 非原子请求来自许多实现优化，但最常见的原因是在缓存控制器和总线之间插入消息队列（甚至单个缓冲区）。 通过将发出请求的时间与发出请求的时间分开，协议必须解决简单监听系统中不存在的漏洞窗口 (window of vulnerability)。 基准监听系统模型保留了原子事务属性，直到第 7.5 节我们才放松。</p>
<p>我们在表 7.8 和 7.9 中介绍了详细的协议规范，包括所有瞬间状态。 与第 7.2.2 节中的简单监听系统协议相比，最显着的区别是瞬间状态的数量要多得多。 放宽 Atomic Request 属性引入了许多情况，其中缓存控制器在发射其一致性请求和在总线上观察其自己的一致性请求之间观察来自总线上另一个控制器的请求。</p>
<p><img src="/2025/02/05/A-Primer-on-Memory-Consistency/1730708857221.png" alt="1730708857221"></p>
<p><img src="/2025/02/05/A-Primer-on-Memory-Consistency/1730708866595.png" alt="1730708866595"></p>
<p>以 I-to-S 转换为例，缓存控制器发出 GetS 请求并将块的状态从 I 更改为 IS^AD。<strong>直到在总线上观察到请求缓存控制器自己的 GetS (Own-GetS) 并序列化</strong>，块的状态实际上是 I。也就是说，请求者的块被视为在 I 中；无法执行加载和存储，并且必须忽略来自其他节点的一致性请求。一旦请求者观察到自己的 GetS，请求是有序的，块在逻辑上是 S，但是由于数据还没有到达，所以无法进行加载。缓存控制器将块的状态更改为 IS^D 并等待前一个所有者的数据响应。由于 Atomic Transaction 属性，数据消息是下一个一致性消息（到同一个块）。一旦数据响应到达，事务就完成了，请求者将块的状态更改为稳定的 S 状态并执行加载。 I-to-M 转换与 I-to-S 转换类似。</p>
<p>从 S 到 M 的转变说明了在漏洞窗口期间发生状态变化的可能性。 如果一个核心试图在状态 S 中存储到一个块，缓存控制器发出一个 GetM 请求并转换到状态 SM^AD。 **该块有效地保持在状态 S，因此加载可能会继续命中，**并且控制器会忽略来自其他核心的 GetS 请求。 但是，如果另一个核心的 GetM 请求首先被排序，则缓存控制器必须将状态转换为 IM^AD 以防止进一步的加载命中。 正如我们在侧边栏中所讨论的，S 到 M 转换期间的漏洞窗口使添加升级事务变得复杂。</p>
<p>原书侧边栏：没有<strong>原子请求</strong>的系统中的升级事务 对于具有原子请求 (Atomic Request) 的协议，升级事务 (Upgrade transaction) 是缓存从 Shared 转换为 Modified 的有效方式。 升级请求使所有共享副本失效，并且比发出 GetM 快得多，因为请求者只需要等待升级被序列化（即总线仲裁延迟），而不是等待来自 LLC&#x2F;内存的数据到达。 但是，如果没有原子请求，添加升级事务变得更加困难，因为在发出请求和请求被序列化之间存在漏洞窗口。 由于在此漏洞窗口期间序列化的 Other-GetM 或 Other-Upgrade，请求者可能会丢失其共享副本。 <strong>解决这个问题的最简单的方法是将块的状态更改为一个新状态</strong>，在该状态下它等待自己的升级被序列化。 当其 Upgrade 被序列化时，这将使其他 S 副本（如果有）无效但不会返回数据，然后核心必须发出后续 GetM 请求以转换到 M。 更有效地处理升级是困难的，因为 LLC&#x2F;内存需要知道何时发送数据。 考虑核心 C0 和 C2 共享一个块 A 并寻求升级它，同时核心 C1 寻求读取它的情况。 C0 和 C2 发出升级请求，C1 发出 GetS 请求。 假设它们在总线上序列化为 C0、C1 和 C2。 C0 的升级成功，因此 LLC&#x2F;内存（处于 IorS 状态）应将其状态更改为 M 但不发送任何数据，C2 应使其 S 副本无效。 C1 的 GetS 在 C0 处找到处于状态 M 的块，它以新的数据值响应并将 LLC&#x2F;内存更新回状态 IorS。 C2 的 Upgrade 终于出现了，但是因为它丢失了共享副本，需要LLC&#x2F;内存来响应。 不幸的是，LLC&#x2F;内存处于 IorS 状态，无法判断此升级需要数据。 存在解决此问题的替代方案，但不在本入门的范围内。 漏洞窗口也以更显着的方式影响 M-to-I 一致性降级。为替换状态为 M 的块，缓存控制器发出 PutM 请求并将块状态更改为 MI^A；与第 7.2.2 节中的协议不同，它不会立即将数据发送到内存控制器。在总线上观察到 PutM 之前，块的状态实际上是 M 并且缓存控制器必须响应其他核心对该块的一致性请求。在没有干预一致性请求到达的情况下，缓存控制器通过将数据发送到内存控制器并将块状态更改为状态 I 来响应观察自己的 PutM。如果干预的 GetS 或 GetM 请求在 PutM 排序之前到达，缓存控制器必须像处于状态 M 一样做出响应，然后转换到状态 II^A 以等待其 PutM 出现在总线上。一旦它看到它的 PutM，直观地，缓存控制器应该简单地转换到状态 I，因为它已经放弃了块的所有权。不幸的是，这样做会使内存控制器卡在瞬间状态，因为它也接收到 PutM 请求。缓存控制器也不能简单地发送数据，因为这样做可能会覆盖有效数据。（注5）解决方案是，当缓存控制器在状态 II^A 中看到其 PutM 时，它会向内存控制器发送一条特殊的 NoData 消息。 NoData 消息向内存控制器表明它来自非所有者并让内存控制器退出其瞬间状态。内存控制器变得更加复杂，因为它需要知道如果它收到 NoData 消息应该返回到哪个稳定状态。我们通过添加第二个瞬态内存状态 M^D 来解决这个问题。请注意，这些瞬间状态代表了我们通常的瞬间状态命名约定的一个例外。在这种情况下，状态 X^D 表示内存控制器在收到 NoData 消息时应恢复到状态 X（如果收到数据消息则移动到状态 IorS）。</p>
<p>原书作者注5：考虑这样一种情况，核心 C1 在 M 中有一个块并发出一个 PutM，但核心 C2 执行 GetM，核心 C3 执行 GetS，两者都在 C1 的 PutM 之前排序。 C2 获取 M 中的块，修改块，然后响应 C3 的 GetS，用更新的块更新 LLC&#x2F;内存。 当 C1 的 PutM 最终被排序时，写回数据会覆盖 C2 的更新。</p>
<h3 id="7-2-4-运行示例"><a href="#7-2-4-运行示例" class="headerlink" title="7.2.4 运行示例"></a>7.2.4 运行示例</h3><p>回到表 7.10 所示的运行示例，核心 C1 发出 GetS，核心 C2 发出 GetM。与前面的示例（在表 7.7 中）不同，消除 Atomic Request 属性意味着两个核心都会发出它们的请求并更改它们的状态。<strong>我们假设核心 C1 的请求恰好首先被序列化</strong>，并且 Atomic Transaction 属性确保 C2 的请求在 C1 的事务完成之前不会出现在总线上。在 LLC&#x2F;内存响应完成 C1 的事务后，核心 C2 的 GetM 在总线上被序列化。 C1 使其副本无效，LLC&#x2F;内存响应 C2 以完成该事务。最后，C1 发出另一个 GetS。当这个 GetS 到达总线时，所有者 C2 以数据响应并将其状态更改为 S。C2 还将数据的副本发送到内存控制器，因为 LLC&#x2F;内存现在是所有者并且需要一个 up-to-date 的块的副本。在此执行结束时，C1 和 C2 处于状态 S，LLC&#x2F;内存处于状态 IorS。</p>
<p><img src="/2025/02/05/A-Primer-on-Memory-Consistency/1730709616673.png" alt="1730709616673"></p>
<p>7.2.5 协议简化 该协议相对简单，并牺牲了性能来实现这种简单性。 最重要的简化是在总线上使用原子事务。 拥有原子事务消除了许多可能的转换，在表中用“(A)”表示。 例如，当一个核心有一个处于 IM^D 状态的缓存块时，该核心不可能观察到另一个核心对该块的一致性请求。 如果事务不是原子的，则可能会发生此类事件，并会迫使我们重新设计协议来处理它们，如第 7.5 节所示。</p>
<p>另一个牺牲性能的显着简化涉及对状态 S 的缓存块的存储请求事件。在此协议中，缓存控制器发出 GetM 并将块状态更改为 SM^AD。 如前面的侧边栏所述，更高性能但更复杂的解决方案将使用升级事务。</p>
<p><strong>7.3 ADDING THE EXCLUSIVE STATE</strong></p>
<p>TODO</p>
<h1 id="第八章：目录一致性协议"><a href="#第八章：目录一致性协议" class="headerlink" title="第八章：目录一致性协议"></a>第八章：目录一致性协议</h1><p>在本章中，我们介绍目录一致性协议 (directory coherence protocol)。 最初开发目录协议是为了解决监听协议缺乏可扩展性的问题。 传统的监听系统在一个完全有序的互连网络上广播所有请求，并且所有请求都被所有一致性控制器监听。 相比之下，目录协议使用一定程度的间接性来避免有序广播网络和让每个缓存控制器处理每个请求。</p>
<p>我们首先在高层次介绍目录协议（第 8.1 节）。 然后，我们展示了一个具有完整但简单的三态 (MSI) 目录协议的系统（第 8.2 节）。 该系统和协议作为我们稍后添加系统功能和协议优化的基准。 然后我们解释如何将独占状态（第 8.3 节）和拥有状态（第 8.4 节）添加到基准 MSI 协议。 接下来我们讨论如何表示目录状态（第 8.5 节）以及如何设计和实现目录本身（第 8.6 节）。 然后，我们描述了提高性能和降低实现成本的技术（第 8.7 节）。 然后，在讨论目录协议及其未来（第 8.9 节）结束本章之前，我们将讨论具有目录协议的商用系统（第 8.8 节）。</p>
<h2 id="8-1-目录协议简介"><a href="#8-1-目录协议简介" class="headerlink" title="8.1 目录协议简介"></a>8.1 目录协议简介</h2><p>目录协议的关键创新是建立一个目录，维护每个块的一致性状态的全局视图。 目录跟踪哪些缓存保存每个块以及处于什么状态。 想要发出一致性请求（例如，GetS）的缓存控制器将其直接发送到目录（即，<strong>单播消息</strong>），并且目录查找块的状态以确定接下来要采取的操作。 例如，目录状态可能表明请求的块由核心 C2 的缓存拥有，因此应将请求转发 (forward) 到 C2（例如，<strong>使用新的 Fwd-GetS 请求</strong>）以获取块的副本。 当 C2 的缓存控制器接收到这个转发的请求时，它会向请求的缓存控制器<strong>单播响应</strong>。</p>
<p>比较目录协议和监听协议的基本操作是有启发性的。在目录协议中，目录维护每个块的状态，缓存控制器将所有请求发送到目录。目录要么响应请求，要么将请求转发给一个或多个其他一致性控制器然后响应。一致性事务通常涉及两个步骤（单播请求，随后是单播响应）或三个步骤（单播请求，K &gt;&#x3D; 1 个转发请求和 K 个响应，其中 K 是共享者的数量）。一些协议甚至还有第四步，因为响应是通过目录间接进行的，或者因为请求者在事务完成时通知目录。相比之下，监听协议将块的状态分布在可能的所有一致性控制器上。因为没有对这种分布式状态的中央总结，所以必须将一致性请求广播到所有一致性控制器。因此，监听一致性事务总是涉及两个步骤（<strong>广播请求，随后是单播响应</strong>）。</p>
<p>与监听协议一样，目录协议需要定义一致性事务何时以及如何相对于其他事务进行排序。在大多数目录协议中，一致性事务是在目录中排序的。多个一致性控制器可以同时向目录发送一致性请求，事务顺序由请求在目录中的序列化顺序决定。如果两个请求竞争 (race) 到目录，互连网络有效地选择目录将首先处理哪个请求。第二个到达的请求的命运取决于目录协议和竞争的请求类型。第二个请求可能会（a）在第一个请求之后立即处理，（b）在等待第一个请求完成时保留在目录中，或者（c）否定确认 (negatively acknowledged, NACKed)。在后一种情况下，目录向请求者发送否定确认消息 (NACK)，请求者必须重新发出其请求。在本章中，我们不考虑使用 NACK 的协议，但我们会在第 9.3.2 节讨论 NACK 的可能使用以及它们如何导致活锁 (livelock) 问题。</p>
<p>使用目录作为排序点代表了目录协议和监听协议之间的另一个关键区别。 传统的监听协议通过序列化有序广播网络上的所有事物来创建总顺序。 监听的总顺序不仅可以确保每个块的请求按块顺序处理，而且还有助于实现内存连贯性模型 (memory consistency model)。 回想一下，传统的监听协议使用完全有序的广播来序列化所有请求； 因此，当请求者观察到其自己的一致性请求时，这将作为其一致性时期可能开始的通知。 特别是，当一个监听控制器看到自己的 GetM 请求时，它可以推断出其他缓存将使其 S 块无效。 我们在表 7.4 中证明了这个序列化通知足以支持强 SC 和 TSO 内存连贯性模型。</p>
<p>相反，目录协议对目录中的事务进行排序，以确保所有节点按块顺序处理冲突请求。 然而，缺少总顺序意味着目录协议中的请求者需要另一种策略来确定其请求何时被序列化，从而确定其一致性时期何时可以安全开始。 因为（大多数）目录协议不使用完全有序的广播，所以没有序列化的全局概念。 相反，必须针对（可能）具有块副本的所有缓存单独序列化请求。 需要显式消息来通知请求者其请求已被每个相关缓存序列化。 特别是，在 GetM 请求中，每个具有共享 (S) 副本的缓存控制器必须在序列化失效消息后发送显式确认 (Ack) 消息。</p>
<p>目录和监听协议之间的这种比较突出了它们之间的基本权衡。 目录协议以间接级别（即，对于某些事务具有三个步骤，而不是两个步骤）为代价实现了更大的可扩展性（即，因为它需要更少的带宽）。 这种额外的间接级别增加了一些一致性事务的延迟。</p>
<h2 id="8-2-基准目录系统"><a href="#8-2-基准目录系统" class="headerlink" title="8.2 基准目录系统"></a>8.2 基准目录系统</h2><h3 id="8-2-1-目录系统模型"><a href="#8-2-1-目录系统模型" class="headerlink" title="8.2.1 目录系统模型"></a>8.2.1 目录系统模型</h3><p>我们在图 8.1 中说明了我们的目录系统模型。 与监听协议不同的是，互连网络的拓扑是有意模糊的。 它可以是 mesh、torus 或架构师希望使用的任何其他拓扑。 我们在本章中假设的互连网络的一个限制是它强制执行点对点排序。 也就是说，如果控制器 A 向控制器 B 发送两条消息，则这些消息以与发送它们相同的顺序到达控制器 B。（注1） 点对点排序降低了协议的复杂性，我们将没有排序的网络讨论推迟到第 8.7.3 节。</p>
<p>原书作者注1：严格来说，我们只需要某些类型的消息的点对点顺序，但这是我们推迟到第 8.7.3 节的细节。</p>
<p><img src="/2025/02/05/A-Primer-on-Memory-Consistency/1730710594962.png" alt="1730710594962"></p>
<p>此目录系统模型与图 2.1 中的基准系统模型之间的唯一区别是我们添加了一个目录并将内存控制器重命名为目录控制器 (directory controller)。 有很多方法来调整和组织目录的大小，现在我们假设最简单的模型：对于内存中的每个块，都有一个对应的目录条目。 在 8.6 节中，我们检查和比较了更实用的目录组织选项。 我们还假设一个具有单个目录控制器的单片 LLC； 在第 8.7.1 节中，我们解释了如何在 LLC 的多个 bank 和多个目录控制器之间分配此功能。</p>
<h3 id="8-2-2-高层次协议规范"><a href="#8-2-2-高层次协议规范" class="headerlink" title="8.2.2 高层次协议规范"></a>8.2.2 高层次协议规范</h3><p>基准目录协议只有三个稳定状态：MSI。 除非块处于状态 M 的缓存中，否则块由目录控制器拥有。每个块的目录状态包括稳定的一致性状态、所有者的身份（如果块处于状态 M）和 共享者编码为 one-hot 位向量（如果块处于状态 S）。 我们在图 8.2 中说明了一个目录条目。 在 8.5 节中，我们将讨论目录条目的其他编码。</p>
<p><img src="/2025/02/05/A-Primer-on-Memory-Consistency/1730710668406.png" alt="1730710668406"></p>
<p>在介绍详细规范之前，我们首先说明协议的更高层次的抽象，以了解其基本行为。 在图 8.3 中，我们展示了缓存控制器发出一致性请求以将权限从 I 更改为 S、I 或 S 更改为 M、M 更改为 I 以及 S 更改为 I 的事务。与上一章中的监听协议一样，我们使用以缓存为中心的符号指定块的目录状态（例如，目录状态 M 表示存在一个缓存，该块处于状态 M）。 请注意，缓存控制器可能不会静默地驱逐共享块； 也就是说，有一个明确的 PutS 请求。 我们将讨论具有静默驱逐共享块的协议，以及静默与显式 PutS 请求的比较，直到第 8.7.4 节。</p>
<p><img src="/2025/02/05/A-Primer-on-Memory-Consistency/1730710700587.png" alt="1730710700587"></p>
<p>大多数事务都相当简单，但有两个事务值得在这里进一步讨论。第一个是当缓存试图将权限从 I 或 S 升级到 M 并且目录状态为 S 时发生的事务。缓存控制器向目录发送 GetM，目录执行两个操作。<strong>首先，它用包含数据和“AckCount”的消息响应请求者； AckCount 是块当前共享者的数量</strong>。目录将 AckCount 发送给请求者，以通知请求者有多少共享者必须确认已使他们的块无效以响应 GetM。其次，目录向所有当前共享者发送无效 (Inv) 消息。每个共享者在收到 Invalidation 后，会向请求者发送 Invalidation-Ack (Inv-Ack)。一旦请求者收到来自目录的消息和所有 Inv-Ack 消息，它就完成了事务。收到所有 Inv-Ack 消息的请求者知道该块不再有任何读者，因此它可以在不违反一致性的情况下写入该块。</p>
<p>值得进一步讨论的第二个事务发生在缓存试图驱逐处于状态 M 的块时。在此协议中，我们让缓存控制器向目录发送包含数据的 PutM 消息。 该目录以 Put-Ack 响应。 如果 PutM 没有携带数据，那么协议将需要在 PutM 事务中发送第三条消息——从缓存控制器到目录的数据消息，被逐出的块已处于状态 M。 此目录协议中的 PutM 事务与监听协议中发生的不同，其中 PutM 不携带数据。</p>
<h3 id="8-2-3-避免死锁"><a href="#8-2-3-避免死锁" class="headerlink" title="8.2.3 避免死锁"></a>8.2.3 避免死锁</h3><p>在这个协议中，消息的接收会导致一致性控制器发送另一个消息。一般来说，如果事件 A（例如，消息接收）可以导致事件 B（例如，消息发送）并且这两个事件都需要资源分配（例如，网络链接和缓冲区），那么我们必须小心避免可能发生的死锁，如果出现循环资源依赖。例如，GetS 请求会导致目录控制器发出 Fwd-GetS 消息；如果这些消息使用相同的资源（例如，网络链接和缓冲区），那么系统可能会死锁。在图 8.4 中，我们说明了一个死锁，其中两个一致性控制器 C1 和 C2 正在响应彼此的请求，但传入队列已经充满了其他一致性请求。如果队列是 FIFO，则响应无法通过请求。由于队列已满，每个控制器都会停止尝试发送响应。因为队列是先进先出的，控制器无法切换到处理后续请求（或获取响应）。因此，系统死锁。</p>
<p><img src="/2025/02/05/A-Primer-on-Memory-Consistency/1730719624385.png" alt="1730719624385"></p>
<p>避免一致性协议中的死锁的一个众所周知的解决方案是为每类消息使用单独的网络。 网络可以在物理上分离或在逻辑上分离（称为虚拟网络），但关键是避免消息类别之间的依赖关系。 图 8.5 说明了一个系统，其中请求和响应消息在不同的物理网络上传播。 因为一个响应不能被另一个请求阻塞，它最终会被它的目的节点消费，打破了循环依赖。</p>
<p><img src="/2025/02/05/A-Primer-on-Memory-Consistency/1730719668923.png" alt="1730719668923"></p>
<p>本节中的目录协议使用三个网络来避免死锁。 因为请求可以导致转发 (forward) 请求，而转发请求可以导致响应，所以存在三个消息类别，每个类别都需要自己的网络。 请求消息是 GetS、GetM 和 PutM。 转发的请求消息是 Fwd-GetS、Fwd-GetM、Inv (Invalidation) 和 Put-Ack。 响应消息是 Data 和 Inv-Ack。 本章中的协议要求<strong>转发请求网络提供点对点排序</strong>； 其他网络没有排序约束，在不同网络上传输的消息之间也没有任何排序约束。</p>
<p>我们推迟到第 9.3 节对避免死锁进行更彻底的讨论，包括对虚拟网络的更多解释和避免死锁的确切要求。</p>
<h3 id="8-2-4-详细的协议规范"><a href="#8-2-4-详细的协议规范" class="headerlink" title="8.2.4 详细的协议规范"></a>8.2.4 详细的协议规范</h3><p>我们在表 8.1 和 8.2 中提供了详细的协议规范，包括所有瞬间状态。与第 8.2.2 节中的高层次描述相比，最显着的区别是瞬间状态。一致性控制器必须管理处于一致性事务中的块的状态，包括缓存控制器在将其一致性请求发送到目录和接收其所有必要的响应消息之间接收来自另一个控制器的转发请求的情况，包括数据和可能的 Inv-Ack。缓存控制器可以在未命中状态处理寄存器 (miss status handling register, MSHR) 中维护此状态，核心使用该寄存器跟踪未完成的一致性请求。在符号上，我们以 XY^AD 的形式表示这些瞬间状态，其中上标 A 表示等待确认，上标 D 表示等待数据。 （这种表示法不同于监听协议，其中上标 A 表示等待请求出现在总线上。）</p>
<p><img src="/2025/02/05/A-Primer-on-Memory-Consistency/1730719893584.png" alt="1730719893584"></p>
<p><img src="/2025/02/05/A-Primer-on-Memory-Consistency/1730719903399.png" alt="1730719903399"></p>
<h3 id="8-2-5-协议操作"><a href="#8-2-5-协议操作" class="headerlink" title="8.2.5 协议操作"></a>8.2.5 协议操作</h3><p>该协议使缓存能够获取处于状态 S 和 M 的块，并将块替换到处于这两种状态中的目录中。</p>
<p>I to S (common case #1)</p>
<p>缓存控制器向目录发送 GetS 请求并将块状态从 I 更改为 IS^D。 目录接收到这个请求，如果该目录是所有者（即当前没有缓存在 M 中拥有该块），则该目录以 Data 消息响应，将块的状态更改为 S（如果它已经不是 S），并且 将请求者添加到共享者列表 (sharer list)。 当数据到达请求者时，缓存控制器将块的状态更改为 S，完成事务。</p>
<p>I to S (common case #2)</p>
<p>缓存控制器向目录发送 GetS 请求并将块状态从 I 更改为 IS^D。 如果目录不是所有者（即存在当前在 M 中具有块的缓存），则目录将请求转发给所有者并将块的状态更改为瞬态 S^D。 所有者通过向请求者发送 Data 并将块的状态更改为 S 来响应此 Fwd-GetS 消息。现在的先前所有者还必须将 Data 发送到目录，因为它正在放弃对目录的所有权，该目录必须具有块的最新副本。 当数据到达请求者时，缓存控制器将块状态更改为 S 并认为事务完成。 当 Data 到达目录时，目录将其复制到内存中，将块状态更改为 S，并认为事务完成。</p>
<p>I to S (race cases)</p>
<p>上述两种 I-to-S 场景代表了常见的情况，其中正在进行的块只有一个事务。 该协议的大部分复杂性源于必须处理一个块的多个正在进行的事务的不太常见的情况。 例如，读者可能会惊讶于缓存控制器可以接收到状态 IS^D 的块的无效 (Invalidation)。 考虑发出 GetS 并转到 IS^D 的核心 C1 和另一个核心 C2，它为在 C1 的 GetS 之后到达目录的同一块发出 GetM。 该目录首先发送 C1 Data 以响应其 GetS，然后发送 Invalidation 以响应 C2 的 GetM。 由于 Data 和 Invalidation 在不同的网络上传输，它们可能会<strong>乱序到达</strong>，因此 C1 可以在数据之前接收失效。</p>
<p>I or S to M</p>
<p>缓存控制器向目录发送 GetM 请求并将块的状态从 I 更改为 IM^AD。在这种状态下，缓存等待 Data 和（可能的）Inv-Ack，表明其他缓存已经使它们在状态 S 中的块副本无效。<strong>缓存控制器知道需要多少 Inv-Ack，因为 Data 消息包含 AckCount，可能为零</strong>。图 8.3 说明了目录响应 GetM 请求的三种常见情况。如果目录处于状态 I，它只需发送 AckCount 为零的数据并进入状态 M。如果处于状态 M，目录控制器将请求转发给所有者并更新块的所有者；现在以前的所有者通过发送 AckCount 为零的 Data 来响应 Fwd-GetM 请求。最后一种常见情况发生在目录处于状态 S 时。目录以 Data 和等于共享者数量的 AckCount 进行响应，另外它向共享者列表中的每个核心发送 Invalidation。接收 Invalidation 消息的缓存控制器使其共享副本无效并将 Inv-Ack 发送给请求者。当请求者收到最后一个 Inv-Ack 时，它转换到状态 M。注意表 8.1 中的特殊 Last-Inv-Ack 事件，它简化了协议规范。</p>
<p>这些常见情况忽略了一些突出目录协议并发性的可能竞争。 例如，核心 C1 的缓存块处于 IM^A 状态，并从 C2 的缓存控制器接收 Fwd-GetS。 这种情况是可能的，因为目录已经向 C1 发送了 Data，向共享者发送了 Invalidation 消息，并将其状态更改为 M。当 C2 的 GetS 到达目录时，目录将其简单地转发给所有者 C1。 这个 Fwd-GetS 可能在所有 Inv-Ack 到达 C1 之前到达 C1。 在这种情况下，我们的协议只是停止并且缓存控制器等待 Inv-Ack。 因为 Inv-Ack 在单独的网络上传输，所以保证它们不会阻塞在未处理的 Fwd-GetS 后面。</p>
<p>M to I</p>
<p>为了驱逐处于状态 M 的块，缓存控制器发送一个包含数据的 PutM 请求并将块状态更改为 MI^A。 当目录接收到这个 PutM 时，它会更新 LLC&#x2F;内存，以 Put-Ack 响应，并转换到状态 I。在请求者收到 Put-Ack 之前，块的状态保持有效 M 并且缓存控制器必须响应转发块的一致性请求。 如果缓存控制器在发送 PutM 和接收 Put-Ack 之间收到转发的一致性请求（Fwd-GetS 或 Fwd-GetM），缓存控制器响应 Fwd-GetS 或 Fwd-GetM 并更改其块状态分别到 SI^A 或 II^A。 这些瞬间状态实际上分别是 S 和 I，但表示缓存控制器必须等待 Put-Ack 完成到 I 的转换。</p>
<p>S to I</p>
<p>与前一章中的监听协议不同，我们的目录协议不会静默地驱逐状态 S 中的块。相反，为了替换状态 S 中的块，缓存控制器发送 PutS 请求并将块状态更改为 SI^A。 目录接收此 PutS 并以 Put-Ack 响应。 在请求者收到 Put-Ack 之前，block 的状态实际上是 S。如果缓存控制器在发送 PutS 之后并且在收到 Put-Ack 之前收到 Invalidation 请求，它会将 block 的状态更改为 II^A。 这种瞬间状态实际上是 I，但它表示缓存控制器必须等待 Put-Ack 完成从 S 到 I 的事务。</p>
<h3 id="8-2-6-协议简化"><a href="#8-2-6-协议简化" class="headerlink" title="8.2.6 协议简化"></a>8.2.6 协议简化</h3><p>该协议相对简单，并牺牲了一些性能来实现这种简单性。 我们现在讨论两个简化：</p>
<p>除了只有三个稳定状态之外，最重要的简化是协议在某些情况下停止。 例如，缓存控制器在处于瞬间状态时收到转发的请求时会停止。 在第 8.7.2 节中讨论的更高性能选项是处理消息并添加更多瞬间状态。 第二个简化是目录发送 Data（和 AckCount）以响应将块状态从 S 更改为 M 的缓存。缓存已经有有效数据，因此目录只需发送 data-less AckCount 就足够了。 我们推迟添加这种新类型的消息，直到我们在第 8.4 节中介绍 MOSI 协议。</p>
<h2 id="8-3-ADDING-THE-EXCLUSIVE-STATE"><a href="#8-3-ADDING-THE-EXCLUSIVE-STATE" class="headerlink" title="8.3 ADDING THE EXCLUSIVE STATE"></a><strong>8.3 ADDING THE EXCLUSIVE STATE</strong></h2><p>正如我们之前在snoop协议的上下文中所讨论的那样，添加Exclusive (E)状态是一个重要的优化，因为它使核心能够仅通过一个coherence事务读取和写入块，而不是MSI协议所要求的两个coherence事务。在最高级别上，这种优化与缓存一致性是使用snoop还是使用目录无关。如果一个内核发出了get请求，并且该块当前没有被其他内核共享，那么请求者可以获得状态为E的块，然后内核可以静默地将块的状态从E升级到M，而无需发出另一个一致性请求</p>
<p>在本节中，我们将E状态添加到基线MSI目录协议中。与前一章的MESI窥探协议一样，协议的操作取决于E状态是否被视为所有权状态。而且，与MESI窥探协议一样，主要的操作差异涉及确定哪个一致性控制器应该响应对目录提供给状态E的缓存的块的请求。自从目录将块提供给状态E的缓存以来，块可能已经从E默默地升级到M。</p>
<p>在拥有E块的协议中，解决方案很简单。在E（或M）中包含块的缓存是所有者，因此必须响应请求。发送到目录的一致性请求将被转发到状态为E的块的缓存中，因为E状态是所有权状态，所以E块的删除不能静默执行；缓存必须向目录发出PutE请求。如果没有显式的PutE，目录将不知道该目录现在是所有者，并且应该响应传入的一致性请求。因为我们在本入门中假设E中的块是拥有的，所以这个简单的解决方案就是我们在本节的MESI协议中实现的。</p>
<p>在不拥有E块的协议中，E块可以被静默地驱逐，但这会增加协议的复杂性。考虑这样一种情况：核心C1获得状态E的块，然后目录从核心C2接收GetS或GetM。目录知道C1要么  i)仍然处于状态E， ii)处于状态M（如果C1执行了从E到M的静默升级），要么 iii)处于状态I（如果协议允许C1执行静默PutE）。如果C1在M中，则目录必须将请求转发给C1，以便C1可以提供最新版本的数据。如果C1在E中，则C1或目录可能会响应，因为它们都具有相同的数据。如果C1在I中，则目录必须响应。一个解决方案是让C1和目录都响应，我们将在第8.8.1节中对SGI Origin[10]的案例研究中详细描述。另一种解决方案是让目录将请求转发给C1。如果C1在I中，C1通知目录响应C2；否则，C1响应C2并通知目录它不需要响应C2。</p>
<h3 id="8-3-1-High-Level-Protocol-Specification"><a href="#8-3-1-High-Level-Protocol-Specification" class="headerlink" title="8.3.1 High-Level Protocol Specification"></a>8.3.1 High-Level Protocol Specification</h3><p>我们在图8.6中指定了事务的高级视图，突出显示了与MSI协议的不同之处。只有两个显著的区别</p>
<p>首先，从I到E有一个过渡 如果目录接收到状态I的块的get，则会发生这种情况。其次，存在一个用于驱逐状态E的块的PutE事务。因为E是所有权状态，所以E块不能被静默地驱逐。与处于M状态的块不同，E块是干净的，因此PutE不需要携带数据；该目录已经拥有该块的最新副本</p>
<p><img src="/2025/02/05/A-Primer-on-Memory-Consistency/1730727710073.png" alt="1730727710073"></p>
<h3 id="8-3-2-Detailed-Protocol-Specification"><a href="#8-3-2-Detailed-Protocol-Specification" class="headerlink" title="8.3.2 Detailed Protocol Specification"></a>8.3.2 Detailed Protocol Specification</h3><p>在表8.3和8.4中，我们给出了MESI协议的详细规范，包括瞬态状态。关于MSI协议的差异用黑体字突出显示。该协议向缓存状态集添加稳定E状态和瞬态状态，以处理最初处于状态E的块的事务。</p>
<p>这个协议比MSI协议稍微复杂一些，在目录控制器上增加了很多复杂性。除了具有更多状态之外，目录控制器还必须区分更多可能的事件。例如，当一个PutS到达时，目录必须区分这是否是“最后一次”PutS；也就是说，这个put是否来自唯一的当前共享者？如果这个PutS是最后一个PutS，那么目录的状态变为I。</p>
<p><img src="/2025/02/05/A-Primer-on-Memory-Consistency/1730728271136.png" alt="1730728271136"></p>
<p><img src="/2025/02/05/A-Primer-on-Memory-Consistency/1730728283074.png" alt="1730728283074"></p>
<h2 id="8-4-ADDING-THE-OWNED-STATE"><a href="#8-4-ADDING-THE-OWNED-STATE" class="headerlink" title="8.4 ADDING THE OWNED STATE"></a>8.4 ADDING THE OWNED STATE</h2><p>出于同样的原因，我们在第7章中将Owned状态添加到基线MSI窥探协议中，架构师可能希望将Owned状态添加到第8.2节中介绍的基线MSI目录协议中。回顾第二章，如果一个缓存中有一个块处于Owned状态，那么这个块是有效的，只读的，脏的（也就是说，它最终必须更新内存），并且是拥有的（也就是说，缓存必须响应块的一致性请求）。与MSI相比，添加Owned状态在三个重要方面改变了协议：(1)在M中观察Fwd-GetS的块的缓存将其状态更改为O，并且不需要（立即）将数据复制回LLC&#x2F;内存，(2)缓存（在O状态下）比LLC&#x2F;内存满足更多的一致性请求，(3)有更多的3-hop 事务（这将由MSI协议中的LLC&#x2F;内存满足）</p>
<h3 id="8-4-1-High-Level-Protocol-Specification"><a href="#8-4-1-High-Level-Protocol-Specification" class="headerlink" title="8.4.1 High-Level Protocol Specification"></a>8.4.1 High-Level Protocol Specification</h3><p>我们在图8.7中指定了事务的高级视图，突出显示了与MSI协议的不同之处。最有趣的区别是，当处于状态I或S的块在所有者缓存中处于O状态，而在一个或多个共享器缓存中处于S状态时，请求者向目录发送GetM的事务。在这种情况下，目录将GetM转发给所有者，并追加AckCount。该目录还将Invalidations发送给每个共享器。所有者接收Fwd-GetM并使用Data和AckCount响应请求者。请求者使用这个接收到的AckCount来确定它何时收到了最后一个Inv-Ack。如果GetM的请求者是所有者（处于状态O），则会有类似的事务。这里的不同之处在于，目录将AckCount直接发送给请求者，因为请求者是所有者。</p>
<p>该协议有一个与PutM事务几乎相同的PutO事务。它包含数据的原因与PutM事务包含数据的原因相同，即，因为M和O都是脏状态</p>
<p><img src="/2025/02/05/A-Primer-on-Memory-Consistency/1730729332062.png" alt="1730729332062"></p>
<h3 id="8-4-2-Detailed-Protocol-Specification"><a href="#8-4-2-Detailed-Protocol-Specification" class="headerlink" title="8.4.2 Detailed Protocol Specification"></a>8.4.2 Detailed Protocol Specification</h3><p>表8.5和8.6给出了MOSI协议的详细规范，包括瞬态状态。关于MSI协议的差异用黑体字突出显示。该协议向缓存状态集中添加了稳定的O状态以及瞬态OM^AC、OM^A和OI^A状态来处理最初处于状态o的块的事务。状态OM^AC表明缓存正在等待来自缓存的inv - ack (A)和来自目录的AckCount (C)，但不是数据。因为这个块是从状态O开始的，所以它已经有了有效的数据。</p>
<p>当核心C1的缓存控制器在OM^AC或SM^AD中有一个块并从核心C2接收该块的Fwd-GetM或Invalidation时，会出现一种有趣的情况。要出现这种情况，必须在C1的GetM之前在目录中对C2的GetM进行排序。因此，在观察C1的GetM之前，目录状态更改为M（由C2拥有）。当C2的Fwd-GetM或Invalidation到达C1时，C1必须知道C2的GetM是先订购的。因此，C1的缓存状态从OM^AC或SM^AD变为IM^AD。从C2转发的GetM或Invalidation使C1的缓存块无效，现在C1必须等待Data和inv - ack。</p>
<p><img src="/2025/02/05/A-Primer-on-Memory-Consistency/1730729680237.png" alt="1730729680237"></p>
<p><img src="/2025/02/05/A-Primer-on-Memory-Consistency/1730729692527.png" alt="1730729692527"></p>
<h2 id="8-5表示目录状态"><a href="#8-5表示目录状态" class="headerlink" title="8.5表示目录状态"></a>8.5表示目录状态</h2><p>在前面的小节中，我们假设了一个完整的目录；也就是说，目录维护每个块的完整状态，包括（可能）具有共享副本的完整缓存集。然而，这个假设与目录协议的主要动机相矛盾：可扩展性(scalability)。在具有大量缓存的系统中（即，一个块的大量潜在共享者），维护每个块的完整共享者集需要大量的存储空间，即使使用紧凑的位向量表示也是如此。对于具有适度数量的缓存的系统,能够维护这个完整的集合可能是有原因的，但是大型系统的架构师可能希望有更可扩展的解决方案来维护目录状态。有许多方法可以减少目录为每个块维护的状态量。这里我们讨论两种重要的技术：粗目录和有限指针(coarse directories and limited pointers.)。我们单独讨论这些技术，但注意到它们可以结合使用。我们将每个解决方案与基线设计进行对比，如图8.8顶部条目所示。</p>
<p><img src="/2025/02/05/A-Primer-on-Memory-Consistency/1730730454827.png" alt="1730730454827"></p>
<h3 id="8-5-1-Coarse-Directory"><a href="#8-5-1-Coarse-Directory" class="headerlink" title="8.5.1 Coarse Directory"></a>8.5.1 Coarse Directory</h3><p>拥有完整的共享器集使目录能够将Invalidation消息准确地发送到那些处于状态S的块的缓存控制器。减少目录状态的一种方法是保守地维护一个粗略的共享器列表，该列表是实际共享器集的超集。也就是说，共享器列表中的一个<strong>给定条目对应于一组K个缓存</strong>，如图8.8中间的条目所示。如果该集合中的一个或多个缓存（可能）的块处于状态S，则设置共享器列表中的该位。GetM将导致目录控制器向该集合中的所有K个缓存发送Invalidation。因此，粗目录减少了目录状态，代价是不必要的Invalidation消息带来额外的互连网络带宽，以及处理这些额外的Invalidation消息所需的缓存控制器带宽。</p>
<h3 id="8-5-2-Limited-Pointer-Directory"><a href="#8-5-2-Limited-Pointer-Directory" class="headerlink" title="8.5.2 Limited Pointer Directory"></a>8.5.2 Limited Pointer Directory</h3><p>在带有C缓存的芯片中，一个完整的共享列表需要C个条目，每个条目一个位，总共C位。</p>
<p>然而，研究表明，许多区块没有共享者或只有一个共享者。有限指针目录通过拥有i （i&lt; C）个条目来利用这一观察结果，其中每个条目需要log2C位，总共i * log2C位，如图8.8底部条目所示。</p>
<p>需要一些额外的机制来处理（希望不常见）系统试图添加第i+1个共享者的情况。有三个经过充分研究的选项可以处理这些情况，使用符号DiriX[2,8]表示，其中i指的是指向共享器的指针数量，X指的是处理系统试图添加第i+1个共享器的情况的机制。</p>
<p>广播（DiriB）：如果已经有i个共享器，并且另一个getS到达，目录控制器将设置块的状态，以指示后续的GetM要求目录将Invalidation广播到所有缓存（即新的“太多共享器”状态）。DiriB的一个缺点是，即使只有K个共享器（i&lt;K&lt;C），目录也必须广播到所有C缓存，这要求目录控制器发送（以及缓存控制器处理）C-K个不必要的Invalidation消息。极限情况Dir0B将这种方法发挥到了极致，它消除了所有指针，并要求对所有一致性操作进行广播。最初的Dir0B提议在每个区块中保持两个状态位，编码三个MSI状态加上一个特殊的“Single Sharer”状态[3]。当缓存试图将其S副本升级到M副本时，这种新状态有助于消除广播（类似于Exclusive状态优化）。类似地，当内存拥有该块时，目录的I状态消除广播。AMD的Coherent HyperTransport[6]实现了一个不使用目录状态的Dir0B版本，放弃了这些优化，但消除了存储任何目录状态的需要。然后，发送到该目录的所有请求被广播到所有缓存。</p>
<p>无广播（DiriNB）：如果已经有i个共享器，并且另一个getS到达，则目录要求当前共享器中的一个使自身无效，以便在共享器列表中为新的请求者腾出空间。对于广泛共享的块（即由超过i个节点共享的块），由于使共享器失效所花费的时间，此解决方案可能会导致显著的性能损失。</p>
<p>对于具有一致指令缓存的系统来说，DiriNB尤其成问题，因为代码经常被广泛共享。</p>
<p>软件（DiriSW）：如果已经有i个共享器，并且另一个get到达，系统将trap到一个软件处理程序。trap到软件提供了极大的灵活性，例如在软件管理的数据结构中维护完整的共享者列表。然而，由于对软件的捕获会导致显著的性能成本和实现复杂性，因此这种方法在商业上的接受程度有限。</p>
<h2 id="8-6目录组织"><a href="#8-6目录组织" class="headerlink" title="8.6目录组织"></a>8.6目录组织</h2><p>逻辑上，该目录包含每个内存块的单个条目。许多传统的基于目录的系统（其中目录控制器与内存控制器集成）通过增加内存来保存目录，直接实现了这种逻辑抽象。例如，SGI Origin在每个内存块中添加了额外的DRAM芯片来存储完整的目录状态[10]。</p>
<p>然而，对于今天的多核处理器和大型有限责任公司，传统的目录设计已经没有什么意义了。首先，架构师不希望目录访问片外内存的延迟和功率开销，特别是缓存在芯片上的数据。其次，当几乎所有的内存块在任何给定的时间都没有缓存时，系统设计者对大的片外目录状态犹豫不决。这些缺点促使架构师通过在芯片上仅缓存目录条目的子集来优化常见情况。在本节的其余部分，我们将讨论<strong>目录缓存设计</strong>，其中有几种是Marty和Hill先前分类的[13]。</p>
<p>与传统的指令和数据缓存一样，目录缓存[7]提供了对完整目录状态子集的更快访问。由于目录总结了一致性缓存的状态，因此它们表现出与指令和数据访问相似的局部性，但只需要存储每个块的一致性状态，而不需要存储其数据。因此，相对较小的目录缓存实现了高命中率。</p>
<p>目录缓存对一致性协议的功能没有影响；它只是减少了平均目录访问延迟。目录缓存在多核处理器时代变得更加重要。在内核位于单独的芯片和&#x2F;或电路板上的旧系统中，消息延迟足够长，以至于它们倾向于摊销目录访问延迟。</p>
<p>在多核处理器中，消息可以在几个周期内从一个核心传递到另一个核心，而片外目录访问的延迟往往会使通信延迟相形见绌，并成为瓶颈。因此，对于多核处理器来说，实现片内目录缓存以避免代价高昂的片外访问是一种强烈的动机。</p>
<p>片上目录缓存包含目录条目的完整集合的子集。因此，关键的设计问题是处理<strong>目录缓存缺失</strong>，即，当一个一致性请求到达一个目录条目不在目录缓存中的块时。</p>
<p>我们总结表8.7中的设计选项，并在下面进行描述。</p>
<h3 id="8-6-1-Directory-Cache-Backed-by-DRAM"><a href="#8-6-1-Directory-Cache-Backed-by-DRAM" class="headerlink" title="8.6.1 Directory Cache Backed by DRAM"></a>8.6.1 Directory Cache Backed by DRAM</h3><p>最直接的设计是将完整的目录保存在DRAM中，就像传统的多芯片多处理器一样，并使用单独的目录缓存结构来减少平均访问延迟。一致性请求在这个目录缓存中丢失导致访问这个DRAM目录。这种设计虽然简单，但有几个重要的缺点。首先，它需要大量的DRAM来保存目录，包括当前不在芯片上缓存的绝大多数块的状态。其次，由于目录缓存与LLC解耦，因此有可能在LLC中命中，但在目录缓存中未命中，从而导致DRAM访问，即使数据在本地可用。最后，目录缓存替换必须将目录条目写回DRAM，这会导致高延迟和功耗开销。</p>
<p><img src="/2025/02/05/A-Primer-on-Memory-Consistency/1730731895750.png" alt="1730731895750"></p>
<h3 id="8-6-2-Inclusive-Directory-Caches"><a href="#8-6-2-Inclusive-Directory-Caches" class="headerlink" title="8.6.2 Inclusive Directory Caches"></a>8.6.2 Inclusive Directory Caches</h3><p>我们可以设计更经济有效的目录缓存，因为我们只需要缓存正在芯片上缓存的块的目录状态。如果目录缓存保存了芯片上缓存的所有块的超集的目录条目，我们将目录缓存称为inclusive目录缓存。一个inclusive目录缓存作为一个“完美的”目录缓存，永远不会错过访问缓存在芯片上的块。不需要在DRAM中存储完整的目录。包含目录缓存中的缺失表明该块处于状态I；miss并不是访问某个后备目录存储的前兆。</p>
<p>我们现在讨论两种包含目录缓存设计，以及适用于这两种设计的优化</p>
<h4 id="8-6-2-1-Inclusive-directory-cache-embedded-in-inclusive-LLC"><a href="#8-6-2-1-Inclusive-directory-cache-embedded-in-inclusive-LLC" class="headerlink" title="8.6.2.1 Inclusive directory cache embedded in inclusive LLC"></a>8.6.2.1 Inclusive directory cache embedded in inclusive LLC</h4><p>最简单的目录缓存设计依赖于与上层缓存保持inclusive的LLC。缓存包含意味着如果一个块在一个高级缓存中，那么它也必须出现在一个低级缓存中。对于图8.1的系统模型，LLC包含意味着如果一个块在一个核心的L1缓存中，那么它也必须在LLC中。</p>
<p>inclusiveLLC的结果是，如果一个块不在LLC中，它也不在L1缓存中，因此对于芯片上的所有缓存必须处于状态I ,inclusive目录缓存通过在LLC中嵌入每个块的一致性状态来利用此属性。如果将一致性请求发送到LLC&#x2F;目录控制器，并且请求的地址不存在于LLC中，则目录控制器知道所请求的块未缓存在芯片上，因此在所有l1中处于状态I。</p>
<p>因为目录镜像了LLC的内容，所以整个目录缓存可以简单地通过在LLC中的每个块中添加额外的位而嵌入到LLC中。这些添加的位可能导致严重的开销，这取决于内核的数量和表示目录状态的格式。我们在图8.9中说明了将这种目录状态添加到LLC缓存块中，并将其与没有嵌入LLC目录缓存的系统中的LLC块进行比较。</p>
<p>不幸的是，LLC inclusion 有几个重要的缺点。首先，对于私有缓存层次结构（如果底层缓存具有足够的关联性[4]），可以自动维护LLC包含，对于我们系统模型中的共享缓存，在替换LLC中的块时，通常需要发送特殊的“召回”请求来使L1缓存中的块失效（在8.6.2.3节中进一步讨论）。更重要的是，LLC包含需要维护位于上层缓存中的缓存块的冗余副本。在多核处理器中，上层缓存的总容量可能是LLC容量的很大一部分（有时甚至大于）</p>
<p><img src="/2025/02/05/A-Primer-on-Memory-Consistency/1730733002842.png" alt="1730733002842"></p>
<h4 id="8-6-2-2-Standalone-Inclusive-Directory-Cache"><a href="#8-6-2-2-Standalone-Inclusive-Directory-Cache" class="headerlink" title="8.6.2.2 Standalone Inclusive Directory Cache"></a>8.6.2.2 Standalone Inclusive Directory Cache</h4><p>我们现在提出了一个不依赖于LLC包含的包含目录缓存设计。在这种设计中，目录缓存是一个独立的结构，它在逻辑上与目录控制器相关联，而不是嵌入在LLC本身中。为了使目录缓存具有inclusive，它必须包含所有L1缓存中块的联合目录条目，因为LLC中的块（但不包含任何L1缓存中的块）必须处于状态I。因此，在这种设计中，目录缓存由所有L1缓存中标记的重复副本组成。与之前的设计（第8.6.2.1节）相比，这种设计更灵活，因为不需要LLC包含，但它增加了重复标签的存储成本。</p>
<p>这个inclusive目录缓存的实现成本很高。最值得注意的是，它需要一个高度关联的目录缓存。（如果我们在包含LLC中嵌入目录缓存（章节8.6.2.1），那么LLC也必须是高度关联的。）考虑具有C个内核的芯片的情况，每个内核都有一个k路集关联L1缓存。目录缓存必须是C*K-way关联的，以保存所有L1缓存标记，不幸的是，这种关联性随着核心数线性增长。我们在图8.10中说明了K&#x3D;2时的这个问题。</p>
<p>为了使目录缓存保持最新，包容性目录缓存设计也引入了一些复杂性。当一个块从L1缓存中被驱逐时，缓存控制器必须通过发出显式的PutS请求来通知目录缓存哪个块被替换了（例如，我们不能使用带有静默驱逐的协议，如第8.7.4节所讨论的）。一种常见的优化是在get或GetX请求上附带显式put。由于索引位必须相同，因此可以通过指定替换的方式对PutS进行编码。这有时被称为“替换提示”，尽管通常它是必需的（而不是真正的“提示”）。</p>
<p><img src="/2025/02/05/A-Primer-on-Memory-Consistency/1730733294157.png" alt="1730733294157"></p>
<h4 id="8-6-2-3-Limiting-the-Associativity-of-Inclusive-Directory-Caches"><a href="#8-6-2-3-Limiting-the-Associativity-of-Inclusive-Directory-Caches" class="headerlink" title="8.6.2.3 Limiting the Associativity of Inclusive Directory Caches"></a>8.6.2.3 Limiting the Associativity of Inclusive Directory Caches</h4><p>为了克服先前实现中高关联目录缓存的成本，我们提出了一种限制其关联性的技术。我们不是为最坏情况（C<em>K结合性）设计目录缓存，而是通过不允许最坏情况发生来限制结合性。也就是说，我们将目录缓存设计为A路集关联的，其中A&lt;C</em>K，并且我们不允许在芯片上缓存映射到给定目录缓存集的条目超过A个。当缓存控制器发出一个corherence请求，将一个块添加到它的缓存中，而目录缓存中相应的集合已经充满了有效条目时，目录控制器首先从所有缓存中取出该集合中的一个块,目录控制器执行此退出操作通过向持有该块的所有缓存发送“召回”请求，缓存将响应确认。一旦目录缓存中的条目通过此回调被释放，那么目录控制器就可以处理触发回调的原始一致性请求。</p>
<p>使用recall克服了在目录缓存中对高关联性的需求，但是如果不仔细设计，它可能会导致较差的性能。如果目录缓存太小，则会频繁发生召回，性能将受到影响。Conway等人[6]提出了一个经验法则，即目录缓存应该至少覆盖它所包含的聚合缓存的大小，但它也可以更大，以减少召回率。此外，为了避免不必要的回收，此方案最适合于状态s中的块的非静默回收。使用静默回收，不必要的回收将被发送到不再保存被回收块的缓存中。</p>
<h3 id="8-6-3-Null-Directory-Cache-with-no-backing-store"><a href="#8-6-3-Null-Directory-Cache-with-no-backing-store" class="headerlink" title="8.6.3 Null Directory Cache (with no backing store)"></a>8.6.3 Null Directory Cache (with no backing store)</h3><p>成本最低的目录缓存是根本没有目录缓存。回想一下，目录状态有助于修剪要转发一致性请求的一致性控制器集。但是，与粗目录（第8.5.1节）一样，如果这种修剪不完全完成，协议仍然可以正常工作，但是会发送不必要的消息，并且协议的效率比它可能的要低。在极端情况下，Dir0B协议（第8.5.2节）不进行任何修剪，在这种情况下，它实际上根本不需要目录（或目录缓存）。每当一致性请求到达目录控制器时，目录控制器简单地将其转发到所有缓存（即广播转发的请求）。这种目录缓存设计（我们称之为空目录缓存）可能看起来很简单，但它在中小型系统中很流行，因为它不需要存储成本。</p>
<p>如果没有目录状态，可能会有人质疑目录控制器的目的，但是它有两个重要的作用。首先，与本章中的所有其他系统一样，目录控制器负责LLC；更准确地说，它是一个LLC&#x2F;目录控制器。第二，目录控制器作为协议中的排序点；如果多个内核并发地请求同一个块，则在目录控制器上对请求进行排序。目录控制器解析哪个请求首先发生。</p>
<h2 id="8-7-PERFORMANCE-AND-SCALABILITY-OPTIMIZATIONS"><a href="#8-7-PERFORMANCE-AND-SCALABILITY-OPTIMIZATIONS" class="headerlink" title="8.7 PERFORMANCE AND SCALABILITY OPTIMIZATIONS"></a>8.7 PERFORMANCE AND SCALABILITY OPTIMIZATIONS</h2><h3 id="8-7-1-Distributed-Directories"><a href="#8-7-1-Distributed-Directories" class="headerlink" title="8.7.1 Distributed Directories"></a>8.7.1 Distributed Directories</h3><p><img src="/2025/02/05/A-Primer-on-Memory-Consistency/1730734201922.png" alt="1730734201922"></p>
<p>到目前为止，我们假设有一个目录附加到单个整体 LLC。 这种设计显然有可能在这个共享的中央资源上造成性能瓶颈。 集中式瓶颈问题的典型、通用解决方案是分配资源。 给定块的目录仍然固定在一处，但不同的块可以有不同的目录。</p>
<p>在较旧的具有 N 个节点的多芯片多处理器中（每个节点由多个芯片组成，包括处理器核心和内存），每个节点通常具有与其关联的内存的 1&#x2F;N 以及相应的目录状态的 1&#x2F;N 。</p>
<p>我们在图 8.11 中说明了这样一个系统模型。 节点的内存地址分配通常是静态的，并且通常可以使用简单的算术轻松计算。 例如，在具有 N 个目录的系统中，块 B 的目录项可能位于目录 B 模 N 处。每个块都有一个主目录，即保存其内存和目录状态的目录。 因此，我们最终得到一个系统，其中有多个独立的目录管理不同块集的一致性。 与要求所有一致性流量通过单个中央资源相比，拥有多个目录可以提供更大的一致性事务带宽。 重要的是，分发目录对一致性协议没有影响。</p>
<p>在当今具有大型 LLC 和目录缓存的多核处理器世界中，分发目录的方法在逻辑上与传统多芯片多处理器中的方法相同。 我们可以分发（存储）LLC 和目录缓存。 每个块都有一个 LLC 主库及其关联的目录缓存库。</p>
<h2 id="8-7-2-Non-Stalling-Directory-Protocols"><a href="#8-7-2-Non-Stalling-Directory-Protocols" class="headerlink" title="8.7.2 Non-Stalling Directory Protocols"></a>8.7.2 Non-Stalling Directory Protocols</h2>]]></content>
      <categories>
        <category>计算机体系结构</category>
      </categories>
  </entry>
  <entry>
    <title>BOP预取器</title>
    <url>/2025/02/05/BOP%E9%A2%84%E5%8F%96%E5%99%A8/</url>
    <content><![CDATA[<h1 id="BOP介绍"><a href="#BOP介绍" class="headerlink" title="BOP介绍"></a>BOP介绍</h1><p>主要相对于SandBox有更好的timeliness，</p>
<h1 id="OFFSET-PREFETCHING"><a href="#OFFSET-PREFETCHING" class="headerlink" title="OFFSET PREFETCHING"></a>OFFSET PREFETCHING</h1><p>offset 预取是next line 的扩展，偏移量预取器预取行X +D，其中D为预取偏移量。情况D &#x3D; 1对应于下一行预取。本节提供一些示例来说明为什么偏移预取是一种有效的预取技术。下面的示例假设为64字节行。为方便起见，在存储器区域中访问的行用位向量表示，相邻的位表示相邻的行。位值告诉行是否被访问（“1”）或不被访问（“0”）。我们忽略了页面边界的影响，只考虑长访问流的稳定状态。</p>
<h2 id="3-1-Example-1-sequential-stream"><a href="#3-1-Example-1-sequential-stream" class="headerlink" title="3.1 Example 1: sequential stream"></a>3.1 Example 1: sequential stream</h2><p>考虑下面的顺序流：111111111111111111…</p>
<p>也就是说，程序访问的行是X、X+1、X+2，等等。在这个示例中，下一行预取器产生100%的预取覆盖率和准确性。但是，在访问X之后为X+1发出预取可能太迟，无法覆盖从最后一级缓存或内存中获取X+1的全部延迟，从而导致延迟预取。延迟预取可能会加快执行速度，但不如及时预取快。偏移量预取器在顺序流上产生100%的预取覆盖率和准确性，就像下一行预取器一样，但是如果偏移量足够大，可以提供及时的预取。</p>
<p>另一个可能降低预取覆盖率的因素是scrambling（乱序访存），即内存访问的时间顺序可能与程序顺序不完全匹配[11]。</p>
<p>一般来说，在长序列流上，对scrambling的容忍度随着偏移量的增大而提高。</p>
<h2 id="3-2-Example-2-strided-stream"><a href="#3-2-Example-2-strided-stream" class="headerlink" title="3.2 Example 2: strided stream"></a>3.2 Example 2: strided stream</h2><p>考虑一个加载指令访问一个常量步长为+96字节的数组。对于64字节的缓存行，在内存区域中访问的行是：110110110110110110…</p>
<p>如果在L1处没有步进预取器（或者如果它发出延迟预取），则观察L2访问（如AC&#x2F;DC[22]）的增量相关预取器将在这里完美地工作，因为行步进序列是周期性的（1,2,1,2，…）。尽管如此，在这个例子中，一个简单的偏移量预取器以3的倍数作为偏移量，可以获得100%的覆盖率和准确性。</p>
<p>通过将偏移量设置为一个周期内跨步的总和或该数字的倍数，理论上，偏移量预取可以在任何周期的行跨步序列上提供100%的覆盖率和准确性。</p>
<h2 id="3-3-Example-3-interleaved-streams"><a href="#3-3-Example-3-interleaved-streams" class="headerlink" title="3.3 Example 3: interleaved streams"></a>3.3 Example 3: interleaved streams</h2><p>考虑两个交错的流S1和S2访问不同的内存区域，并具有不同的行为：S1: 101010101010101010…</p>
<p>S2: 110110110110110110…</p>
<p>流S1单独可以用2的倍数作为偏移量完美地预取。流S2单独可以用3的倍数作为偏移量完美地预取。两个流都可以用6的倍数作为偏移量完美地预取。</p>
<h1 id="BEST-OFFSET-BO-PREFETCHING"><a href="#BEST-OFFSET-BO-PREFETCHING" class="headerlink" title="BEST-OFFSET (BO) PREFETCHING"></a>BEST-OFFSET (BO) PREFETCHING</h1><p><img src="/2025/02/05/BOP%E9%A2%84%E5%8F%96%E5%99%A8/1731049049568.png" alt="1731049049568"></p>
<p>图1显示了BO预取器的示意图。</p>
<p>图1中的符号D表示当前预取偏移量，即当前用于预取的偏移量。当对行X的读请求访问L2缓存时，如果这是一个未命中或预取命中（即，设置了预取位），并且如果X和X +D位于同一内存页，则对行X +D的预取请求被发送到L3缓存。</p>
<h2 id="4-1-Best-offset-learning"><a href="#4-1-Best-offset-learning" class="headerlink" title="4.1 Best-offset learning"></a>4.1 Best-offset learning</h2><p>预取偏移量D是自动动态设置的，试图适应应用程序的行为，这些行为可能会随着时间的推移而变化。</p>
<p>最佳偏移学习算法试图通过测试几个不同的偏移来找到最佳的预取偏移量。如果在访问行X时，行X - d最近有一次访问，那么偏移量d可能是一个很好的预取偏移量。然而，X - d最近被访问的事实并不足以保证行X会及时预取。我们希望预取在任何可能的情况下都是及时的。也就是说，对于行X来说，d是一个很好的预取偏移量，行X - d必须最近被访问过，但不是太近。</p>
<p>理想情况下，访问行X - d和X之间的时间应该大于完成预取请求的延迟。</p>
<p>我们的解决方案是在最近的请求（RR）表中记录已完成的预取请求的基址。</p>
<p>基址为触发预取请求的地址：预取行为X +D，则基址为X。从插入L2的预取行地址减去当前预取偏移量得到基址。</p>
<p>如果行X−d在RR表中，则表示最近下发了对行X−d + D的预取请求，并且已经完成。因此，如果一个预取请求发出的偏移量是d而不是D，那么它将是当前访问的行X的预取，并且这个预取将是及时的（假设取行X的延迟等于取行X - d + D的延迟）。</p>
<blockquote>
<p>注：这句话的意思就是偏移量为d的已经预取到X了，也就是D&#x3D;d</p>
</blockquote>
<p>对于RR表有几种可能的实现。在本研究中，我们选择最简单的实现：直接映射RR表，通过哈希函数访问，每个表项都包含一个标签（tag）。标签不需要是完整的地址，部分标签就足够了</p>
<p>除了RR表之外，BO预取器还具有<strong>偏移列表</strong>和<strong>分数表</strong>。分数表将分数与偏移列表中的每个偏移量关联起来。分数值在0到SCOREMAX之间（例如，SCOREMAX&#x3D;31表示5位分数）。</p>
<p>预取偏移量在每个学习阶段结束时更新。一个学习阶段包括几个回合。在学习阶段开始时，所有分数都重置为0。对于每个符合条件的L2读访问（<strong>未命中或预取命中</strong>），我们从列表中测试偏移量di。如果X−di命中RR表，则增加偏移量di的分数。在一轮中，列表中的每个偏移都测试一次：我们在一轮中第一次访问时测试d1，在下一次访问时测试d2，然后是d3，以此类推。当列表中的所有偏移量都测试完后，当前一轮结束，从偏移量d1再次开始新一轮。</p>
<blockquote>
<p>注：预取命中就是命中了预取来的块</p>
</blockquote>
<p>当前的学习阶段在一轮结束时，当以下两个事件中的任何一个首先发生：其中一个分数等于SCOREMAX，或者轮数等于ROUNDMAX（一个固定参数）。当学习阶段结束时，我们搜索最佳偏移量，即得分最高的偏移量。这个偏移量成为新的预取偏移量，开始一个新的学习阶段。</p>
<h2 id="4-2-Offset-list"><a href="#4-2-Offset-list" class="headerlink" title="4.2 Offset list"></a>4.2 Offset list</h2><p>没有什么可以阻止BO预取器使用负偏移值。虽然一些应用程序可能从负偏移中受益，但我们在实验中没有观察到任何好处。因此，我们在本研究中只考虑<strong>正偏移</strong>。有用的偏移量值取决于内存页大小，因为BO预取器不会跨页边界预取。例如，假设4KB页和64B行，一个页包含64行，并且没有必要考虑大于63的偏移值。但是，对于具有超级页面的系统，考虑大于63的偏移量可能是有用的。在偏移列表中包含的偏移量的选择有些随意。例如，一种可能性是包含从1到最大偏移量之间的所有偏移量。然而，这个最大偏移量不能太大，因为较大的偏移量列表意味着较大的分数表和较长的学习阶段。如果我们想让列表包含较大的偏移量，但又不想让列表太大，我们必须采样1和最大偏移量之间的偏移量（这需要将偏移量列表实现为ROM）。使用数千个代表性基准测试的微架构师可能希望对要放在列表中的偏移量进行广泛的探索。我们没有足够的基准来进行这样的探索。</p>
<p>我们提出了一种偏移采样的方法，它是算法的，不是完全任意的：我们在我们的列表中包括所有在1到256之间的偏移，其质因数分解不包含大于5的质数。这给出了以下52个偏移量的列表：12 3 45 6 8 9 10 12 15 16 18 20 24 25 27 30 32 36 40 45 48 50 54 60 64 72 75 80 81 90 96 100 108 120 125 128 135 144 150 160 162 180 192 200 216 225 240 243 250 256。</p>
<p>仅考虑具有小质数因子的偏移量有两个好处：</p>
<p>•小偏移量比大偏移量更具代表性（小偏移量更可能有用）。</p>
<p>•偏移列表比全偏移范围小得多。</p>
<p>此外，这种方法与3.3节的例子是一致的：如果列表中有两个偏移量，那么它们的最小公倍数也是如此（前提是它不是太大）。</p>
<h2 id="4-3-Prefetch-throttling"><a href="#4-3-Prefetch-throttling" class="headerlink" title="4.3 Prefetch throttling"></a>4.3 Prefetch throttling</h2><p>BO预取器是一级预取器：每次访问最多发出一次预取。</p>
<p>可以想象一个预取度大于1的偏移预取器。例如，二级偏移量预取器将同时预取两个不同的偏移量，最佳偏移量和次最佳偏移量。这可能会为具有不规则访问模式的应用程序带来一些额外的性能。但是，这将增加预取请求的数量，给内存带宽和缓存标签带来更大的压力，除非实现预取过滤器。不需要带有一级BO预取器的预取过滤器。此外，使用两个偏移量的预取可能会在不规则的内存访问模式下产生许多无用的预取。</p>
<blockquote>
<p>举例：With two different prefetch offsets D1 and D2, redundant prefetch requests are issued when accessing lines X and X +D1 −D2.</p>
</blockquote>
<p>尽管如此，与其他一些预取方法（如跨步预取）相比，BO预取是相对积极的。对不规则访问模式发出的无用预取浪费了能量和内存带宽。在学习阶段结束时获得的最佳分数给出了关于预取准确性的一些信息。如果分数很低，这可能意味着偏移预取失败，我们可能决定关闭预取。我们定义了一个固定的阈值<strong>BADSCORE</strong>，这样当最佳分数不大于BADSCORE时，就会关闭预取。然而，最佳偏移学习永远不会停止，即使在预取关闭时也会继续，因此当应用程序行为发生变化并需要预取时，可以再次打开预取。</p>
<p>图1说明了预取打开的情况：对于插入L2的每个预取行Y，我们写入地址Y−D 4。这将是一个过拟合的情况。由于D1和D2两个不同的预取偏移量，访问线路X和X +D1−D2时会发出冗余预取请求。到RR表中（如果Y和Y−D在同一页）。在预取关闭的学习阶段，在RR表中的插入被修改：对于每个提取的行Y，我们将地址Y写入RR表（即D &#x3D; 0）。</p>
<blockquote>
<p>这里也就是预取关闭D一定为0，所以将Y写入D</p>
</blockquote>
<h2 id="4-4-Implementation-details"><a href="#4-4-Implementation-details" class="headerlink" title="4.4 Implementation details"></a>4.4 Implementation details</h2><p>BO预取器具有3个加法器，如图1所示。这些加法器只需要生成页面内一行的位置。例如，对于4MB页面和64B行，每个加法器的宽度为22−6 &#x3D; 16位。页码位只是简单地从基址X或从预取的行地址Y复制（参见图1）。通过简单的哈希函数访问RR表。例如，对于一个包含256个条目的RR表，我们将最低8位行地址位与次低的8位进行异或，以获得表索引。对于12位标签，我们跳过8个最低有效行地址位并提取接下来的12位。</p>
<h1 id="BASELINE-MICROARCHITECTURE"><a href="#BASELINE-MICROARCHITECTURE" class="headerlink" title="BASELINE MICROARCHITECTURE"></a>BASELINE MICROARCHITECTURE</h1><p>预取不是独立模型，需要考虑其他微结构影响</p>
<p><img src="/2025/02/05/BOP%E9%A2%84%E5%8F%96%E5%99%A8/1731054466977.png" alt="1731054466977"></p>
<p>首先这是基线模型，然后测试了1，2，4核工作对core0的影响，462程序会大大降低core0 的ipc</p>
<p><img src="/2025/02/05/BOP%E9%A2%84%E5%8F%96%E5%99%A8/1731054598236.png" alt="1731054598236"></p>
<p><img src="/2025/02/05/BOP%E9%A2%84%E5%8F%96%E5%99%A8/1731055018638.png" alt="1731055018638"></p>
<p>他之后的实验工作就是通过固定offset测试BOP的偏移表是否含在内部，同时对比性能</p>
]]></content>
      <categories>
        <category>论文阅读</category>
      </categories>
  </entry>
  <entry>
    <title>DNN 加速器</title>
    <url>/2025/02/05/DNN-%E5%8A%A0%E9%80%9F%E5%99%A8/</url>
    <content><![CDATA[<h1 id="DNN加速器综述"><a href="#DNN加速器综述" class="headerlink" title="DNN加速器综述"></a>DNN加速器综述</h1><h2 id="硬件方案"><a href="#硬件方案" class="headerlink" title="硬件方案"></a>硬件方案</h2><p>两种架构:temporal and spatial architectures<br><img src="/2025/02/05/DNN-%E5%8A%A0%E9%80%9F%E5%99%A8/image00.png" alt="alt text"><br>其中asic和fpga主要为spatial结构,而CPU和GPU主要为temporal结构<br><strong>本次主要介绍空间架构</strong><br>这种结构有相当一部分能耗在存储上,故数据重用是研究重点<br><img src="/2025/02/05/DNN-%E5%8A%A0%E9%80%9F%E5%99%A8/image-1.png" alt="基本结构"><br>一些重用名词<br>input reuse:FC层<br>weight reuse:CONV层<br>conv reuse:卷积层的滑窗每次都有重复的<br><strong>Weight Stationary</strong><br>所有使用相同weight的mac必须映射到同一PE上进行串行处理。这最大限度地提高了RF中权重的卷积和滤波器重用，从而最大限度地减少了访问权重的能量消耗<br><img src="/2025/02/05/DNN-%E5%8A%A0%E9%80%9F%E5%99%A8/image-2.png" alt="alt text"><br>这是一个3x3的矩阵2x2的卷积核,最后生成2x2的输出<br><img src="/2025/02/05/DNN-%E5%8A%A0%E9%80%9F%E5%99%A8/image-3.png" alt="alt text"><br>先说上面那一种<br>仅介绍一个输出元素如何产生的,<br>T1:I0XW0<br>T2:I0XW0+I1XW1<br>T3:将结果移入PE2<br>T4:I0XW0+I1XW1+I2XW2<br>T5:I0XW0+I1XW1+I2XW2+I3XW3,完成一次卷积操作<br>下面哪一种和上面类似,不过是再次分块了<br><strong>Output Stationary</strong><br>映射规则是对相同的输出像素的所有mac必须依次映射到同一PE上。<br><img src="/2025/02/05/DNN-%E5%8A%A0%E9%80%9F%E5%99%A8/image-4.png" alt="alt text"><br><strong>Row Stationary</strong><br><img src="/2025/02/05/DNN-%E5%8A%A0%E9%80%9F%E5%99%A8/image-5.png" alt="alt text"><br><strong>No Local Reuse</strong><br><img src="/2025/02/05/DNN-%E5%8A%A0%E9%80%9F%E5%99%A8/image-6.png" alt="alt text"></p>
]]></content>
      <categories>
        <category>论文阅读</category>
      </categories>
  </entry>
  <entry>
    <title>SMS预取</title>
    <url>/2025/02/05/SMS%E9%A2%84%E5%8F%96/</url>
    <content><![CDATA[<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>识别编码相关的空间访问模式，然后将这些块预取到Cache</p>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><h1 id="摘要-1"><a href="#摘要-1" class="headerlink" title="摘要"></a>摘要</h1><p>识别编码相关的空间访问模式，然后将这些块预取到Cache</p>
<h1 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h1><p>首先得出结论：增加并行性和隐藏访问延迟才是提高服务器性能的关键，商业程序使用重复布局和访问模式的数据结构，例如数据块缓存池页面，或者网络数据包头。当程序访问数据集，访问数据的偏移会出现重复模式，但这些访问通常不连续，并且stride不一，我们使用空间相关性而不思空间局部性来描述访问之间的关系</p>
<pre><code>SMS可以减少多处理器服务器的主缓存缺失和片外缺失，他利用重复访问模式来预测并预取
</code></pre>
<p>这份工作的特点：</p>
<ol>
<li>高效的空间相关性预测：预测商业负载访问流不需要基于地址的相关性。SMS利用代码和访问模式的相关性来预测模式，甚至是之前没访问的地址，SMS提供的预测覆盖率是其他基于地址的4倍</li>
<li>精确跟踪空间相关性：以前的缓存耦合结构观察空间相关性是次优的，比如交错的访问模式，之前的检测会引起冲突，我们提出解耦结构，可以识别更少更密集的模式，将预测器存储需求减半</li>
<li>增加性能：主要讲了SMS在商业负载的优秀</li>
</ol>
<p>之后第二节描述SMS，第三节给出硬件细节，第四节评估性能，第五节讨论相关工作</p>
<h1 id="Spatial-Memory-Streaming"><a href="#Spatial-Memory-Streaming" class="headerlink" title="Spatial Memory Streaming"></a>Spatial Memory Streaming</h1><p>在选择Cache block，设计者在各种因素中取出最优解，通常最佳的缓存块大小牺牲了利用密集数据结构的空间局部性，以避稀疏结构带来的过多带宽开销，对于简单的数据结构，如数组，空间关系可以通过简单的预取实现，如stride prefetching</p>
<p>商业负载访问模式较为复杂，不适合用 simple prefetching or streaming schemes，然而，这些应用程序中的数据结构经常显示缓存块之间的空间关系。例如，在数据库中，缓冲池中的页面共享公共结构元素，例如页头中的日志序列号和指示页脚中元组偏移量的槽索引，这些元素总是在扫描&#x2F;修改页面之前被访问。在web服务器中，包头和包尾具有任意复杂但固定的结构。图1（左）显示了更多的示例。尽管这些结构中的访问可能是不连续的，但它们在相对地址中仍然表现出重复的模式。我们称这些访问之间的关系为<strong>空间相关性</strong></p>
<p><img src="/2025/02/05/SMS%E9%A2%84%E5%8F%96/1729853439799.png" alt="1729853439799"></p>
<p>SMS在运行时提取空间相关访问模式，并使用这些模式预测，他在可用带宽和资源允许情况尽快将预测的缓存块放入Cache，从而增加内存并行性并隐藏低级缓存和片外访存延迟</p>
<h2 id="Spatial-Patterns-and-Generations"><a href="#Spatial-Patterns-and-Generations" class="headerlink" title="Spatial Patterns and Generations"></a>Spatial Patterns and Generations</h2><p>我们形式化了空间相关性的概念，类似于先前的空间足迹研究[4,17]。我们将空间区域定义为系统地址空间中固定大小的部分，由多个连续的缓存块组成。A spatial region generation is the time interval over which SMS records accesses within a spatial region，我们把第一次访问这个空间区域称为触发访问，空间模式是表示在a spatial region generation期间访问区域的blocks集合的位向量？？？</p>
<p>定义a spatial region generation精确间隔会显著影响空间格局的精度和覆盖范围，a spatial region generation必须定义以确保，当SMS流在未来触发访问时进入缓存，没有预测的块在使用前被驱除或无效，</p>
<p>因此，我们选择从触发访问到在生成期间访问的任何块通过替换或失效从处理器的主缓存中删除的间隔。对该区域中任何块的后续访问都是对新一代的触发访问。</p>
<p>此定义确保在生成过程中访问的块集同时存在于缓存中。</p>
<h2 id="Identifying-Recurring-Spatial-Patterns"><a href="#Identifying-Recurring-Spatial-Patterns" class="headerlink" title="Identifying Recurring Spatial Patterns"></a>Identifying Recurring Spatial Patterns</h2><p>在触发访问时，SMS预测区域内相关性块子集，于是其关键问题就是找到一个与重复出现的空间模式强相关的预测指数</p>
<p>空间相关性由于数据结构布局和访问模式重复和规律性产生，例如聚合的几个变量经常被一起访问，因此出现空间相关性，<strong>这种情况，空间模式与触发器访问地址相关</strong>，地址标识数据结构，还有一种就是数据结构遍历重复出现或者具有规则结构，在这种情况，空间模式将与执行遍历的代码（pc）相关联，文献中研究了多种预测指标，先前的研究发现当相关表存储无界？？，结合地址和PC构建索引可以提供最准确的预测，也就是PC+addr indexing，当多个代码序列对同一数据结构进行不同遍历，预测器会生成不同的模式，然而，该预测索引需要随数据集大小缩放预测期存储，而且预测覆盖率会随着存储限制而急剧下降</p>
<p>对于SPEC CPU 2000程序，PC+addr可以通过pc+a spatial region offset实现，这个偏移是cache block中与空间区域起始位置的相对地址，也就是相当于这个区域的哪个block，这个偏移允许预测器区分由相同代码片段生成的重复模式，这些重复模式不同支出就是他们相对空间区域边界对其，大大减少预测表存储需求，applications have far fewer distinct miss PCs than miss addresses.</p>
<p>我们观察到这种索引，除了节省内存，还可以消除cold misses，当代码序列在大型数据集重复相同的访问模式，访问序列刚开始时学习的PC相关空间模式为以前从未访问的数据提供准确预测。Database scan and join operations, which dominate the execution of decision support queries 包含着只访问数据以此的唱重复访问模式，这些应用适合这种index方式</p>
<h1 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h1><p>(终于到自己的SMS设计了)</p>
<p>我们的设计目标是多处理器环境下的高性能商业服务器应用程序，区别：之前的设计针对<strong>decoupled sectored</strong> [22] or <strong>sub-blocked caches.</strong></p>
<p>预测和缓存集成简化硬件设计，因为空间区域访问的结构可以2和sub-blocks的tag集成，然而，不同空间区域交错访问导致标签冲突，桃枝空间区域碎片化1，降低准确性，所以SMS不使用子块</p>
<p>他包括两个结构</p>
<blockquote>
<p>The pattern history table stores previously-observed spatial patterns, and is accessed at the start of each spatial region generation to predict the pattern of future accesses.</p>
</blockquote>
<h2 id="Observing-Spatial-Patterns"><a href="#Observing-Spatial-Patterns" class="headerlink" title="Observing Spatial Patterns"></a>Observing Spatial Patterns</h2><p>SMS通过记录在AGT空间区域生成过程中访问的块来学习空间模式，当空间区域生成开始时，SMS在AGT分配一个条目，当cache block被访问，更新AGT记录的模式，当eviction&#x2F;invalidation of any block accessed during the generation)，AGT将空间模式转移到PHT，然后释放条目</p>
<p>实际AGT有两个内容表，积累表和过滤表，减少搜索难度和总体大小，AGT处理L1数据访问，所以两个表必须都能匹配数据访问带宽</p>
<p>空间模式记录在累积表，累计表条目由空间区域标记来标记，即区域及地址高位，每个条目存储触发访问的PC和空间区域偏移量，以及指示在生成期间访问了哪些块的空间模式位向量</p>
<p>新的空间区域最初在过滤表，过滤表记录tag，pc和offset，用于在当次只有一次访问的空间区域，有很少的区域永远不会访问第二个快，预测这些没有好处，因为唯一的访问是触发访问，将这些限制在过滤表，减少了累计表的空间占用</p>
<p><img src="/2025/02/05/SMS%E9%A2%84%E5%8F%96/1729857733789.png" alt="1729857733789"></p>
<p>上图描述了AGT详细操作，每个L1访问，首先搜索累计表，如果匹配，设置所访问块的空间模式位，否则，在筛选表找，如果没找到，这次访问就是触发访问，并在筛选表重新分配条目，如果在筛选表匹配，则比较偏移，如果不同，该快是区域访问的第二个快，将这个条目移到累计表，对该区域其他访问将在模式中设置相应位，这个位代表一个区域有几个block，当有的快被驱除或无效，则结束生成，这时在过滤表和累积表搜索标签，过滤表的条目将被抛弃，累积表的放入模式历史表，如果其中一个表满了，选择一个表项，终止生成，即，从过滤表中删除该表项或从累积表转移到模式历史表中</p>
<h2 id="Predicting-Spatial-Patterns"><a href="#Predicting-Spatial-Patterns" class="headerlink" title="Predicting Spatial Patterns"></a>Predicting Spatial Patterns</h2><p>SMS使用模式历史表对空间模式进行存储，并预测在每个区域将访问块的模式，PHT实现和预测如下，其被组织为类似cache的组相连结构，其由预测索引访问，这个索引是PC和空间区域偏移组成，PHT每个条目存储AGT积累的访问模式</p>
<p><img src="/2025/02/05/SMS%E9%A2%84%E5%8F%96/1729864558517.png" alt="1729864558517"></p>
<p>在触发访问是,SMS查询PHT来预测访问哪些块，如果找到一个条目，空间区域的基地址和空间模式将被复制到几个预测寄存器的一个，当SMS将模式预测的每个块传输到主缓存，他会清除预测寄存器的位，当预测寄存器整个模式被清除，寄存器释放，如果多个预测寄存器活动，SMS轮训操作，这个流请求类似于缓存一致性协议的读请求</p>
<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="访问密度"><a href="#访问密度" class="headerlink" title="访问密度"></a><strong>访问密度</strong></h2><p><img src="/2025/02/05/SMS%E9%A2%84%E5%8F%96/1729867839321.png" alt="1729867839321"></p>
<h2 id="indexing"><a href="#indexing" class="headerlink" title="indexing"></a>indexing</h2><p><img src="/2025/02/05/SMS%E9%A2%84%E5%8F%96/1729867930971.png" alt="1729867930971"></p>
<p>名词：<strong>覆盖率</strong>表示通过SMS消除的L1读错误的比例。</p>
<p>过度预测表示在取出或无效前已获取但未使用的块，也就是一些无用的预取</p>
<p>在OLTP和web应用，大多数空间相关访问都来自频繁访问的代码序列和数据结构，因此数据地址和PC都和空间模式相关，所以除了PC寻址，其他的覆盖率相似，PC不准确，他不能区分相同代码对不同数据结构的访问模式，PC+偏移索引可以根据空间区域偏移量来区分模式，足以捕捉到常见的情况</p>
<p>而DSS基于程序上下文，PC和PC+off较好</p>
<p>对于科学应用，pc+off接近pc+addr</p>
<p>pc+off的第二个优点就是：他的存储需求与代码大小成正比而不是数据集大小，</p>
<h2 id="4-3-Decoupled-Training"><a href="#4-3-Decoupled-Training" class="headerlink" title="4.3. Decoupled Training"></a>4.3. Decoupled Training</h2><p>训练十分重要，过早终止空间区域生成，可能导致PHT被污染</p>
<p><img src="/2025/02/05/SMS%E9%A2%84%E5%8F%96/1729868738111.png" alt="1729868738111"></p>
<p>可以看到AGT覆盖率最高</p>
<h2 id="4-4-Spatial-Region-Size"><a href="#4-4-Spatial-Region-Size" class="headerlink" title="4.4. Spatial Region Size"></a>4.4. Spatial Region Size</h2><blockquote>
<p>Choosing a spatial region size involves a tradeoff between coverage and storage requirements.</p>
</blockquote>
<h2 id="4-5-Active-Generation-Table"><a href="#4-5-Active-Generation-Table" class="headerlink" title="4.5. Active Generation Table"></a>4.5. Active Generation Table</h2><p>a 32-entry filter table and a 64-entry accumulation table are sufficient.</p>
<p>首先得出结论：增加并行性和隐藏访问延迟才是提高服务器性能的关键，商业程序使用重复布局和访问模式的数据结构，例如数据块缓存池页面，或者网络数据包头。当程序访问数据集，访问数据的偏移会出现重复模式，但这些访问通常不连续，并且stride不一，我们使用空间相关性而不思空间局部性来描述访问之间的关系</p>
<pre><code>SMS可以减少多处理器服务器的主缓存缺失和片外缺失，他利用重复访问模式来预测并预取
</code></pre>
<p>这份工作的特点：</p>
<ol>
<li>高效的空间相关性预测：预测商业负载访问流不需要基于地址的相关性。SMS利用代码和访问模式的相关性来预测模式，甚至是之前没访问的地址，SMS提供的预测覆盖率是其他基于地址的4倍</li>
<li>精确跟踪空间相关性：以前的缓存耦合结构观察空间相关性是次优的，比如交错的访问模式，之前的检测会引起冲突，我们提出解耦结构，可以识别更少更密集的模式，将预测器存储需求减半</li>
<li>增加性能：主要讲了SMS在商业负载的优秀</li>
</ol>
<p>之后第二节描述SMS，第三节给出硬件细节，第四节评估性能，第五节讨论相关工作</p>
<h1 id="Spatial-Memory-Streaming-1"><a href="#Spatial-Memory-Streaming-1" class="headerlink" title="Spatial Memory Streaming"></a>Spatial Memory Streaming</h1><p>在选择Cache block，设计者在各种因素中取出最优解，通常最佳的缓存块大小牺牲了利用密集数据结构的空间局部性，以避稀疏结构带来的过多带宽开销，对于简单的数据结构，如数组，空间关系可以通过简单的预取实现，如stride prefetching</p>
<p>商业负载访问模式较为复杂，不适合用 simple prefetching or streaming schemes，然而，这些应用程序中的数据结构经常显示缓存块之间的空间关系。例如，在数据库中，缓冲池中的页面共享公共结构元素，例如页头中的日志序列号和指示页脚中元组偏移量的槽索引，这些元素总是在扫描&#x2F;修改页面之前被访问。在web服务器中，包头和包尾具有任意复杂但固定的结构。图1（左）显示了更多的示例。尽管这些结构中的访问可能是不连续的，但它们在相对地址中仍然表现出重复的模式。我们称这些访问之间的关系为<strong>空间相关性</strong></p>
<p><img src="/2025/02/05/SMS%E9%A2%84%E5%8F%96/1729853439799.png" alt="1729853439799"></p>
<p>SMS在运行时提取空间相关访问模式，并使用这些模式预测，他在可用带宽和资源允许情况尽快将预测的缓存块放入Cache，从而增加内存并行性并隐藏低级缓存和片外访存延迟</p>
<h2 id="Spatial-Patterns-and-Generations-1"><a href="#Spatial-Patterns-and-Generations-1" class="headerlink" title="Spatial Patterns and Generations"></a>Spatial Patterns and Generations</h2><p>我们形式化了空间相关性的概念，类似于先前的空间足迹研究[4,17]。我们将空间区域定义为系统地址空间中固定大小的部分，由多个连续的缓存块组成。A spatial region generation is the time interval over which SMS records accesses within a spatial region，我们把第一次访问这个空间区域称为触发访问，空间模式是表示在a spatial region generation期间访问区域的blocks集合的位向量？？？</p>
<p>定义a spatial region generation精确间隔会显著影响空间格局的精度和覆盖范围，a spatial region generation必须定义以确保，当SMS流在未来触发访问时进入缓存，没有预测的块在使用前被驱除或无效，</p>
<p>因此，我们选择从触发访问到在生成期间访问的任何块通过替换或失效从处理器的主缓存中删除的间隔。对该区域中任何块的后续访问都是对新一代的触发访问。</p>
<p>此定义确保在生成过程中访问的块集同时存在于缓存中。</p>
<h2 id="Identifying-Recurring-Spatial-Patterns-1"><a href="#Identifying-Recurring-Spatial-Patterns-1" class="headerlink" title="Identifying Recurring Spatial Patterns"></a>Identifying Recurring Spatial Patterns</h2><p>在触发访问时，SMS预测区域内相关性块子集，于是其关键问题就是找到一个与重复出现的空间模式强相关的预测指数</p>
<p>空间相关性由于数据结构布局和访问模式重复和规律性产生，例如聚合的几个变量经常被一起访问，因此出现空间相关性，<strong>这种情况，空间模式与触发器访问地址相关</strong>，地址标识数据结构，还有一种就是数据结构遍历重复出现或者具有规则结构，在这种情况，空间模式将与执行遍历的代码（pc）相关联，文献中研究了多种预测指标，先前的研究发现当相关表存储无界？？，结合地址和PC构建索引可以提供最准确的预测，也就是PC+addr indexing，当多个代码序列对同一数据结构进行不同遍历，预测器会生成不同的模式，然而，该预测索引需要随数据集大小缩放预测期存储，而且预测覆盖率会随着存储限制而急剧下降</p>
<p>对于SPEC CPU 2000程序，PC+addr可以通过pc+a spatial region offset实现，这个偏移是cache block中与空间区域起始位置的相对地址，也就是相当于这个区域的哪个block，这个偏移允许预测器区分由相同代码片段生成的重复模式，这些重复模式不同支出就是他们相对空间区域边界对其，大大减少预测表存储需求，applications have far fewer distinct miss PCs than miss addresses.</p>
<p>我们观察到这种索引，除了节省内存，还可以消除cold misses，当代码序列在大型数据集重复相同的访问模式，访问序列刚开始时学习的PC相关空间模式为以前从未访问的数据提供准确预测。Database scan and join operations, which dominate the execution of decision support queries 包含着只访问数据以此的唱重复访问模式，这些应用适合这种index方式</p>
<h1 id="设计-1"><a href="#设计-1" class="headerlink" title="设计"></a>设计</h1><p>(终于到自己的SMS设计了)</p>
<p>我们的设计目标是多处理器环境下的高性能商业服务器应用程序，区别：之前的设计针对<strong>decoupled sectored</strong> [22] or <strong>sub-blocked caches.</strong></p>
<p>预测和缓存集成简化硬件设计，因为空间区域访问的结构可以2和sub-blocks的tag集成，然而，不同空间区域交错访问导致标签冲突，桃枝空间区域碎片化1，降低准确性，所以SMS不使用子块</p>
<p>他包括两个结构</p>
<blockquote>
<p>The pattern history table stores previously-observed spatial patterns, and is accessed at the start of each spatial region generation to predict the pattern of future accesses.</p>
</blockquote>
<h2 id="Observing-Spatial-Patterns-1"><a href="#Observing-Spatial-Patterns-1" class="headerlink" title="Observing Spatial Patterns"></a>Observing Spatial Patterns</h2><p>SMS通过记录在AGT空间区域生成过程中访问的块来学习空间模式，当空间区域生成开始时，SMS在AGT分配一个条目，当cache block被访问，更新AGT记录的模式，当eviction&#x2F;invalidation of any block accessed during the generation)，AGT将空间模式转移到PHT，然后释放条目</p>
<p>实际AGT有两个内容表，积累表和过滤表，减少搜索难度和总体大小，AGT处理L1数据访问，所以两个表必须都能匹配数据访问带宽</p>
<p>空间模式记录在累积表，累计表条目由空间区域标记来标记，即区域及地址高位，每个条目存储触发访问的PC和空间区域偏移量，以及指示在生成期间访问了哪些块的空间模式位向量</p>
<p>新的空间区域最初在过滤表，过滤表记录tag，pc和offset，用于在当次只有一次访问的空间区域，有很少的区域永远不会访问第二个快，预测这些没有好处，因为唯一的访问是触发访问，将这些限制在过滤表，减少了累计表的空间占用</p>
<p><img src="/2025/02/05/SMS%E9%A2%84%E5%8F%96/1729857733789.png" alt="1729857733789"></p>
<p>上图描述了AGT详细操作，每个L1访问，首先搜索累计表，如果匹配，设置所访问块的空间模式位，否则，在筛选表找，如果没找到，这次访问就是触发访问，并在筛选表重新分配条目，如果在筛选表匹配，则比较偏移，如果不同，该快是区域访问的第二个快，将这个条目移到累计表，对该区域其他访问将在模式中设置相应位，这个位代表一个区域有几个block，当有的快被驱除或无效，则结束生成，这时在过滤表和累积表搜索标签，过滤表的条目将被抛弃，累积表的放入模式历史表，如果其中一个表满了，选择一个表项，终止生成，即，从过滤表中删除该表项或从累积表转移到模式历史表中</p>
<h2 id="Predicting-Spatial-Patterns-1"><a href="#Predicting-Spatial-Patterns-1" class="headerlink" title="Predicting Spatial Patterns"></a>Predicting Spatial Patterns</h2><p>SMS使用模式历史表对空间模式进行存储，并预测在每个区域将访问块的模式，PHT实现和预测如下，其被组织为类似cache的组相连结构，其由预测索引访问，这个索引是PC和空间区域偏移组成，PHT每个条目存储AGT积累的访问模式</p>
<p><img src="/2025/02/05/SMS%E9%A2%84%E5%8F%96/1729864558517.png" alt="1729864558517"></p>
<p>在触发访问是,SMS查询PHT来预测访问哪些块，如果找到一个条目，空间区域的基地址和空间模式将被复制到几个预测寄存器的一个，当SMS将模式预测的每个块传输到主缓存，他会清除预测寄存器的位，当预测寄存器整个模式被清除，寄存器释放，如果多个预测寄存器活动，SMS轮训操作，这个流请求类似于缓存一致性协议的读请求</p>
<h1 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h1><h2 id="访问密度-1"><a href="#访问密度-1" class="headerlink" title="访问密度"></a><strong>访问密度</strong></h2><p><img src="/2025/02/05/SMS%E9%A2%84%E5%8F%96/1729867839321.png" alt="1729867839321"></p>
<h2 id="indexing-1"><a href="#indexing-1" class="headerlink" title="indexing"></a>indexing</h2><p><img src="/2025/02/05/SMS%E9%A2%84%E5%8F%96/1729867930971.png" alt="1729867930971"></p>
<p>名词：<strong>覆盖率</strong>表示通过SMS消除的L1读错误的比例。</p>
<p>过度预测表示在取出或无效前已获取但未使用的块，也就是一些无用的预取</p>
<p>在OLTP和web应用，大多数空间相关访问都来自频繁访问的代码序列和数据结构，因此数据地址和PC都和空间模式相关，所以除了PC寻址，其他的覆盖率相似，PC不准确，他不能区分相同代码对不同数据结构的访问模式，PC+偏移索引可以根据空间区域偏移量来区分模式，足以捕捉到常见的情况</p>
<p>而DSS基于程序上下文，PC和PC+off较好</p>
<p>对于科学应用，pc+off接近pc+addr</p>
<p>pc+off的第二个优点就是：他的存储需求与代码大小成正比而不是数据集大小，</p>
<h2 id="4-3-Decoupled-Training-1"><a href="#4-3-Decoupled-Training-1" class="headerlink" title="4.3. Decoupled Training"></a>4.3. Decoupled Training</h2><p>训练十分重要，过早终止空间区域生成，可能导致PHT被污染</p>
<p><img src="/2025/02/05/SMS%E9%A2%84%E5%8F%96/1729868738111.png" alt="1729868738111"></p>
<p>可以看到AGT覆盖率最高</p>
<h2 id="4-4-Spatial-Region-Size-1"><a href="#4-4-Spatial-Region-Size-1" class="headerlink" title="4.4. Spatial Region Size"></a>4.4. Spatial Region Size</h2><blockquote>
<p>Choosing a spatial region size involves a tradeoff between coverage and storage requirements.</p>
</blockquote>
<h2 id="4-5-Active-Generation-Table-1"><a href="#4-5-Active-Generation-Table-1" class="headerlink" title="4.5. Active Generation Table"></a>4.5. Active Generation Table</h2><p>a 32-entry filter table and a 64-entry accumulation table are sufficient.</p>
]]></content>
      <categories>
        <category>论文阅读</category>
      </categories>
  </entry>
  <entry>
    <title>gem5</title>
    <url>/2025/02/05/gem5/</url>
    <content><![CDATA[<ul>
<li><input checked disabled type="checkbox"> event programming</li>
<li><input checked disabled type="checkbox"> new config</li>
<li><input checked disabled type="checkbox"> debug flags</li>
<li><input disabled type="checkbox"> out of order</li>
</ul>
<p><strong>在GEM5退出时，Dump cache中所有的line的地址和内容， 参考<a href="https://www.gem5.org/documentation/learning_gem5/part2/events/">Event-driven programming</a>， 但是退出的event callback和这里展示的例子不完全一样，需要自己去阅读相关代码。</strong></p>
<p>首先我使用的CPU类型为TimeSimpleCPU,直接找他与Cache如何交互,也即是下图</p>
<p><img src="/2025/02/05/gem5/1730213552828.png" alt="1730213552828"></p>
<p>然后找到了tags,这里可以打印所有的blk</p>
<p>在cache&#x2F;tags&#x2F;base.cc,可以打印所有的blk</p>
<p><img src="/2025/02/05/gem5/1730213976910.png" alt="1730213976910"></p>
<p>registerExitCallback注意这个函数</p>
<p><img src="/2025/02/05/gem5/1730215799144.png" alt="1730215799144"></p>
<p>这个是tag&#x2F;base.cc</p>
<p>这个如何实现遍历:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void forEachBlk(std::function&lt;void(CacheBlk &amp;)&gt; visitor) override &#123;</span><br><span class="line">    for (CacheBlk&amp; blk : blks) &#123;</span><br><span class="line">        visitor(blk);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>首先将输入参数变为函数,接受一个blk参数,然后这个blks是blk的集合,存了所有blk,然后进行遍历</p>
<p>这个是base_set_assoc.h</p>
<p>所以可以在结束时调用这个函数,这样就可打印全部内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BaseTags::BaseTags(const Params &amp;p)</span><br><span class="line">    : ClockedObject(p), blkSize(p.block_size), blkMask(blkSize - 1),</span><br><span class="line">      size(p.size), lookupLatency(p.tag_latency),</span><br><span class="line">      system(p.system), indexingPolicy(p.indexing_policy),</span><br><span class="line">      warmupBound((p.warmup_percentage/100.0) * (p.size / p.block_size)),</span><br><span class="line">      warmedUp(false), numBlocks(p.size / p.block_size),</span><br><span class="line">      dataBlks(new uint8_t[p.size]), // Allocate data storage in one big chunk</span><br><span class="line">      stats(*this)</span><br><span class="line">&#123;</span><br><span class="line">    // registerExitCallback([this]() &#123; cleanupRefs(); &#125;);</span><br><span class="line">    registerExitCallback([this]() &#123; DPRINTF(DumpCache,&quot;%s&quot;,print()); &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>具体就是在这个函数内会注册退出时的回调函数,只需要将里面函数换为print就行</p>
<h2 id="NUMA"><a href="#NUMA" class="headerlink" title="NUMA"></a>NUMA</h2><p>非统一内存访问架构的特点是：被共享的内存物理上是分布式的，所有这些内存的集合就是全局<a href="https://zh.wikipedia.org/wiki/%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4" title="地址空间">地址空间</a>。所以处理器访问这些内存的时间是不一样的，显然访问本地内存的速度要比访问全局共享内存或远程访问外地内存要快些。另外，NUMA中内存可能是分层的：本地内存，群内共享内存，全局共享内存。</p>
<h2 id="SMT"><a href="#SMT" class="headerlink" title="SMT"></a>SMT</h2><h3 id="1、SMT为什么能提升并行性能（多线程性能）？"><a href="#1、SMT为什么能提升并行性能（多线程性能）？" class="headerlink" title="1、SMT为什么能提升并行性能（多线程性能）？"></a>1、SMT为什么能提升并行性能（多线程性能）？</h3><p>SMT技术虽然是提升多线程下表现的性能，但SMT实际上是提升CPU单核性能大背景下的“副产品”。 一个单核单线程任务，在CPU的视角上，可以被看作是执行一连串连续的指令。比如说是下面这个例子里，假设执行的就是一个包含10个指令的任务：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">任务1 = A1 A2 B1 C1 D1 A3 A4 D2 C2 B2</span><br></pre></td></tr></table></figure>

<p>我们先看最简单的场景，CPU执行这些任务最直接的办法就是一个指令一个指令的执行，假设这些指令的执行周期都是N，那么执行完这些指令，就需要10N个周期。那么CPU的速度就只和CPU的频率相关了，显然这也不符合我们的认知，不同CPU在相同频率下的性能显然不一样。</p>
<p>除了频率以外，要提升CPU的单核性能，第一个常见手段就是尽可能的缩短每个指令执行的周期，不过在我们假设的这个场景中和SMT关系不大，这里就不说了。第二个常见手段就是指令级并行（ILP）。虽然说这个任务1理论上是得一个指令接着一个指令的执行，但实际上这些指令并一定只能这么顺序执行，只要两个指令之间没有相互依赖和冲突，那么就可以并发执行（一起执行），从而缩短总的执行时间。 例如在上面这个例子中，我将指令分组成A B C D四组，组内必须顺序执行，组间的指令完全没有依赖（彼此不依赖对方执行后的数据）和冲突（不共享资源，不是一类操作），那么我们就可以并发执行这些指令。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">任务1A：A1 A2 A3 A4</span><br><span class="line">任务1B：B1 B2</span><br><span class="line">任务1C：C1 C2</span><br><span class="line">任务1D：D1 D2</span><br></pre></td></tr></table></figure>

<p>那么我们还是假设每个任务的执行周期是N，可以看到只要我们按照上述分组执行代码，那么整体的执行时间就只取决于最长的一组任务1A，也就是执行时间可以缩短到4N，速度提升到2.5倍。</p>
<p>显然，如果说要在一个CPU核心里同时执行上述几组任务，那么CPU自然得具备至少4组执行端口，这里我们也简化成PA、PB、PC和PD，分别执行上述的1A 1B 1C 1D。所以现代的CPU要提升单核性能，都会尽可能的把后端的执行端口数目变多，并且尽可能的在单位时间内读入更多指令，从而促进指令间的并发。</p>
<p>但是，实际的任务里，指令之间的依赖冲突关系是错综复杂的，不可能完美的将指令均匀的分组到每一个端口上。 就比如说我们上面这个例子里，在并发执行后虽然时间缩短为了4N个周期，但是实际上只有端口PA是一直在工作的，而PB PC PD都会在中途闲下来。</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/831fed02c2728151044cb76835a8a2ad.png"></p>
<p>以Skylake为例子，后端执行端口EU不只一个</p>
<p>随着单核性能的不断提升，后端执行资源也越来越丰富，这种执行端口闲置的情况就会越来越明显，造成资源浪费。这时候，为了将这些资源物尽其用，同步多线程SMT就应运而生了。SMT的思路是这样的，既然一个任务填不满后端的资源，那么我们就找不只一个任务来填就好了，不同任务之间的相互依赖和冲突情况很低，放到一起来执行正合适去填满后端资源。</p>
<p>我们接着举例子，假设现在有一个新的任务2，同样是10个指令，同样按照端口分组：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">任务2 = B‘1 A’1 B‘2 C’1 C‘2 D&#x27;1 D’2 D‘3 C’3 A‘2</span><br><span class="line">任务2A = A’1 A’2</span><br><span class="line">任务2B = B’1 B’2</span><br><span class="line">任务2C = C’1 C’2 C’3</span><br><span class="line">任务2D = D&#x27;1 D’2 D‘3 </span><br></pre></td></tr></table></figure>

<p>那么在指令级并发的情况下，这个任务的执行时间就是3N。</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/3b51c4b732d0eaf031e5228b3185b2d5.png"></p>
<p>那么如果把任务1和任务2在单核CPU上分别执行，它们的执行时间就是4N+3N&#x3D;7N。这时，如果我们引入SMT技术，虚拟出两个核心来，让他们同样在一个核心内执行，依然使用ABCD来表示互相不冲突的指令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PA：A1 A2 A3 A4 A’1 A’2</span><br><span class="line">PB：B1 B2 B’1 B’2</span><br><span class="line">PC：C1 C2 C’1 C’2 C’3</span><br><span class="line">PD：D1 D2 D&#x27;1 D’2 D‘3 </span><br></pre></td></tr></table></figure>

<p>那么这时候整个执行时间就变成了6N，比起之前的7N又提升16.7%的速度。</p>
<p>前端有两组维护不同任务上下文的单元就可以</p>
]]></content>
      <categories>
        <category>计算机体系结构</category>
      </categories>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2025/02/03/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
<h1 id="今日踩坑"><a href="#今日踩坑" class="headerlink" title="今日踩坑"></a>今日踩坑</h1><p>1.Champsim  最新版本2024-12即使报错也会生成bin文件,这个感觉是他的编译选项问题</p>
<p>2.firesim 在使用au280时,应该使用BaseXilinxAlveoConfig替换PLATFORM_CONFIG&#x3D;BaseXilinxAlveoU280Config,直接加入一個BaseXilinxAlveoU280Config也可以</p>
<h1 id="2025-2-5"><a href="#2025-2-5" class="headerlink" title="2025-2-5"></a>2025-2-5</h1><p>今日发现dcache的写dirty有问题：目前这个写逻辑有问题，只有当写数据，或者写miss才会设定dirty位，读miss读出的数据是不会设置dirty位的，但不影响功能，</p>
<p>而且之后可能会加入mshr合并机制：mshr不合并？</p>
]]></content>
  </entry>
  <entry>
    <title>runahead</title>
    <url>/2025/02/05/runahead/</url>
    <content><![CDATA[<h1 id="runahead"><a href="#runahead" class="headerlink" title="runahead"></a>runahead</h1><p>(又是Onur Mutlu写的文章)</p>
<h2 id="要解决的问题-摘要"><a href="#要解决的问题-摘要" class="headerlink" title="要解决的问题(摘要)"></a>要解决的问题(摘要)</h2><p>现如今高性能处理器都通过OoO来中和一些高延迟操作(如cache miss,中断异常,设备访问),之前做法都是增大指令窗口(个人理解为rob中可存储指令个数),现在可以提前执行,也即是runahead,在相同的机器上,runahead结合128个Instruction Windows与在没有提前执行和384个Instruction Windows相比性能几乎没有差异</p>
<h2 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h2><p>mem access对CPU的性能影响很大,故之前有人提出了cache,no-blocking cache,硬件预取,软件预取,基于线程预取<br>Balasubramonian提出了长延迟指令阻塞退役时执行未来指令的机制。它们的机制动态地将寄存器文件的一部分分配给“未来线程”，该线程在“主线程”停止时启动。这种机制需要对两种不同上下文的部分硬件支持。<br>缺点:两模式都无法全部享用处理器资源<br>在运行提前执行中，普通模式和运行提前模式都可以利用机器的全部资源，这有助于机器在运行提前模式中获得进一步的领先。<br>Lebeck提出，将依赖于长延迟操作的指令从(相对较小的)调度窗口中移除，放入(相对较大的)等待指令缓冲区(WIB)中，直到操作完成，然后将指令移回调度窗口。这结合了大指令窗口的延迟容忍优势和小调度窗口的快速周期时间优势。(类似于超标量发射队列的推测唤醒那一节)</p>
<h2 id="IW和SW-和超标量哪一本的含义不同"><a href="#IW和SW-和超标量哪一本的含义不同" class="headerlink" title="IW和SW(和超标量哪一本的含义不同)"></a>IW和SW(和超标量哪一本的含义不同)</h2><p>An out-of-order execution machine<br>accomplishes this using two windows: the instruction window and the scheduling window.</p>
<p>指令窗口是已经解码的指令但还没退休,也即是在rob的指令,调度窗口是指令窗口的一个子集,其主要作用就是找到可以执行的指令<br><img src="/2025/02/05/runahead/image.png" alt="alt text"><br>可以看到runahead+128表项的IW的停顿百分比与IPC(每个条顶部为IPC),其消除full window<br>stalls获得了20%的IPC提升</p>
<h2 id="runahead-1"><a href="#runahead-1" class="headerlink" title="runahead"></a>runahead</h2><p>CPU任何时候都可以进入runahead,本论文在l2cache miss,并且该内存操作到达指令窗口的头部时(也就是最老的指令)进入提前执行.提前执行时的pc得存起来,以便退出runahead恢复archstate,IW中所有指令都被标记为runahead inst,在这个模式中取到的指令也是No updates to the checkpointed register file are allowed during runahead mode.runahead的执行与内存通信和无效结果的传播有关,一些规则:</p>
<ol>
<li>Invalid bits and instructions.</li>
<li>Propagation of INV values.<br>进入runahead的第一条无效指令为load或者store(引起这个问题的原因),若为load,则rf的INV拉高,若为store,则runahead cache分配一个表项,并且将dest 的byte置为无效Any invalid instruction that writes to a register marks that<br>register as INV after it is scheduled or executed. Any valid<br>operation that writes to a register resets the INV bit ofits<br>destination register.</li>
<li>Runahead store operations and runahead cache.之前的工作runahead load之前有runahead store(raw)被视为无效指令并被删除我们认为转发是必要的,如果两个指令都在IW中,直接通过store buffer获取指令,如果指令伪退休了,<br>我们将其存入runahead cache,其目的是转发数据和状态,被替换的dirty行不会存入下一级存储器,而是会直接删除(正常模式的指令无法访问该cache)store buffer 和runahead cache的每个字节都有对应的INV,而runahead cache 中还有STO为,指示store是否写入该字节,只有访问该cache中的STO和valid 之高的line,才不会miss,规则如下:<ol>
<li>当有效runahead store执行-&gt;拉低cache的INV,若datacache中该数据缺失,则进行预取</li>
<li>当无效runahead store被选中-&gt;将store buffer对应位置拉高INV</li>
<li>当有效runahead store退休,写入cache,重置INV,设置写入字节的STO</li>
<li>当无效的runahead store执行,cache的INV升高,设置STO</li>
<li>runahead store不会将数据写入data cache<br>但store地址无效时,其操作将会被视为NOP,这时与之相关的load可能无法获得正确的值,可以使用memory dependence predictors解决</li>
</ol>
</li>
<li>Runahead load operations.Runahead load操作可能因三种不同原因而无效它可能源于一个 INV 物理寄存器。（寄存器的INV位）它可能依赖于store buffer中标记为 INV 的存储。（store buffer的INV位）它可能依赖于一个已经伪退休的 INV 存储器。（runahead cache的INV位）Runahead load 执行时会<strong>并行</strong>访问data cache,store buffer和runahead cache访问store buffer和runahead cache:只有访问的line的INV置低,(STO置为高),才能获取数据,若无效,则该指令的dst reg 置为INV如果store buffer和runahead cache 都miss,但data cache hit,使用该数据,但实际这时数据可能是无效的-&gt;依赖于之前的store,但之前的store 的line是INV的或者被驱逐出cache(这种很罕见,故不会影响性能),如果三个都miss,则访问l2cache,如果访问l2cache miss,则驱除该指令,然后当作正常模式的指令运行,(个人理解这个可能会形成嵌套runahead)</li>
<li>Execution and prediction of branches.<strong>在runahead模式的分支指令预测失败后不会恢复****训练策略</strong>runahead 时就训练BHT,这样其训练效果好不能再runahead训练BHT,这样可能导致分支预测不太行,导致runahead遇见分支性能下降只能在runahead训练BHT,正常模式通过fifo访问BHT两种模式有不同的表</li>
<li>Instruction pseudo-retirement during runahead mode.<br>runahead模式退休和正常差不多,区别在于:runahead如果检测ROB有inv指令,直接退休,两种模式均会更新RAT</li>
</ol>
<h2 id="Exiting-runahead-mode"><a href="#Exiting-runahead-mode" class="headerlink" title="Exiting runahead mode"></a>Exiting runahead mode</h2><p>退出也是可以随时退出,本文使用和分支预测失误后恢复的方法相似<br>本文使用的是当blocking的数据返回后退出runahead,</p>
<h2 id="一些名词"><a href="#一些名词" class="headerlink" title="一些名词"></a>一些名词</h2><p>BHT,FIFO,ROB,RAT,store buffer</p>
]]></content>
  </entry>
  <entry>
    <title>diplomacy&amp;boom</title>
    <url>/2025/02/05/diplomacy&amp;boom/</url>
    <content><![CDATA[<h1 id="1-官方的adder例子"><a href="#1-官方的adder例子" class="headerlink" title="1. 官方的adder例子"></a>1. 官方的adder例子</h1><p><img src="/2025/02/05/diplomacy&boom/1730820232374.png" alt="1730820232374"></p>
<p><strong>首先定义参数</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">case class UpwardParam(width: Int)</span><br><span class="line">case class DownwardParam(width: Int)</span><br><span class="line">case class EdgeParam(width: Int)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>也即是INT,</p>
<p><strong>之后实现节点</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">object AdderNodeImp extends SimpleNodeImp[DownwardParam, UpwardParam, EdgeParam, UInt] &#123;</span><br><span class="line">  def edge(pd: DownwardParam, pu: UpwardParam, p: Parameters, sourceInfo: SourceInfo) = &#123;</span><br><span class="line">    if (pd.width &lt; pu.width) EdgeParam(pd.width) else EdgeParam(pu.width)</span><br><span class="line">  &#125;</span><br><span class="line">  def bundle(e: EdgeParam) = UInt(e.width.W)</span><br><span class="line">  def render(e: EdgeParam) = RenderedEdge(&quot;blue&quot;, s&quot;width = $&#123;e.width&#125;&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个edge的意思就是去协商向上传的参数与向下传的参数,最终取最小值,然后bundle是根据协商参数创建数据类型,</p>
<p>然后就是节点,节点主要有SourceNode,SinkNode和NexusNode,由于 <code>SourceNode</code>只沿向外边生成向下流动的参数，节点实现和之前一样。对 <code>AdderDriverNode</code>而言，类型为 <code>Seq[DownwardParam]</code>的 <code>widths</code>表示初始化该节点（<code>AdderDriver</code>）的模块时输出的数据宽度，这里使用 <code>Seq</code>是因为每个节点可能驱动多个输出，在这个例子中，每个节点会连接到加法器和monitor。SinkNode同理</p>
<p>最后就是Nexus节点,</p>
<p>加法器节点接收两个 <code>AdderDriverNode</code>的输入，并把输出传递给monitor，该节点为 <code>NexusNode</code>。<code>dFn</code>将向内边传来的向下的参数，映射到向外边的向下的参数，<code>uFn</code>将向外边的向上的参数，映射到向内边的向上的参数。</p>
<p>(内边可以理解为传入的参数,外边可以理解为向外传的参数)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class AdderDriverNode(widths: Seq[DownwardParam])(implicit valName: ValName)</span><br><span class="line">  extends SourceNode(AdderNodeImp)(widths)</span><br><span class="line"></span><br><span class="line">/** node for [[AdderMonitor]] (sink) */</span><br><span class="line">class AdderMonitorNode(width: UpwardParam)(implicit valName: ValName)</span><br><span class="line">  extends SinkNode(AdderNodeImp)(Seq(width))</span><br><span class="line"></span><br><span class="line">/** node for [[Adder]] (nexus) */</span><br><span class="line">class AdderNode(dFn: Seq[DownwardParam] =&gt; DownwardParam,</span><br><span class="line">                uFn: Seq[UpwardParam] =&gt; UpwardParam)(implicit valName: ValName)</span><br><span class="line">  extends NexusNode(AdderNodeImp)(dFn, uFn)</span><br></pre></td></tr></table></figure>

<p>这个里面有两个模板匹配,然后最终传入的AdderNode的值为(dps和ups的head),最后将输入累加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Adder(implicit p: Parameters) extends LazyModule &#123;</span><br><span class="line">  val node = new AdderNode (</span><br><span class="line">    &#123; case dps: Seq[DownwardParam] =&gt;</span><br><span class="line">      require(dps.forall(dp =&gt; dp.width == dps.head.width), &quot;inward, downward adder widths must be equivalent&quot;)</span><br><span class="line">      dps.head</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123; case ups: Seq[UpwardParam] =&gt;</span><br><span class="line">      require(ups.forall(up =&gt; up.width == ups.head.width), &quot;outward, upward adder widths must be equivalent&quot;)</span><br><span class="line">      ups.head</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">  lazy val module = new LazyModuleImp(this) &#123;</span><br><span class="line">    require(node.in.size &gt;= 2)</span><br><span class="line">    node.out.head._1 := node.in.unzip._1.reduce(_ + _)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  override lazy val desiredName = &quot;Adder&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要就是设置numoutputs个驱动节点,然后给每个节点分配随机值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">/** driver (source)</span><br><span class="line">  * drives one random number on multiple outputs */</span><br><span class="line">class AdderDriver(width: Int, numOutputs: Int)(implicit p: Parameters) extends LazyModule &#123;</span><br><span class="line">  val node = new AdderDriverNode(Seq.fill(numOutputs)(DownwardParam(width)))</span><br><span class="line"></span><br><span class="line">  lazy val module = new LazyModuleImp(this) &#123;</span><br><span class="line">    // check that node parameters converge after negotiation</span><br><span class="line">    val negotiatedWidths = node.edges.out.map(_.width)</span><br><span class="line">    require(negotiatedWidths.forall(_ == negotiatedWidths.head), &quot;outputs must all have agreed on same width&quot;)</span><br><span class="line">    val finalWidth = negotiatedWidths.head</span><br><span class="line"></span><br><span class="line">    // generate random addend (notice the use of the negotiated width)</span><br><span class="line">    val randomAddend = FibonacciLFSR.maxPeriod(finalWidth)</span><br><span class="line"></span><br><span class="line">    // drive signals</span><br><span class="line">    node.out.foreach &#123; case (addend, _) =&gt; addend := randomAddend &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  override lazy val desiredName = &quot;AdderDriver&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要就是设置numoperands个监视节点,和一个adder节点,然后对比nodesum节点和nodeseq节点值的区别,送出error</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class AdderMonitor(width: Int, numOperands: Int)(implicit p: Parameters) extends LazyModule &#123;</span><br><span class="line">  val nodeSeq = Seq.fill(numOperands) &#123; new AdderMonitorNode(UpwardParam(width)) &#125;</span><br><span class="line">  val nodeSum = new AdderMonitorNode(UpwardParam(width))</span><br><span class="line"></span><br><span class="line">  lazy val module = new LazyModuleImp(this) &#123;</span><br><span class="line">    val io = IO(new Bundle &#123;</span><br><span class="line">      val error = Output(Bool())</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    // print operation</span><br><span class="line">    printf(nodeSeq.map(node =&gt; p&quot;$&#123;node.in.head._1&#125;&quot;).reduce(_ + p&quot; + &quot; + _) + p&quot; = $&#123;nodeSum.in.head._1&#125;&quot;)</span><br><span class="line"></span><br><span class="line">    // basic correctness checking</span><br><span class="line">    io.error := nodeSum.in.head._1 =/= nodeSeq.map(_.in.head._1).reduce(_ + _)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  override lazy val desiredName = &quot;AdderMonitor&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后就是顶层,顶层就是通过高阶函数将每个节点链接起来</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class AdderTestHarness()(implicit p: Parameters) extends LazyModule &#123;</span><br><span class="line">  val numOperands = 2</span><br><span class="line">  val adder = LazyModule(new Adder)</span><br><span class="line">  // 8 will be the downward-traveling widths from our drivers</span><br><span class="line">  val drivers = Seq.fill(numOperands) &#123; LazyModule(new AdderDriver(width = 8, numOutputs = 2)) &#125;</span><br><span class="line">  // 4 will be the upward-traveling width from our monitor</span><br><span class="line">  val monitor = LazyModule(new AdderMonitor(width = 4, numOperands = numOperands))</span><br><span class="line"></span><br><span class="line">  // create edges via binding operators between nodes in order to define a complete graph</span><br><span class="line">  drivers.foreach&#123; driver =&gt; adder.node := driver.node &#125;</span><br><span class="line"></span><br><span class="line">  drivers.zip(monitor.nodeSeq).foreach &#123; case (driver, monitorNode) =&gt; monitorNode := driver.node &#125;</span><br><span class="line">  monitor.nodeSum := adder.node</span><br><span class="line"></span><br><span class="line">  lazy val module = new LazyModuleImp(this) &#123;</span><br><span class="line">    // when(monitor.module.io.error) &#123;</span><br><span class="line">    //   printf(&quot;something went wrong&quot;)</span><br><span class="line">    // &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  override lazy val desiredName = &quot;AdderTestHarness&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-根据rocketchip-搭建一个简单的SOC框架-基于ysyxSoC"><a href="#2-根据rocketchip-搭建一个简单的SOC框架-基于ysyxSoC" class="headerlink" title="2. 根据rocketchip 搭建一个简单的SOC框架(基于ysyxSoC)"></a>2. 根据rocketchip 搭建一个简单的SOC框架(基于ysyxSoC)</h1><p>首先我们需要包含freechip库,有两种方法,1.直接从云端下载,2.直接导入本地的库,本实验选择第二种,基于ysyxSoC的build.sc来创建自己的sc文件,导入成功后就可以进行自己的SoC搭建</p>
<p>我们的SoC框架如下所示</p>
<p><img src="/2025/02/05/diplomacy&boom/1730881092351.png" alt="1730881092351"></p>
<p>也就是我们CPU需要一个AXI_master节点,clint,SDRAM和MROM各自需要一个AXI_slave节点,然后AXI_XBAR继承于NexusNode,可支持多个输入节点和多个输出节点</p>
<p>然后设备的地址空间安排如下:</p>
<table>
<thead>
<tr>
<th>设备</th>
<th>地址空间</th>
</tr>
</thead>
<tbody><tr>
<td>clint</td>
<td>0x1000_0000-0x1000_ffff</td>
</tr>
<tr>
<td>SDRAM</td>
<td>0x8000_0000-0x9fff_ffff</td>
</tr>
<tr>
<td>MROM</td>
<td>0x2000_0000-0x2000_ffff</td>
</tr>
</tbody></table>
<p>首先创建clint的slave节点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class AXI4MyCLINT(address: Seq[AddressSet])(implicit p: Parameters) extends LazyModule &#123;</span><br><span class="line">  val beatBytes = 4</span><br><span class="line">  val node = AXI4SlaveNode(Seq(AXI4SlavePortParameters(</span><br><span class="line">    Seq(AXI4SlaveParameters(</span><br><span class="line">        address       = address,</span><br><span class="line">        executable    = true,</span><br><span class="line">        supportsWrite = TransferSizes(1, beatBytes),</span><br><span class="line">        supportsRead  = TransferSizes(1, beatBytes),</span><br><span class="line">        interleavedId = Some(0))</span><br><span class="line">    ),</span><br><span class="line">    beatBytes  = beatBytes)))</span><br><span class="line"></span><br><span class="line">  lazy val module = new Impl</span><br><span class="line">  class Impl extends LazyModuleImp(this) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到我们首先创建了slvae节点，这个节点里面有一个TransferSizes，来揭示最多可以传多少笔数据，这里是按照四笔来说的，然后在之后的LazyModuleImp有具体的实现，我们可以根据传入的node的信号的地址来读写相应的寄存器，然后SDRAM和MROM比较类似，以SDRAM为主要讲解</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class AXI4MySDRAM(address: Seq[AddressSet])(implicit p: Parameters) extends LazyModule &#123;</span><br><span class="line">  val beatBytes = 4</span><br><span class="line">  val node = AXI4SlaveNode(Seq(AXI4SlavePortParameters(</span><br><span class="line">    Seq(AXI4SlaveParameters(</span><br><span class="line">        address       = address,</span><br><span class="line">        executable    = true,</span><br><span class="line">        supportsWrite = TransferSizes(1, beatBytes),</span><br><span class="line">        supportsRead  = TransferSizes(1, beatBytes),</span><br><span class="line">        interleavedId = Some(0))</span><br><span class="line">    ),</span><br><span class="line">    beatBytes  = beatBytes)))</span><br><span class="line"></span><br><span class="line">  lazy val module = new Impl</span><br><span class="line">  class Impl extends LazyModuleImp(this) &#123;</span><br><span class="line">    val (in, _) = node.in(0)</span><br><span class="line">    val sdram_bundle = IO(new SDRAMIO)</span><br><span class="line"></span><br><span class="line">    val msdram = Module(new sdram_top_axi)</span><br><span class="line">    msdram.io.clock := clock</span><br><span class="line">    msdram.io.reset := reset.asBool</span><br><span class="line">    msdram.io.in &lt;&gt; in</span><br><span class="line">    sdram_bundle &lt;&gt; msdram.io.sdram</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SDRAM仍然是先创建slave节点，然后LazyModuleImp中将节点连接到msdram的输入端，这个模块是一个黑盒，这地方的好处就是一般sdram和DDR都使用IP,而现在的IP一般都是verilog,所以包裹一层黑盒</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class MySoC(implicit p: Parameters) extends LazyModule &#123;</span><br><span class="line">  val xbar = AXI4Xbar()</span><br><span class="line">  val cpu = LazyModule(new CPU(idBits = ChipLinkParam.idBits))</span><br><span class="line">  val lmrom = LazyModule(new AXI4MROM(AddressSet.misaligned(0x20000000, 0x10000)))</span><br><span class="line">  val lclint = LazyModule(new AXI4MyCLINT(AddressSet.misaligned(0x10000000, 0x10000)))</span><br><span class="line">  val sdramAddressSet = AddressSet.misaligned(0x80000000L, 0x2000000)</span><br><span class="line">  val lsdram_axi = Some(LazyModule(new AXI4MySDRAM(sdramAddressSet))) </span><br><span class="line"></span><br><span class="line">  List(lsdram_axi.get.node ,lmrom.node, lclint.node).map(_ := xbar)</span><br><span class="line">  xbar := cpu.masterNode</span><br><span class="line">  </span><br><span class="line">  override lazy val module = new Impl</span><br><span class="line">  class Impl extends LazyModuleImp(this) with DontTouch &#123;</span><br><span class="line"></span><br><span class="line">    cpu.module.reset := SynchronizerShiftReg(reset.asBool, 10) || reset.asBool</span><br><span class="line">    cpu.module.slave := DontCare</span><br><span class="line">    val intr_from_chipSlave = IO(Input(Bool()))</span><br><span class="line">    cpu.module.interrupt := intr_from_chipSlave</span><br><span class="line">    val sdramBundle = lsdram_axi.get.module.sdram_bundle</span><br><span class="line">    val sdram = IO(chiselTypeOf(sdramBundle))</span><br><span class="line">    sdram &lt;&gt; sdramBundle</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先調用xbar创建XBAR,然后为每个设备分配地址空间,最后连线,也就是将slave node和xbar连线,cpu的master node 和xbar连线,之后就是实现部分,主要也是连线逻辑,然后就结束了整个SOC的创建</p>
<p><img src="/2025/02/05/diplomacy&boom/1730880825683.png" alt="1730880825683"></p>
<p>最后是生成的代码的一部分,可以看到正确链接</p>
<h1 id="3-rocketchip-的AXIDelayer解析"><a href="#3-rocketchip-的AXIDelayer解析" class="headerlink" title="3.rocketchip 的AXIDelayer解析"></a>3.rocketchip 的AXIDelayer解析</h1><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> node = <span class="type">AXI4AdapterNode</span>()</span><br><span class="line">require (<span class="number">0.0</span> &lt;= q &amp;&amp; q &lt; <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>首先可以看到他创建了一个AXI4AdapterNode,这个主要就是master原封不动传进来,slave也是原封不动传进来（只可改变参数，但边不可改变）,然后q就是请求延迟的概率</p>
<p>然后在lazymodule定义了一个feed函数</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">feed</span></span>[<span class="type">T</span> &lt;: <span class="type">Data</span>](sink: <span class="type">IrrevocableIO</span>[<span class="type">T</span>], source: <span class="type">IrrevocableIO</span>[<span class="type">T</span>], noise: <span class="type">T</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">  <span class="comment">// irrevocable requires that we not lower valid</span></span><br><span class="line">  <span class="keyword">val</span> hold = <span class="type">RegInit</span>(<span class="literal">false</span>.<span class="type">B</span>)</span><br><span class="line">  when (sink.valid)  &#123; hold := <span class="literal">true</span>.<span class="type">B</span> &#125;</span><br><span class="line">  when (sink.fire) &#123; hold := <span class="literal">false</span>.<span class="type">B</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> allow = hold || ((q * <span class="number">65535.0</span>).toInt).<span class="type">U</span> &lt;= <span class="type">LFSRNoiseMaker</span>(<span class="number">16</span>, source.valid)</span><br><span class="line">  sink.valid := source.valid &amp;&amp; allow</span><br><span class="line">  source.ready := sink.ready &amp;&amp; allow</span><br><span class="line">  sink.bits := source.bits</span><br><span class="line">  when (!sink.valid) &#123; sink.bits := noise &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数就是通过allow来截断sink和source的vaild和ready信号,allow主要有两个信号,一个是hold,另一个是比较电路,假设我们第一次使用这个,那么hold必然为false,只能通过后面的比较电路来决定allow,如果后面的也为false,则会引入噪音,直到后面条件满足,这时控制信号就会通,但是bits仍然是有噪声的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def anoise[T &lt;: AXI4BundleA](bits: T): Unit = &#123;</span><br><span class="line">  bits.id    := LFSRNoiseMaker(bits.params.idBits)</span><br><span class="line">  bits.addr  := LFSRNoiseMaker(bits.params.addrBits)</span><br><span class="line">  bits.len   := LFSRNoiseMaker(bits.params.lenBits)</span><br><span class="line">  bits.size  := LFSRNoiseMaker(bits.params.sizeBits)</span><br><span class="line">  bits.burst := LFSRNoiseMaker(bits.params.burstBits)</span><br><span class="line">  bits.lock  := LFSRNoiseMaker(bits.params.lockBits)</span><br><span class="line">  bits.cache := LFSRNoiseMaker(bits.params.cacheBits)</span><br><span class="line">  bits.prot  := LFSRNoiseMaker(bits.params.protBits)</span><br><span class="line">  bits.qos   := LFSRNoiseMaker(bits.params.qosBits)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个就是给ar和aw通道加noise</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(node.in zip node.out) foreach &#123; case ((in, edgeIn), (out, edgeOut)) =&gt;</span><br><span class="line">   val arnoise = Wire(new AXI4BundleAR(edgeIn.bundle))</span><br><span class="line">   val awnoise = Wire(new AXI4BundleAW(edgeIn.bundle))</span><br><span class="line">   val wnoise  = Wire(new  AXI4BundleW(edgeIn.bundle))</span><br><span class="line">   val rnoise  = Wire(new  AXI4BundleR(edgeIn.bundle))</span><br><span class="line">   val bnoise  = Wire(new  AXI4BundleB(edgeIn.bundle))</span><br><span class="line"></span><br><span class="line">   arnoise := DontCare</span><br><span class="line">   awnoise := DontCare</span><br><span class="line">   wnoise := DontCare</span><br><span class="line">   rnoise := DontCare</span><br><span class="line">   bnoise := DontCare</span><br><span class="line"></span><br><span class="line">   anoise(arnoise)</span><br><span class="line">   anoise(awnoise)</span><br><span class="line"></span><br><span class="line">   wnoise.data := LFSRNoiseMaker(wnoise.params.dataBits)</span><br><span class="line">   wnoise.strb := LFSRNoiseMaker(wnoise.params.dataBits/8)</span><br><span class="line">   wnoise.last := LFSRNoiseMaker(1)(0)</span><br><span class="line"></span><br><span class="line">   rnoise.id   := LFSRNoiseMaker(rnoise.params.idBits)</span><br><span class="line">   rnoise.data := LFSRNoiseMaker(rnoise.params.dataBits)</span><br><span class="line">   rnoise.resp := LFSRNoiseMaker(rnoise.params.respBits)</span><br><span class="line">   rnoise.last := LFSRNoiseMaker(1)(0)</span><br><span class="line"></span><br><span class="line">   bnoise.id   := LFSRNoiseMaker(bnoise.params.idBits)</span><br><span class="line">   bnoise.resp := LFSRNoiseMaker(bnoise.params.respBits)</span><br><span class="line"></span><br><span class="line">   feed(out.ar, in.ar, arnoise)</span><br><span class="line">   feed(out.aw, in.aw, awnoise)</span><br><span class="line">   feed(out.w,  in.w,   wnoise)</span><br><span class="line">   feed(in.b,   out.b,  bnoise)</span><br><span class="line">   feed(in.r,   out.r,  rnoise)</span><br></pre></td></tr></table></figure>

<p>这一堆主要就是将node in和out的信号和参数分开,然后为w,r,b通道加噪声,最后将这些噪声通过feed传到总线,其实这个模块就是去延迟vaild和ready,在延迟期间bits是noise,在sink为vaild期间就是source的bit</p>
<h1 id="rocket-ICache"><a href="#rocket-ICache" class="headerlink" title="rocket ICache"></a>rocket ICache</h1><p>一个典型的rocket chip结构</p>
<p><img src="/2025/02/05/diplomacy&boom/1731144531780.png" alt="1731144531780"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">val (tl_out, edge_out) = outer.masterNode.out(0)</span><br></pre></td></tr></table></figure>

<p>在看rocket代码中有一个这个语句，masternode的out方法返回了两个变量，一个bundle，另一个是边的参数，这里是outward edge参数</p>
<p>深入挖掘out</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def out: Seq[(BO, EO)] = &#123;</span><br><span class="line">  require(</span><br><span class="line">    instantiated,</span><br><span class="line">    s&quot;$name.out should not be called until after instantiation of its parent LazyModule.module has begun&quot;</span><br><span class="line">  )</span><br><span class="line">  bundleOut.zip(edgesOut)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发现在diplomacy库中的MixedNode（所有节点都继承了这个类）定义了这个out方法，其注释为将outward的边参数和端口gather起来，只能在LazyModuleImp中使用和访问</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abstract class MixedNode[DI, UI, EI, BI &lt;: Data, DO, UO, EO, BO &lt;: Data](</span><br><span class="line">  val inner: InwardNodeImp[DI, UI, EI, BI],</span><br><span class="line">  val outer: OutwardNodeImp[DO, UO, EO, BO]</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>MixedNode是一个抽象类，只能被继承或作为基类，然后接下来讲解他的参数</p>
<p>DI:从上游传入的Downward-flowing parameters，对于一个InwardNode节点，他的参数由OutwardNode觉得，他可以多个源连接到一起，所以参数是Seq类型</p>
<p>UI:向上传的参数，一般为sink的参数，，对于InwardNode，参数由节点自身决定</p>
<p>EI:描述内边连接的参数，通常是根据协议对sink的一系列例化</p>
<p>BI:连接内边的Bundle type，他是这个sink接口的硬件接口代表真实硬件</p>
<p>DO:向外边传的参数，通常是source的参数对于一个OutwardNode，这个参数由自己决定</p>
<p>UO:外边传入的参数，通常是描述sink节点的参数，对于一个OutwardNode 这个由连接的inwardNode决定，由于这个可以被多个sinks连接，所以他是seq的</p>
<p>EO:描述外边的连接，通常是source节点的特殊的参数</p>
<p>BO:输出IO</p>
<p>接下来回归原题,可以看到有一个edge_out,这个变量有很多tilelink的方法,如检查是否是req等,是否含有data,但AXI的edge就没u,</p>
<h1 id="rocket-ALU"><a href="#rocket-ALU" class="headerlink" title="rocket ALU"></a>rocket ALU</h1><p>首先ALU继承于下面的抽象类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abstract class AbstractALU(implicit p: Parameters) extends CoreModule()(p) &#123;</span><br><span class="line">  val io = IO(new Bundle &#123;</span><br><span class="line">    val dw = Input(UInt(SZ_DW.W))</span><br><span class="line">    val fn = Input(UInt(SZ_ALU_FN.W))</span><br><span class="line">    val in2 = Input(UInt(xLen.W))</span><br><span class="line">    val in1 = Input(UInt(xLen.W))</span><br><span class="line">    val out = Output(UInt(xLen.W))</span><br><span class="line">    val adder_out = Output(UInt(xLen.W))</span><br><span class="line">    val cmp_out = Output(Bool())</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先dw的含义就是是32位还是64位</p>
<p>重点讲解一下移位操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SLL, SRL, SRA</span><br><span class="line">val (shamt, shin_r) =</span><br><span class="line">  if (xLen == 32) (io.in2(4,0), io.in1)</span><br><span class="line">  else &#123;</span><br><span class="line">    require(xLen == 64)</span><br><span class="line">    val shin_hi_32 = Fill(32, isSub(io.fn) &amp;&amp; io.in1(31))</span><br><span class="line">    val shin_hi = Mux(io.dw === DW_64, io.in1(63,32), shin_hi_32)</span><br><span class="line">    val shamt = Cat(io.in2(5) &amp; (io.dw === DW_64), io.in2(4,0))</span><br><span class="line">    (shamt, Cat(shin_hi, io.in1(31,0)))</span><br><span class="line">  &#125;</span><br><span class="line">val shin = Mux(shiftReverse(io.fn), Reverse(shin_r), shin_r)</span><br><span class="line">val shout_r = (Cat(isSub(io.fn) &amp; shin(xLen-1), shin).asSInt &gt;&gt; shamt)(xLen-1,0)</span><br><span class="line">val shout_l = Reverse(shout_r)</span><br><span class="line">val shout = Mux(io.fn === FN_SR || io.fn === FN_SRA || io.fn === FN_BEXT, shout_r, 0.U) |</span><br><span class="line">            Mux(io.fn === FN_SL,                                          shout_l, 0.U)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>shamt为移位的位数,我们假设是RV32,shin_r是被移位的数字,shin如果是左移,就将shin_r翻转,如果右移,则不变,shout_r检测是逻辑移位还是算数移位,如果是逻辑移位isSUB为false,也就是最高位符号位为0,,然后转换为有符号数,右移shamt,最后取出低32位,如果是verilog可以设置一个shift_mask(~(32’hffffffff)&gt;&gt;shamt),然后将移位前的符号位和这个mask&amp;,最后或一下移位结果就是算数右移,</p>
<p>为什么逻辑左移可以转换为逻辑右移,将被移位的数字翻转后,最高位变为最低位,我们右移结果,翻转过来就是左移结果</p>
<p>然后就是结果输出模块s</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">val out = MuxLookup(io.fn, shift_logic_cond)(Seq(</span><br><span class="line">  FN_ADD -&gt; io.adder_out,</span><br><span class="line">  FN_SUB -&gt; io.adder_out</span><br><span class="line">) ++ (if (coreParams.useZbb) Seq(</span><br><span class="line">  FN_UNARY -&gt; unary,</span><br><span class="line">  FN_MAX -&gt; maxmin_out,</span><br><span class="line">  FN_MIN -&gt; maxmin_out,</span><br><span class="line">  FN_MAXU -&gt; maxmin_out,</span><br><span class="line">  FN_MINU -&gt; maxmin_out,</span><br><span class="line">  FN_ROL -&gt; rotout,</span><br><span class="line">  FN_ROR -&gt; rotout,</span><br><span class="line">) else Nil))</span><br></pre></td></tr></table></figure>

<p>这个表默认是shift_logic_cond,然后根据FN类型选择(这里还加入了Zbb扩展)</p>
<h1 id="rocket-DecodeLogic"><a href="#rocket-DecodeLogic" class="headerlink" title="rocket DecodeLogic"></a>rocket DecodeLogic</h1><p>首先这个逻辑里面定义了两个方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// TODO This should be a method on BitPat</span><br><span class="line">private def hasDontCare(bp: BitPat): Boolean = bp.mask.bitCount != bp.width</span><br><span class="line">// Pads BitPats that are safe to pad (no don&#x27;t cares), errors otherwise</span><br><span class="line">private def padBP(bp: BitPat, width: Int): BitPat = &#123;</span><br><span class="line">  if (bp.width == width) bp</span><br><span class="line">  else &#123;</span><br><span class="line">    require(!hasDontCare(bp), s&quot;Cannot pad &#x27;$bp&#x27; to &#x27;$width&#x27; bits because it has don&#x27;t cares&quot;)</span><br><span class="line">    val diff = width - bp.width</span><br><span class="line">    require(diff &gt; 0, s&quot;Cannot pad &#x27;$bp&#x27; to &#x27;$width&#x27; because it is already &#x27;$&#123;bp.width&#125;&#x27; bits wide!&quot;)</span><br><span class="line">    BitPat(0.U(diff.W)) ## bp</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中hasDontCare是检查一个Bitpat是否有dontcare位,padBP是将一个bitpat格式的填充到width位</p>
<p>然后定义了好几个apply方法,这里只讲解rocketchip使用的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def apply(addr: UInt, default: Seq[BitPat], mappingIn: Iterable[(BitPat, Seq[BitPat])]): Seq[UInt] = &#123;</span><br><span class="line">    val nElts = default.size</span><br><span class="line">    require(mappingIn.forall(_._2.size == nElts),</span><br><span class="line">      s&quot;All Seq[BitPat] must be of the same length, got $nElts vs. $&#123;mappingIn.find(_._2.size != nElts).get&#125;&quot;</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    val elementsGrouped = mappingIn.map(_._2).transpose</span><br><span class="line">    val elementWidths = elementsGrouped.zip(default).map &#123; case (elts, default) =&gt;</span><br><span class="line">      (default :: elts.toList).map(_.getWidth).max</span><br><span class="line">    &#125;</span><br><span class="line">    val resultWidth = elementWidths.sum</span><br><span class="line"></span><br><span class="line">    val elementIndices = elementWidths.scan(resultWidth - 1) &#123; case (l, r) =&gt; l - r &#125;</span><br><span class="line"></span><br><span class="line">    // All BitPats that correspond to a given element in the result must have the same width in the</span><br><span class="line">    // chisel3 decoder. We will zero pad any BitPats that are too small so long as they dont have</span><br><span class="line">    // any don&#x27;t cares. If there are don&#x27;t cares, it is an error and the user needs to pad the</span><br><span class="line">    // BitPat themselves</span><br><span class="line">    val defaultsPadded = default.zip(elementWidths).map &#123; case (bp, w) =&gt; padBP(bp, w) &#125;</span><br><span class="line">    val mappingInPadded = mappingIn.map &#123; case (in, elts) =&gt;</span><br><span class="line">      in -&gt; elts.zip(elementWidths).map &#123; case (bp, w) =&gt; padBP(bp, w) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    val decoded = apply(addr, defaultsPadded.reduce(_ ## _), mappingInPadded.map &#123; case (in, out) =&gt; (in, out.reduce(_ ## _)) &#125;)</span><br><span class="line"></span><br><span class="line">    elementIndices.zip(elementIndices.tail).map &#123; case (msb, lsb) =&gt; decoded(msb, lsb + 1) &#125;.toList</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到他接受三个参数,返回一个seq,addr是要解码的数据,default是解码list的默认格式,rocket的格式为</p>
<p><img src="/2025/02/05/diplomacy&boom/1731152261040.png" alt="1731152261040"></p>
<p>mappin就是传入的decode表</p>
<p><img src="/2025/02/05/diplomacy&boom/1731152309795.png" alt="1731152309795"></p>
<p>类似于这种</p>
<p>首先我们nElts就是得出这个列表的元素个数,然后一个assert来确保传入的map和default的元素个数一致,然后elementsGrouped将List的各个控制信号分开,这里使用了map(遍历每个元素)和transpose(将元素转置,这样第一个seq就是所有表的val,以此类推),</p>
<p>然后得出每个bitpat的大小,这个elementWidths也就是将default的元素和elementsGrouped配对,然后将default的元素附加到elementsGrouped上,最后算出每个bitpat的大小</p>
<p>resultWidth就是所有bitpat的大小,然后elementIndices就是每个bitpat大小的索引,也就是假如每个bitpat大小为[4,3,2],这个得出的就是[8,4,1,-1]</p>
<p>然后最后哪一行代码就是将上面这个数组转换为(8,5),(4,2),(1,0)在,这样通过decode生成bool信号,然后将这些信号生成list</p>
<p>总体来说,这个模块使用了很多scala的高阶函数:</p>
<p>map:将给定函数作用于每个元素</p>
<p>transpose:将list转置</p>
<p>scan:扫描元组的每个值,并将其进行之后的函数操作,有累积性,比如这里就是给定初值,然后减去其他元素得到新的数组</p>
<p>zip:将两个元素组成一个元组</p>
<p>reduce:将元组的每个元素做相应操作,具有累积性</p>
<p>最后DecodeLogic实现的就是将输入的addr的每部分解码,然后得到解码的信号</p>
<h1 id="PMA（Physical-Memory-Attribute）"><a href="#PMA（Physical-Memory-Attribute）" class="headerlink" title="PMA（Physical Memory Attribute）"></a>PMA（Physical Memory Attribute）</h1><p>PMA是一个SOC系统的固有属性,所以直接将其设为硬件实现,PMA是软件可读的,</p>
<p>在平台支持pma的动态重新配置的地方，将提供一个接口，通过将请求传递给能够正确重新配置平台的机器模式驱动程序来设置属性。</p>
<p>例如，在某些内存区域上切换可缓存性属性可能涉及特定于平台的操作，例如缓存刷新，这些操作仅对机器模式可用。</p>
<h2 id="3-6-1-主内存、I-O和空闲区域"><a href="#3-6-1-主内存、I-O和空闲区域" class="headerlink" title="3.6.1. 主内存、I&#x2F;O和空闲区域"></a>3.6.1. 主内存、I&#x2F;O和空闲区域</h2><p>给定内存地址范围最重要的特征是它是否符合规则内存，或I&#x2F;O设备，或为空闲。常规的主存需要有许多属性，如下所述，而I&#x2F;O设备可以有更广泛的属性范围。不适合常规主存的内存区域，例如设备刮擦板ram，被归类为I&#x2F;O区域。空区域也被归类为I&#x2F;O区域，但具有指定不支持访问的属性。</p>
<h2 id="3-6-2-Supported-Access-Type-PMAs"><a href="#3-6-2-Supported-Access-Type-PMAs" class="headerlink" title="3.6.2. Supported Access Type PMAs"></a>3.6.2. Supported Access Type PMAs</h2><p>访问类型指定支持哪些访问宽度（从8位字节到长多字突发），以及每个访问宽度是否支持不对齐的访问。</p>
<blockquote>
<p>注:虽然在RISC-V hart上运行的软件不能直接生成内存突发，但软件可能必须对DMA引擎进行编程以访问I&#x2F;O设备，因此可能需要知道支持哪种访问大小。</p>
</blockquote>
<p>主存区域始终支持连接设备所需的所有访问宽度的读写，并且可以指定是否支持读指令。</p>
<blockquote>
<p>注:有些平台可能要求所有主存都支持指令读取。其他平台可能会禁止从某些主内存区域获取指令。</p>
</blockquote>
<p>在某些情况下，访问主存的处理器或设备的设计可能支持其他宽度，但必须能够与主存支持的类型一起工作。</p>
<p>I&#x2F;O区域可以指定支持哪些数据宽度的读、写或执行访问组合。</p>
<p>对于具有基于页面的虚拟内存的系统，I&#x2F;O和内存区域可以指定支持哪些硬件页表读和硬件页表写的组合。</p>
<blockquote>
<p>注:类unix操作系统通常要求所有可缓存的主内存都支持PTW。</p>
</blockquote>
<h2 id="3-6-3-Atomicity-PMAs"><a href="#3-6-3-Atomicity-PMAs" class="headerlink" title="3.6.3. Atomicity PMAs"></a>3.6.3. Atomicity PMAs</h2><p>原子性pma描述在此地址区域中支持哪些原子指令。对原子指令的支持分为两类：LR&#x2F;SC和AMOs。有些平台可能要求所有可缓存的主存支持附加处理器所需的所有原子操作。</p>
<p>在AMOs中，有四个级别的支持：AMONone、amosswap、AMOLogical和AMOArithmetic。</p>
<p>AMONone表示不支持AMO操作。AMOSwap表示该地址范围内只支持AMOSwap指令。AMOLogical表示支持交换指令加上所有逻辑AMOs （amoand、amoor、amoxor）。“AMOArithmetic”表示支持所有的RISC-V AMOs。对于每个级别的支持，如果底层内存区域支持该宽度的读写，则支持给定宽度的自然对齐的AMOs。主存和I&#x2F;O区域可能只支持处理器支持的原子操作的一个子集，或者不支持处理器支持的原子操作。</p>
<p><img src="/2025/02/05/diplomacy&boom/1731160758247.png" alt="1731160758247"></p>
<p>对于LR&#x2F;SC，有三个级别的支持表示可保留性和可能性属性的组合：RsrvNone、RsrvNonEventual和RsrvEventual。RsrvNone不支持LR&#x2F;SC操作（位置不可预留）。RsrvNonEventual表示支持这些操作（位置是可保留的），但没有非特权ISA规范中描述的最终成功保证。RsrvEventual表示支持这些操作，并提供最终成功的保证。</p>
<blockquote>
<p>注:我们建议在可能的情况下为主内存区域提供RsrvEventual支持。</p>
<p>大多数I&#x2F;O区域将不支持LR&#x2F;SC访问，因为它们最方便地构建在缓存一致性方案之上，但有些区域可能支持RsrvNonEventual或RsrvEventual。</p>
<p>当LR&#x2F;SC用于标记为RsrvNonEventual的内存位置时，软件应该提供在检测到缺乏进度时使用的替代回退机制。</p>
</blockquote>
<h2 id="3-6-4-Misaligned-Atomicity-Granule-PMA"><a href="#3-6-4-Misaligned-Atomicity-Granule-PMA" class="headerlink" title="3.6.4. Misaligned Atomicity Granule PMA"></a>3.6.4. Misaligned Atomicity Granule PMA</h2><p>Misaligned原子性粒子PMA为失调原子性粒子提供了约束支持。这个PMA（如果存在）指定了不对齐原子颗粒的大小，即自然对齐的2次幂字节数。该PMA的特定支持值由MAGNN表示，例如，MAG16表示不对齐的原子性颗粒至少为16字节。</p>
<p>不对齐的原子性颗粒PMA仅适用于基本isa中定义的AMOs、load和store，以及F、D和Q扩展中定义的不超过MXLEN位的load和store。对于该集中的一条指令，如果所有被访问的字节都位于同一个未对齐的原子颗粒中，则该指令不会因为地址对齐而引发异常，并且该指令将仅出于rvwmo的目的而引发一个内存操作。，它将自动执行。</p>
<p>如果一个未对齐的AMO访问的区域没有指定未对齐的原子性颗粒PMA，或者不是所有访问的字节都位于同一个未对齐的原子性颗粒内，则会引发异常。</p>
<p>对于访问这样一个区域的常规加载和存储，或者并非所有访问的字节都位于同一原子性颗粒内，则会引发异常，或者继续访问，但不保证是原子性的。对于一些不对齐的访问，实现可能会引发访问错误异常，而不是地址不对齐异常，这表明trap处理程序不应该模拟该指令。</p>
<blockquote>
<p>LR&#x2F;SC指令不受此PMA的影响，因此当不对齐时总是引发异常。向量内存访问也不受影响，因此即使包含在未对齐的原子性颗粒中，也可能以非原子方式执行。隐式访问类似</p>
</blockquote>
<h2 id="3-6-5-Memory-Ordering-PMAs"><a href="#3-6-5-Memory-Ordering-PMAs" class="headerlink" title="3.6.5. Memory-Ordering PMAs"></a>3.6.5. Memory-Ordering PMAs</h2><p>为了按照FENCE指令和原子指令排序位进行排序，地址空间的区域被分类为主存或I&#x2F;O。</p>
<p>一个hart对主存区域的访问不仅可以被其他hart观察到，还可以被其他能够在主存系统中发起请求的设备（例如，DMA引擎）观察到。</p>
<p>coherence主存区域总是具有RVWMO或RVTSO内存模型。</p>
<p>非coherence的主存区域有一个实现定义的内存模型。</p>
<p>一个hart对一个I&#x2F;O区域的访问不仅可以被其他hart和总线控制设备观察到，而且可以被目标I&#x2F;O设备观察到，并且I&#x2F;O区域可以以宽松或强顺序访问。其他hart和总线主控设备通常以类似于RVWMO内存区域访问顺序的方式来观察对具有宽松顺序的I&#x2F;O区域的访问，如本规范第1卷a .4.2节所讨论的那样。相比之下，对具有强顺序的I&#x2F;O区域的访问通常由其他hart和总线控制设备按照程序顺序观察。</p>
<p>每个强有序I&#x2F;O区域指定一个编号的排序通道，这是一种在不同I&#x2F;O区域之间提供排序保证的机制。通道0仅用于表示点对点强排序，其中只有hart对单个关联I&#x2F;O区域的访问是强排序的。</p>
<p>通道1用于跨所有I&#x2F;O区域提供全局强排序。hart对与通道1相关联的任何I&#x2F;O区域的任何访问只能被所有其他hart和I&#x2F;O设备观察到以程序顺序发生，包括相对于hart对宽松I&#x2F;O区域或具有不同通道号的强顺序I&#x2F;O区域的访问。换句话说，对通道1中的区域的任何访问都相当于在该指令之前和之后执行一个栅栏io，io指令。</p>
<p>其他更大的通道号为通过该通道号跨具有相同通道号的任何区域的访问提供程序排序。</p>
<p>系统可能支持在每个内存区域上动态配置排序属性。</p>
<p>强排序可用于改进与遗留设备驱动程序代码的兼容性，或者在已知实现不会重新排序访问时，与插入显式排序指令相比，可以提高性能。</p>
<p>本地强排序（通道0）是强排序的默认形式，因为如果hart和I&#x2F;O设备之间只有一条有序通信路径，则通常可以直接提供它。</p>
<p>通常，如果不同的强排序I&#x2F;O区域共享相同的互连路径并且路径不重新排序请求，则它们可以共享相同的排序通道，而无需额外的排序硬件</p>
<h2 id="3-6-6-Coherence-and-Cacheability-PMAs"><a href="#3-6-6-Coherence-and-Cacheability-PMAs" class="headerlink" title="3.6.6. Coherence and Cacheability PMAs"></a>3.6.6. Coherence and Cacheability PMAs</h2><p>内存区域的可缓存性不应该影响该区域的软件视图，除非在其他pma中反映出差异，例如主存与I&#x2F;O分类、内存排序、支持的访问和原子操作以及一致性。出于这个原因，我们将<strong>可缓存性</strong>视为仅由机器模式软件管理的平台级设置。</p>
<p>如果平台支持内存区域的可配置缓存设置，则特定于平台的机器模式例程将在必要时更改设置并刷新缓存，因此系统仅在可缓存设置之间的转换期间不一致。较低的特权级别不应该看到这个临时状态</p>
<p>一致性很容易提供一个共享内存区域，它不被任何代理缓存。这样一个区域的PMA将简单地表示它不应该缓存在私有或共享缓存中。</p>
<p>对于只读区域，一致性也很简单，可以由多个代理安全地缓存，而不需要缓存一致性方案。该区域的PMA将表明它可以被缓存，但不支持写操作。</p>
<p>一些读写区域可能只由单个代理访问，在这种情况下，它们可以由该代理私下缓存，而不需要一致性方案。这些区域的PMA将表明它们可以被缓存。数据也可以缓存在共享缓存中，因为其他代理不应该访问该区域。</p>
<p>如果代理可以缓存其他代理可以访问的读写区域，无论是缓存还是非缓存，都需要缓存一致性方案来避免使用过时的值。</p>
<p>在缺乏硬件缓存一致性的区域（硬件非一致性区域），缓存一致性可以完全在软件中实现，但众所周知，软件一致性方案难以正确实现，并且由于需要保守的软件定向缓存刷新，通常会对性能产生严重影响。硬件缓存一致性方案需要更复杂的硬件，并且由于缓存一致性探测可能会影响性能，但对软件来说是不可见的。</p>
<p>对于每个硬件缓存相干区域，PMA将指示该区域是相干的，如果系统有多个相干控制器，则指示使用哪个硬件相干控制器。对于某些系统，一致性控制器可能是一个外部共享缓存，它本身可以分层访问其他外部缓存一致性控制器。</p>
<p>平台中的大多数内存区域将与软件一致，因为它们将被固定为非缓存、只读、硬件缓存一致或仅由一个代理访问。</p>
<p>如果PMA表示不可缓存，那么对该区域的访问必须由内存本身满足，而不是由任何缓存满足。</p>
<p>对于具有可缓存性控制机制的实现，可能会出现程序无法访问当前驻留在缓存中的内存位置的情况。在这种情况下，必须忽略缓存的副本。防止这种约束是必要的去阻止高特权模式的推测缓存重新填充不会影响较少特权模式的不可缓存访问行为。</p>
<h2 id="3-6-7-Idempotency-PMAs"><a href="#3-6-7-Idempotency-PMAs" class="headerlink" title="3.6.7. Idempotency PMAs"></a>3.6.7. Idempotency PMAs</h2><p>幂等pma描述对地址区域的读写是否幂等。假定主存储器区域是幂等的。对于I&#x2F;O区域，读和写的幂等性可以分别指定（例如，读是幂等的，而写不是）。如果访问是非幂等的，即对任何读或写访问都有潜在的副作用，则必须避免推测性访问或冗余访问。</p>
<p>为了定义幂等pma，冗余访问对观察到的内存顺序的改变不被认为是副作用。</p>
<p>虽然硬件应始终设计为避免对标记为非幂等的内存区域进行投机或冗余访问，但也有必要确保软件或编译器优化不会生成对非幂等内存区域的虚假访问。</p>
<p>非幂等区域可能不支持不对齐访问。对这些区域的不对齐访问应该引发访问错误异常，而不是地址不对齐异常，这表明软件不应该使用多个较小的访问来模拟不对齐的访问，这可能会导致意想不到的副作用。</p>
<p>对于非幂等区域，隐式读写不能提前或推测地执行，除了以下例外情况。当执行非推测式隐式读操作时，允许实现在包含非推测式隐式读操作地址的自然对齐的2次幂区域内额外读取任何字节。此外，当执行非推测指令获取时，允许实现额外读取下一个自然对齐的相同大小的2次幂区域内的任何字节（该区域的地址取2XLEN模）。这些额外读取的结果可用于满足后续的早期或推测式隐式读取。这些自然对齐的2次幂区域的大小是由实现定义的，但是，对于具有基于页面的虚拟内存的系统，不能超过所支持的最小页面大小</p>
<p>译者注:这里描述的应该跟预取有关,允许预取特定字节的数据,地址得2的幂次对齐</p>
<h1 id="3-7-Physical-Memory-Protection"><a href="#3-7-Physical-Memory-Protection" class="headerlink" title="3.7. Physical Memory Protection"></a>3.7. Physical Memory Protection</h1><p>为了支持安全处理和包含错误，需要限制运行在硬件上的软件可访问的物理地址。一个可选的物理内存保护（PMP）单元提供每台机器模式控制寄存器，允许为每个物理内存区域指定物理内存访问特权（读、写、执行）。PMP值与第3.6节中描述的PMA检查并行检查。</p>
<p>PMP访问控制设置的粒度是特定于平台的，但是标准PMP编码支持小至4字节的区域。某些区域的特权可以是硬连接的，例如，某些区域可能只在机器模式下可见，而在低特权层中不可见。</p>
<p>PMP检查区域:PMP检查应用于有效特权模式为访问S和U模式的指令读取和数据访问,</p>
<p>当mstatus中的MPRV位被设置，并且mstatus中的MPP字段包含S或u时，m模式下的数据访问也被应用于虚拟地址转换的页表访问，其有效特权模式为S。可选地，PMP检查还可以应用于m模式访问，在这种情况下，PMP寄存器本身被锁定，因此即使m模式软件也不能更改它们，直到hart被重置。实际上，PMP可以授予S和U模式权限（默认情况下没有），还可以从Mmode撤销权限（默认情况下具有完全权限）。</p>
<p>PMP违规总是被捕捉到精确异常</p>
<h2 id="3-7-1-Physical-Memory-Protection-CSRs"><a href="#3-7-1-Physical-Memory-Protection-CSRs" class="headerlink" title="3.7.1. Physical Memory Protection CSRs"></a>3.7.1. Physical Memory Protection CSRs</h2><p>PMP表项由一个8位配置寄存器和一个mxlen位地址寄存器描述。</p>
<p>一些PMP设置还使用与前一个PMP项相关联的地址寄存器。最多支持64个PMP表项。实现可以实现0、16或64个PMP表项；编号最少的PMP表项必须首先实现。所有PMP CSR字段都是WARL，可以是只读零。PMP csr仅在m模式下可访问。</p>
<p>PMP配置寄存器被密集地打包到csr中，以最小化上下文切换时间。对于RV32, 16个csr， pmpcfg0-pmpcfg15，为64个PMP条目保留配置pmp0cfg-pmp63cfg，如图30所示。对于RV64, 8个偶数csr pmpcfg0、pmpcfg2、…、pmpcfg14保存64个PMP条目的配置，如图31所示。对于RV64，奇数配置寄存器pmpcfg1， pmpcfg3，…，pmpcfg15是非法的。</p>
<p>PMP地址寄存器是命名为pmpaddr0-pmpaddr63的csr。每个PMP地址寄存器为RV32编码34位物理地址的第33-2位，如图32所示。对于RV64，每个PMP地址寄存器编码56位物理地址的第55-2位，如图33所示。并非所有的物理地址位都可以实现，因此pmpaddr寄存器是WARL</p>
<blockquote>
<p>注:章节10.3中描述的基于Sv32页面的虚拟内存方案支持RV32的34位物理地址，因此PMP方案必须支持RV32的大于XLEN的地址。第10.4节和10.5节中描述的Sv39和Sv48基于页面的虚拟内存方案支持56位物理地址空间，因此RV64 PMP地址寄存器施加了相同的限制。</p>
</blockquote>
<p><img src="/2025/02/05/diplomacy&boom/1731164360120.png" alt="1731164360120"></p>
<p><img src="/2025/02/05/diplomacy&boom/1731164379398.png" alt="1731164379398"></p>
<p>图34显示了PMP配置寄存器的布局。设置R、W和X位时，分别表示PMP项允许读、写和指令执行。当这些位中的一个被清除时，对应的访问类型被拒绝。R、W和X字段形成一个集合的WARL字段，其中保留R&#x3D;0和W&#x3D;1的组合。剩下的两个字段A和L将在下面的部分中描述。</p>
<p>尝试从不具有执行权限的PMP区域获取指令将引发指令访问错误异常。试图执行在没有读权限的情况下访问PMP区域内物理地址的加载或负载保留指令会引发加载访问错误异常。试图执行在没有写权限的情况下访问PMP区域内物理地址的存储、存储条件或AMO指令，将引发存储访问错误异常。</p>
<h3 id="3-7-1-1-Address-Matching"><a href="#3-7-1-1-Address-Matching" class="headerlink" title="3.7.1.1. Address Matching"></a>3.7.1.1. Address Matching</h3><p>PMP表项配置寄存器中的A字段编码了相关联的PMP地址寄存器的地址匹配模式。这个字段的编码如表18所示。当A&#x3D;0时，该PMP表项被禁用并且不匹配任何地址。支持另外两种地址匹配模式：自然对齐的2次幂区域（NAPOT），包括自然对齐的四字节区域（NA4）的特殊情况；以及任意范围的上边界（TOR）。这些模式支持四字节粒度</p>
<p><img src="/2025/02/05/diplomacy&boom/1731164814689.png" alt="1731164814689"></p>
<p>NAPOT范围使用相关地址寄存器的低阶位来编码范围的大小，如表19所示。检测连续1的数目</p>
<ul>
<li>若 <code>pmpaddr</code>值为 <code>yyyy...yy01</code>，即连续1的个数为1，则该PMP entry所控制的地址空间为从 <code>yyyy...yy00</code>开始的16个字节</li>
</ul>
<p><img src="/2025/02/05/diplomacy&boom/1731164947670.png" alt="1731164947670"></p>
<p>如果选择TOR，则关联的地址寄存器为地址范围的顶部，前面的PMP地址寄存器为地址范围的底部。如果PMP表项i的A字段设置为TOR，则该表项匹配任何地址y，使pmpaddri-1≤y&lt;pmpaddri（与pmpcfgi-1的值无关）。如果PMP条目0的A字段设置为TOR，则使用0作为下界，因此它匹配任何地址y&lt;pmpaddr0。</p>
<p>如果pmpaddri-1≥pmpaddri和pmpcfgi。A&#x3D;TOR，则PMP表项i不匹配任何地址。</p>
<p>软件可以通过将0写入pmp0cfg，然后将所有1写入pmpaddr0，然后回读pmpaddr0来确定PMP粒度。如果G是最低有效位集的索引，则PMP粒度为2G+2字节。(NAPOT)</p>
<blockquote>
<p>注意:这里的G是0在paddr的位置</p>
</blockquote>
<p>如果当前的XLEN大于MXLEN，为了地址匹配的目的，PMP地址寄存器从MXLEN到XLEN位进行零扩展。</p>
<h3 id="3-7-1-2-Locking-and-Privilege-Mode"><a href="#3-7-1-2-Locking-and-Privilege-Mode" class="headerlink" title="3.7.1.2. Locking and Privilege Mode"></a>3.7.1.2. Locking and Privilege Mode</h3><p>L位表示PMP表项被锁定。锁定的PMP表项一直处于锁定状态，直到hart被重置。如果PMP表项i被锁定，对pmppfg和pmpaddri的写入将被忽略。此外，如果PMP表项i被锁定并且PMP icfgA被设置为TOR，对pmpadri -1的写入将被忽略。</p>
<p>设置L位锁定PMP表项，即使A字段被设置为OFF。</p>
<p>除了锁定PMP表项外，L位表示是否对m模式访问强制R&#x2F;W&#x2F;X权限。当设置L位时，这些权限对所有特权模式强制执行。</p>
<p>当L位清除时，任何匹配PMP表项的m模式访问都将成功；R&#x2F;W&#x2F;X权限只适用于S模式和U模式。</p>
<h3 id="3-7-1-3-Priority-and-Matching-Logic"><a href="#3-7-1-3-Priority-and-Matching-Logic" class="headerlink" title="3.7.1.3. Priority and Matching Logic"></a>3.7.1.3. Priority and Matching Logic</h3><p>PMP表项的优先级是静态的。与访问的任何字节匹配的编号最低的PMP表项决定该访问是成功还是失败。匹配的PMP表项必须匹配访问的所有字节，否则访问失败，无论L、R、W和X位如何。例如，如果将PMP表项配置为匹配4字节范围0xC-0xF，那么假设PMP表项是匹配这些地址的最高优先级表项，那么对0x8-0xF范围的8字节访问将失败。</p>
<p>如果一个PMP表项匹配一次访问的所有字节，那么L、R、W和X位决定这次访问是成功还是失败。如果L位为空，且访问的特权模式为M，则表示访问成功。否则，如果设置了L位或访问的特权模式为S或U，则只有设置了与访问类型对应的R、W或X位，才能访问成功。</p>
<p>如果没有匹配m模式访问的PMP表项，则访问成功。如果没有匹配s模式或u模式访问的PMP表项，但至少实现了一个PMP表项，则访问失败。如果至少实现了一个PMP表项，但是所有PMP表项的A字段都被设置为OFF，那么所有s模式和u模式内存访问都将失败。</p>
<p>访问失败会产生指令、加载或存储访问错误异常。请注意，一条指令可能产生多个访问，这些访问可能不是相互原子的。如果一条指令产生的至少一次访问失败，则会产生访问错误异常，尽管该指令产生的其他访问可能会成功，但会产生明显的副作用。值得注意的是，引用虚拟内存的指令被分解为多个访问。</p>
<p>在某些实现中，不对齐的加载、存储和指令提取也可以分解为多个访问，其中一些访问可能在访问错误异常发生之前成功。特别是，通过PMP检查的未对齐存储的一部分可能变得可见，即使另一部分未通过PMP检查。即使存储地址是自然对齐的，同样的行为也可能出现在大于XLEN位的存储中（例如，RV32D中的FSD指令）。</p>
<h2 id="3-7-2-Physical-Memory-Protection-and-Paging"><a href="#3-7-2-Physical-Memory-Protection-and-Paging" class="headerlink" title="3.7.2. Physical Memory Protection and Paging"></a>3.7.2. Physical Memory Protection and Paging</h2><p>物理内存保护机制被设计成与第10章中描述的基于页面的虚拟内存系统相结合。当启用分页时，访问虚拟内存的指令可能导致多次物理内存访问，包括对页表的隐式引用。<strong>PMP检查应用于所有这些访问</strong>。隐式可分页访问的有效特权模式是S。</p>
<p>使用虚拟内存的实现被允许在显式内存访问要求之前推测性地执行地址转换，并被允许将它们缓存在地址转换缓存结构中——包括可能缓存在Bare转换模式和m模式中使用的从有效地址到物理地址的身份映射。结果物理地址的PMP设置可以在地址转换和显式内存访问之间的任何点进行检查（并可能进行缓存）。因此，当修改PMP设置时，m模式软件必须将PMP设置与虚拟内存系统以及任何PMP或地址转换缓存同步。这是通过执行一个SFENCE来完成的。在PMP csr写入后，rs1&#x3D;x0和rs2&#x3D;x0的VMA指令。实现虚拟化管理程序扩展时的其他同步要求，请参见18.5.3节。</p>
<p>如果没有实现基于页面的虚拟内存，内存访问将同步检查PMP设置，因此没有SFENCE.VMA是必需的。</p>
<h1 id="BOOM-IFU"><a href="#BOOM-IFU" class="headerlink" title="BOOM IFU"></a>BOOM IFU</h1><p><img src="/2025/02/05/diplomacy&boom/1731995196160.png" alt="1731995196160"></p>
<p>前端将从ICache读出的数据写入fetch buf</p>
<h2 id="BOOM-Front-end"><a href="#BOOM-Front-end" class="headerlink" title="BOOM Front end"></a>BOOM Front end</h2><p>前端为5个阶段,f0产生pc,f1进行TLB转换,F2读出数据送入IMem,F3对指令预解码,检查分支预测,(f1,f2,f3每个阶段都可以产生重定向,),然后将指令送入Fetch buffer,将分支预测信息送入FTQ</p>
<h3 id="F0"><a href="#F0" class="headerlink" title="F0"></a>F0</h3><p>这个阶段选择pc,并且向icache和bpd发送请求</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">when (RegNext(reset.asBool) &amp;&amp; !reset.asBool) &#123;</span><br><span class="line">  s0_valid   := true.B</span><br><span class="line">  s0_vpc     := io_reset_vector</span><br><span class="line">  s0_ghist   := (0.U).asTypeOf(new GlobalHistory)</span><br><span class="line">  s0_tsrc    := BSRC_C</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">icache.io.req.valid     := s0_valid</span><br><span class="line">icache.io.req.bits.addr := s0_vpc</span><br><span class="line"></span><br><span class="line">bpd.io.f0_req.valid      := s0_valid</span><br><span class="line">bpd.io.f0_req.bits.pc    := s0_vpc</span><br><span class="line">bpd.io.f0_req.bits.ghist := s0_ghist</span><br></pre></td></tr></table></figure>

<p>s0的信号来自于其他阶段,这个是f1阶段的信号,如果f1有效,并且没有tlb_miss,就把f1的预测结果送入f0,然后标记结果来自BSRC_1,也就是ubtb,然后把f1的ghist送入f0,</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">when (s1_valid &amp;&amp; !s1_tlb_miss) &#123;</span><br><span class="line">  // Stop fetching on fault</span><br><span class="line">  s0_valid     := !(s1_tlb_resp.ae.inst || s1_tlb_resp.pf.inst)</span><br><span class="line">  s0_tsrc      := BSRC_1</span><br><span class="line">  s0_vpc       := f1_predicted_target</span><br><span class="line">  s0_ghist     := f1_predicted_ghist</span><br><span class="line">  s0_is_replay := false.B</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>f2阶段送入的信号分以下情况</p>
<ul>
<li>如果s2阶段有效,并且icache无回应,或者icache有回应但f3阶段没有准备好接受,此时需要进行重定向,重新发送指令请求,然后清除f1阶段,</li>
<li>如果s2阶段有效且f3准备好接受:1. 如果f2阶段预测的和f1的pc一样,就更新f2阶段的ghist,表示预测正确,2.如果f2的预测结果和f1不一样,或者f1本身就是无效的,就清除f1阶段,并且将pc重定向为预测器的pc,将s0的预测结果设置为BSRC_2</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">when ((s2_valid &amp;&amp; !icache.io.resp.valid) ||</span><br><span class="line">      (s2_valid &amp;&amp; icache.io.resp.valid &amp;&amp; !f3_ready)) &#123;</span><br><span class="line">  s0_valid := (!s2_tlb_resp.ae.inst &amp;&amp; !s2_tlb_resp.pf.inst) || s2_is_replay || s2_tlb_miss</span><br><span class="line">  s0_vpc   := s2_vpc</span><br><span class="line">  s0_is_replay := s2_valid &amp;&amp; icache.io.resp.valid</span><br><span class="line">  // When this is not a replay (it queried the BPDs, we should use f3 resp in the replaying s1)</span><br><span class="line">  s0_s1_use_f3_bpd_resp := !s2_is_replay</span><br><span class="line">  s0_ghist := s2_ghist</span><br><span class="line">  s0_tsrc  := s2_tsrc</span><br><span class="line">  f1_clear := true.B</span><br><span class="line">&#125; .elsewhen (s2_valid &amp;&amp; f3_ready) &#123;</span><br><span class="line">  when (s1_valid &amp;&amp; s1_vpc === f2_predicted_target &amp;&amp; !f2_correct_f1_ghist) &#123;</span><br><span class="line">    // We trust our prediction of what the global history for the next branch should be</span><br><span class="line">    s2_ghist := f2_predicted_ghist</span><br><span class="line">  &#125;</span><br><span class="line">  when ((s1_valid &amp;&amp; (s1_vpc =/= f2_predicted_target || f2_correct_f1_ghist)) || !s1_valid) &#123;</span><br><span class="line">    f1_clear := true.B</span><br><span class="line"></span><br><span class="line">    s0_valid     := !((s2_tlb_resp.ae.inst || s2_tlb_resp.pf.inst) &amp;&amp; !s2_is_replay)</span><br><span class="line">    s0_vpc       := f2_predicted_target</span><br><span class="line">    s0_is_replay := false.B</span><br><span class="line">    s0_ghist     := f2_predicted_ghist</span><br><span class="line">    s2_fsrc      := BSRC_2</span><br><span class="line">    s0_tsrc      := BSRC_2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">s0_replay_bpd_resp := f2_bpd_resp</span><br><span class="line">s0_replay_resp := s2_tlb_resp</span><br><span class="line">s0_replay_ppc  := s2_ppc</span><br></pre></td></tr></table></figure>

<p>如果f3阶段的信号有效,f3重定向有以下情况</p>
<ul>
<li>如果f2阶段信号有效,但f2的pc不为f3的预测pc,或者f2的ghist和f3不一样</li>
<li>如果f2阶段无效,f1阶段有效,但f1的pc不为f3的预测pc,或者f1的ghist和f3不一样</li>
<li>如果f1,f2均无效</li>
</ul>
<p>此时,需要清除f2和f1阶段,然后将s0的pc设置为f3预测的pc</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.elsewhen (( s2_valid &amp;&amp;  (s2_vpc =/= f3_predicted_target || f3_correct_f2_ghist)) ||</span><br><span class="line">          (!s2_valid &amp;&amp;  s1_valid &amp;&amp; (s1_vpc =/= f3_predicted_target || f3_correct_f1_ghist)) ||</span><br><span class="line">          (!s2_valid &amp;&amp; !s1_valid)) &#123;</span><br><span class="line">      f2_clear := true.B</span><br><span class="line">      f1_clear := true.B</span><br><span class="line"></span><br><span class="line">      s0_valid     := !(f3_fetch_bundle.xcpt_pf_if || f3_fetch_bundle.xcpt_ae_if)</span><br><span class="line">      s0_vpc       := f3_predicted_target</span><br><span class="line">      s0_is_replay := false.B</span><br><span class="line">      s0_ghist     := f3_predicted_ghist</span><br><span class="line">      s0_tsrc      := BSRC_3</span><br><span class="line"></span><br><span class="line">      f3_fetch_bundle.fsrc := BSRC_3</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>最后就是后端传来信号</p>
<ul>
<li>如果执行了sfence,需要冲刷整个前端,将指令设置为sfence的pc</li>
<li>如果后端发来重定向,冲刷整个前端,将pc设置为重定向pc</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">when (io.cpu.sfence.valid) &#123;</span><br><span class="line">  fb.io.clear := true.B</span><br><span class="line">  f4_clear    := true.B</span><br><span class="line">  f3_clear    := true.B</span><br><span class="line">  f2_clear    := true.B</span><br><span class="line">  f1_clear    := true.B</span><br><span class="line"></span><br><span class="line">  s0_valid     := false.B</span><br><span class="line">  s0_vpc       := io.cpu.sfence.bits.addr</span><br><span class="line">  s0_is_replay := false.B</span><br><span class="line">  s0_is_sfence := true.B</span><br><span class="line"></span><br><span class="line">&#125;.elsewhen (io.cpu.redirect_flush) &#123;</span><br><span class="line">  fb.io.clear := true.B</span><br><span class="line">  f4_clear    := true.B</span><br><span class="line">  f3_clear    := true.B</span><br><span class="line">  f2_clear    := true.B</span><br><span class="line">  f1_clear    := true.B</span><br><span class="line"></span><br><span class="line">  f3_prev_is_half := false.B</span><br><span class="line"></span><br><span class="line">  s0_valid     := io.cpu.redirect_val</span><br><span class="line">  s0_vpc       := io.cpu.redirect_pc</span><br><span class="line">  s0_ghist     := io.cpu.redirect_ghist</span><br><span class="line">  s0_tsrc      := BSRC_C</span><br><span class="line">  s0_is_replay := false.B</span><br><span class="line"></span><br><span class="line">  ftq.io.redirect.valid := io.cpu.redirect_val</span><br><span class="line">  ftq.io.redirect.bits  := io.cpu.redirect_ftq_idx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<p>pc重定向</p>
<p>1、当执行SFENCE.VMA指令时，代表软件可能已经修改了页表，因此此时的TLB里的内容可能是错误的，那么此时正在流水线中执行的指令也有可能是错误的，因此需要刷新TLB和冲刷流水线，也需要重新进行地址翻译和取指，所以此时需要重定向PC值。</p>
<p>2、当执行级发现分支预测失败、后续流水线发生异常或者发生Memory Ordering Failure时（Memory Ordering Failure的相关介绍见参考资料[1])，需要冲刷流水线，将处理器恢复到错误执行前的状态，指令也需要重新进行取指，所以此时也需要重定向PC值。</p>
<p>3、当发生以下三种情况时，需要将PC重定向为F3阶段分支预测器预测的目标跳转地址：</p>
<p>F2阶段的指令有效且F3阶段的分支预测结果与此时处于F2阶段的指令的PC值不相同；</p>
<p>F2阶段的指令无效且F3阶段的分支预测结果与此时处于F1阶段的指令的PC值不相同；</p>
<p>F2阶段和F1阶段的指令均无效。</p>
<p>4、当Icache的响应无效或者F3阶段传来的握手信号没有准备就绪时，需要将PC值重定向为此时处于F2阶段的指令的PC值。</p>
<p>5、当F1阶段的指令有效且F2阶段的分支预测结果与此时处于F1阶段的指令的PC值不相同或者F1阶段的指令无效时，需要将PC重定向为F2阶段分支预测器预测的目标跳转地址。</p>
<p>6、当TLB没有发生miss且F1阶段的分支预测器预测结果为跳转时，需要将PC重定向为预测的目标跳转地址。</p>
<h3 id="F1"><a href="#F1" class="headerlink" title="F1"></a>F1</h3><p>F1阶段进行tlb转换,并且得出ubtb结果,如果tlb miss需要终止icache访存,这个周期ubtb给出预测结果,根据结果对前端重定向</p>
<h4 id="TLB访问逻辑"><a href="#TLB访问逻辑" class="headerlink" title="TLB访问逻辑"></a>TLB访问逻辑</h4><p>如下面代码,s1_resp的结果来自两部分,如果s1有replay信号,那么结果就是replay的数据(只有f2才会发出replay表示指令准备好了但不能接受),否则就是tlb得出的数据</p>
<blockquote>
<p>个人感觉这里是降低功耗的一个小方法,如果f2replay,那么他的物理地址一定计算完了,我们就可以减少一次tlb访问</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tlb.io.req.valid      := (s1_valid &amp;&amp; !s1_is_replay &amp;&amp; !f1_clear) || s1_is_sfence</span><br><span class="line">...</span><br><span class="line">  val s1_tlb_miss = !s1_is_replay &amp;&amp; tlb.io.resp.miss</span><br><span class="line">  val s1_tlb_resp = Mux(s1_is_replay, RegNext(s0_replay_resp), tlb.io.resp)</span><br><span class="line">  val s1_ppc  = Mux(s1_is_replay, RegNext(s0_replay_ppc), tlb.io.resp.paddr)</span><br><span class="line">  val s1_bpd_resp = bpd.io.resp.f1</span><br><span class="line"></span><br><span class="line">  icache.io.s1_paddr := s1_ppc</span><br><span class="line">  icache.io.s1_kill  := tlb.io.resp.miss || f1_clear</span><br></pre></td></tr></table></figure>

<h4 id="分支信息处理逻辑"><a href="#分支信息处理逻辑" class="headerlink" title="分支信息处理逻辑"></a>分支信息处理逻辑</h4><p>f1阶段得出的分支预测结果可能有多个,我们取最旧的一个作为分支目标地址,然后更新ghist(GHR)</p>
<blockquote>
<p>如何选出最旧的分支呢？这里的做法是首先通过fetchMask得到一个指令包的有效指令位置，然后通过通过查询每个指令是否是分支指令并且taken，生成一个新的f1_redirects，然后通过优先编码器得到最旧指令的idx，之后从bpd的resp取出这个idx对应预测结果，如果确实有分支进行预测，就置target为预测的target，否则为pc+4（or 2）</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">val f1_mask = fetchMask(s1_vpc)</span><br><span class="line">val f1_redirects = (0 until fetchWidth) map &#123; i =&gt;</span><br><span class="line">  s1_valid &amp;&amp; f1_mask(i) &amp;&amp; s1_bpd_resp.preds(i).predicted_pc.valid &amp;&amp;</span><br><span class="line">  (s1_bpd_resp.preds(i).is_jal ||</span><br><span class="line">    (s1_bpd_resp.preds(i).is_br &amp;&amp; s1_bpd_resp.preds(i).taken))</span><br><span class="line">&#125;</span><br><span class="line">val f1_redirect_idx = PriorityEncoder(f1_redirects)</span><br><span class="line">val f1_do_redirect = f1_redirects.reduce(_||_) &amp;&amp; useBPD.B</span><br><span class="line">val f1_targs = s1_bpd_resp.preds.map(_.predicted_pc.bits)</span><br><span class="line">val f1_predicted_target = Mux(f1_do_redirect,</span><br><span class="line">                              f1_targs(f1_redirect_idx),</span><br><span class="line">                              nextFetch(s1_vpc))</span><br><span class="line"></span><br><span class="line">val f1_predicted_ghist = s1_ghist.update(</span><br><span class="line">  s1_bpd_resp.preds.map(p =&gt; p.is_br &amp;&amp; p.predicted_pc.valid).asUInt &amp; f1_mask,</span><br><span class="line">  s1_bpd_resp.preds(f1_redirect_idx).taken &amp;&amp; f1_do_redirect,</span><br><span class="line">  s1_bpd_resp.preds(f1_redirect_idx).is_br,</span><br><span class="line">  f1_redirect_idx,</span><br><span class="line">  f1_do_redirect,</span><br><span class="line">  s1_vpc,</span><br><span class="line">  false.B,</span><br><span class="line">  false.B)</span><br></pre></td></tr></table></figure>

<h4 id="详解mask"><a href="#详解mask" class="headerlink" title="详解mask"></a>详解mask</h4><p>取指令通过mask来屏蔽无效指令，如下面代码，我们只讲解bank&#x3D;2的情况，首先算出shamt位移量，然后通过是否在同一个set算出end_mask,最后进行编码</p>
<p>举例：假设fetchWidth&#x3D;8，coreInstBytes&#x3D;2，block&#x3D;16bytes，numChunks&#x3D;2 banks&#x3D;2</p>
<p>如果地址为0011 1100，</p>
<p>idx&#x3D;110</p>
<p>shamt&#x3D;10</p>
<p>那么这个地址显然需要跨两行，mayNotBeDualBanked显然为1，</p>
<p>故end_mask &#x3D; 0000 1111</p>
<p>故最终结果为0000 1100，也就是他会屏蔽跨行的指令</p>
<p>如果地址为0011 0100，这个没有跨行，所以最终结果为</p>
<p>1111 1100</p>
<p>也就是说，mask是对取出的指令做一个有效编码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def isLastBankInBlock(addr: UInt) = &#123;</span><br><span class="line">  (nBanks == 2).B &amp;&amp; addr(blockOffBits-1, log2Ceil(bankBytes)) === (numChunks-1).U</span><br><span class="line">&#125;</span><br><span class="line">def mayNotBeDualBanked(addr: UInt) = &#123;</span><br><span class="line">  require(nBanks == 2)</span><br><span class="line">  isLastBankInBlock(addr)</span><br><span class="line">&#125;</span><br><span class="line">def fetchMask(addr: UInt) = &#123;</span><br><span class="line">  val idx = addr.extract(log2Ceil(fetchWidth)+log2Ceil(coreInstBytes)-1, log2Ceil(coreInstBytes))</span><br><span class="line">  if (nBanks == 1) &#123;</span><br><span class="line">    ((1 &lt;&lt; fetchWidth)-1).U &lt;&lt; idx</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    val shamt = idx.extract(log2Ceil(fetchWidth)-2, 0)</span><br><span class="line">    val end_mask = Mux(mayNotBeDualBanked(addr), Fill(fetchWidth/2, 1.U), Fill(fetchWidth, 1.U))</span><br><span class="line">    ((1 &lt;&lt; fetchWidth)-1).U &lt;&lt; shamt &amp; end_mask</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么br_mask 就是在有效指令中筛选为BR的指令</p>
<h4 id="GHist更新逻辑"><a href="#GHist更新逻辑" class="headerlink" title="GHist更新逻辑"></a>GHist更新逻辑</h4><p>以例子来进行讲解</p>
<p>Ghist的更新是采用了update方法,他的输入依次如下：</p>
<ul>
<li>branches: UInt,：这个就是上面讲解的br_mask,</li>
<li>cfi_taken: Bool：指令是否taken，这个信号一般指的是最旧的指令是否taken，这个例子就是先得出f1_redirects(重定向指令的mask)，然后通过优先编码器得出最旧的指令然后得出是否要重定向信号f1_do_redirect，以及预测目标，所以这个信号就是最旧的分支是否taken，并且是否要重定向。</li>
<li>cfi_is_br: Bool：这个信号得出了最旧的分支指令是否为br，（f1分支预测包含br jalr，jalr，但只有条件分支可以更改ghist）</li>
<li>cfi_idx: UInt：得出最旧的分支指令的（这个可能包括jal或jalr，而且这个不是oh编码，只是简单的idx）</li>
<li>cfi_valid: Bool：是否需要重定向</li>
<li>addr: UInt：pc</li>
<li>cfi_is_call: Bool</li>
<li>cfi_is_ret: Bool</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">val f1_mask = fetchMask(s1_vpc)</span><br><span class="line">val f1_redirects = (0 until fetchWidth) map &#123; i =&gt;</span><br><span class="line">  s1_valid &amp;&amp; f1_mask(i) &amp;&amp; s1_bpd_resp.preds(i).predicted_pc.valid &amp;&amp;</span><br><span class="line">  (s1_bpd_resp.preds(i).is_jal ||</span><br><span class="line">    (s1_bpd_resp.preds(i).is_br &amp;&amp; s1_bpd_resp.preds(i).taken))</span><br><span class="line">&#125;</span><br><span class="line">val f1_redirect_idx = PriorityEncoder(f1_redirects)</span><br><span class="line">val f1_do_redirect = f1_redirects.reduce(_||_) &amp;&amp; useBPD.B</span><br><span class="line">val f1_targs = s1_bpd_resp.preds.map(_.predicted_pc.bits)</span><br><span class="line">val f1_predicted_target = Mux(f1_do_redirect,</span><br><span class="line">                              f1_targs(f1_redirect_idx),</span><br><span class="line">                              nextFetch(s1_vpc))</span><br><span class="line">val f1_predicted_ghist = s1_ghist.update(</span><br><span class="line">  s1_bpd_resp.preds.map(p =&gt; p.is_br &amp;&amp; p.predicted_pc.valid).asUInt &amp; f1_mask,</span><br><span class="line">  s1_bpd_resp.preds(f1_redirect_idx).taken &amp;&amp; f1_do_redirect,</span><br><span class="line">  s1_bpd_resp.preds(f1_redirect_idx).is_br,</span><br><span class="line">  f1_redirect_idx,</span><br><span class="line">  f1_do_redirect,</span><br><span class="line">  s1_vpc,</span><br><span class="line">  false.B,</span><br><span class="line">  false.B)</span><br></pre></td></tr></table></figure>

<p><strong>not_taken_branches</strong>：如果条件分支taken或者不是条件分支，这个就为0，否则就不为0，</p>
<p>然后进入update方法，update方法也是分了bank讨论，首先讨论bank为1的</p>
<p>new_history.old_history更新逻辑：</p>
<ul>
<li>如果这个分支是条件分支并且taken：histories(0) &lt;&lt;1|1.U</li>
<li>如果是条件分支但没有taken：histories(0) &lt;&lt;1</li>
<li>如果不是条件分支：histories(0)</li>
</ul>
<p>下面讨论bank为2的情况</p>
<p>他使用的始终histories(1)，也就是更新逻辑,</p>
<p>首先判断cfi指令在bank0或者整个packet是否跨行了（ignore_second_bank），然后得出第一个bank是否有条件分支未taken（first_bank_saw_not_taken）：</p>
<p>如果忽视bank1，根据new_history.new_saw_branch_not_taken ，new_history.new_saw_branch_taken更新old_hist</p>
<p>否则，new_saw_branch_not_taken：bank1是否有没taken的指令</p>
<p>new_saw_branch_taken：bank1是否有taken的指令并且cfi不在bank0</p>
<p>然后更新old_hist:</p>
<blockquote>
<p><del>感觉这个更新逻辑有问题，ignore_second_bank有两个条件：如果cfi在bank0，otherwise的MUX的cfi_is_br &amp;&amp; cfi_in_bank_0必然不会成立，如果mayNotBeDualBanked成立，那么cfi必然在bank1，该条件仍然不会成立，同样first_bank_saw_not_taken也不会成立，所以这个逻辑最后就是得到了histories（1），之前的逻辑都是冗余的(将多余代码去掉仍然可以运行程序)</del></p>
<p>没什么问题,如果想进入otherwise代码块:</p>
<ol>
<li>bank0无分支或者分支预测没taken</li>
<li>分支指令在bank1</li>
</ol>
<p>但cfi_is_br &amp;&amp; cfi_in_bank_0是无效的逻辑，进入when代码块必然不会进入otherwise，所以必然不会触发这个MUX条件（理解问题？）</p>
</blockquote>
<p>举个例子来说明这两个条件什么意思:</p>
<p>例：假设fetchWidth&#x3D;8，coreInstBytes&#x3D;2，block&#x3D;16bytes，numChunks&#x3D;2 banks&#x3D;2</p>
<p>如果地址为0011 1100，cfi_idx_oh为0000 1000</p>
<p>这个地址mayNotBeDualBanked为1，cfi_in_bank0为1,如果这个不是分支,或者没有taken,cfi_in_bank0为0</p>
<p>如果地址0011 0000,cfi_idx_oh为0001 0000</p>
<p>这个地址mayNotBeDualBanked为0，cfi_in_bank0为0,如果cfi_idx_oh,cfi_in_bank0就为1</p>
<blockquote>
<p>这里ignore_second_bank的意思就是第二个分支没有分支或者分支无效,</p>
<p>假设第二个bank有分支,我们会忽视第一个bank的分支历史,只更新第二个bank</p>
</blockquote>
<blockquote>
<p>In the two bank case every bank ignore the history added by the previous bank</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  def histories(bank: Int) = &#123;</span><br><span class="line">    if (nBanks == 1) &#123;</span><br><span class="line">      old_history</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      require(nBanks == 2)</span><br><span class="line">      if (bank == 0) &#123;</span><br><span class="line">        old_history</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        Mux(new_saw_branch_taken                            , old_history &lt;&lt; 1 | 1.U,</span><br><span class="line">        Mux(new_saw_branch_not_taken                        , old_history &lt;&lt; 1,</span><br><span class="line">                                                              old_history))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">def update(branches: UInt, cfi_taken: Bool, cfi_is_br: Bool, cfi_idx: UInt,</span><br><span class="line">    cfi_valid: Bool, addr: UInt,</span><br><span class="line">    cfi_is_call: Bool, cfi_is_ret: Bool): GlobalHistory = &#123;</span><br><span class="line">    val cfi_idx_fixed = cfi_idx(log2Ceil(fetchWidth)-1,0)</span><br><span class="line">    val cfi_idx_oh = UIntToOH(cfi_idx_fixed)</span><br><span class="line">    val new_history = Wire(new GlobalHistory)</span><br><span class="line"></span><br><span class="line">    val not_taken_branches = branches &amp; Mux(cfi_valid,</span><br><span class="line">                                            MaskLower(cfi_idx_oh) &amp; ~Mux(cfi_is_br &amp;&amp; cfi_taken, cfi_idx_oh, 0.U(fetchWidth.W)),</span><br><span class="line">                                            ~(0.U(fetchWidth.W)))</span><br><span class="line"></span><br><span class="line">    if (nBanks == 1) &#123;</span><br><span class="line">      // In the single bank case every bank sees the history including the previous bank</span><br><span class="line">      new_history := DontCare</span><br><span class="line">      new_history.current_saw_branch_not_taken := false.B</span><br><span class="line">      val saw_not_taken_branch = not_taken_branches =/= 0.U || current_saw_branch_not_taken</span><br><span class="line">      new_history.old_history := Mux(cfi_is_br &amp;&amp; cfi_taken &amp;&amp; cfi_valid   , histories(0) &lt;&lt; 1 | 1.U,</span><br><span class="line">                                 Mux(saw_not_taken_branch                  , histories(0) &lt;&lt; 1,</span><br><span class="line">                                                                             histories(0)))</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // In the two bank case every bank ignore the history added by the previous bank</span><br><span class="line">      val base = histories(1)</span><br><span class="line">      val cfi_in_bank_0 = cfi_valid &amp;&amp; cfi_taken &amp;&amp; cfi_idx_fixed &lt; bankWidth.U</span><br><span class="line">      val ignore_second_bank = cfi_in_bank_0 || mayNotBeDualBanked(addr)</span><br><span class="line"></span><br><span class="line">      val first_bank_saw_not_taken = not_taken_branches(bankWidth-1,0) =/= 0.U || current_saw_branch_not_taken</span><br><span class="line">      new_history.current_saw_branch_not_taken := false.B</span><br><span class="line">      when (ignore_second_bank) &#123;</span><br><span class="line">        new_history.old_history := histories(1)</span><br><span class="line">        new_history.new_saw_branch_not_taken := first_bank_saw_not_taken</span><br><span class="line">        new_history.new_saw_branch_taken     := cfi_is_br &amp;&amp; cfi_in_bank_0</span><br><span class="line">      &#125; .otherwise &#123;</span><br><span class="line">        new_history.old_history := Mux(cfi_is_br &amp;&amp; cfi_in_bank_0                             , histories(1) &lt;&lt; 1 | 1.U,</span><br><span class="line">                                   Mux(first_bank_saw_not_taken                               , histories(1) &lt;&lt; 1,</span><br><span class="line">                                                                                                histories(1)))</span><br><span class="line"></span><br><span class="line">        new_history.new_saw_branch_not_taken := not_taken_branches(fetchWidth-1,bankWidth) =/= 0.U</span><br><span class="line">        new_history.new_saw_branch_taken     := cfi_valid &amp;&amp; cfi_taken &amp;&amp; cfi_is_br &amp;&amp; !cfi_in_bank_0</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    new_history.ras_idx := Mux(cfi_valid &amp;&amp; cfi_is_call, WrapInc(ras_idx, nRasEntries),</span><br><span class="line">                           Mux(cfi_valid &amp;&amp; cfi_is_ret , WrapDec(ras_idx, nRasEntries), ras_idx))</span><br><span class="line">    new_history</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="F2"><a href="#F2" class="headerlink" title="F2"></a>F2</h3><p>f2阶段获得cache数据，注意f2阶段可能收到无效的cache数据，或者收到了数据但f3接收不了，这时就要重定向，然后冲刷f1阶段，f2阶段也会得到预测结果，其处理和f1阶段类似</p>
<blockquote>
<p>(s1_vpc &#x3D;&#x2F;&#x3D; f2_predicted_target || f2_correct_f1_ghist)，f2分支预测重定向需要前面两个条件，条件1的意思就是f2阶段预测的地址和之前这条指令与目前f1的pc不一样，条件2的意思预测方向不一样</p>
</blockquote>
<h3 id="F3"><a href="#F3" class="headerlink" title="F3"></a>F3</h3><p>f3阶段使用了IMem Response Queue和BTB Response Queue，两个队列项数均为1，其中IMem Response Queue在F2阶段入队，在F3阶段出队，主要传递Icache响应的指令、PC、全局历史等信息；而BTB Response Queue则设置成“flow”的形式（即输入可以在同一周期内“流”过队列输出），所以它的入队出队均在F3阶段完成，主要传递分支预测器的预测信息。</p>
<p>这个周期也会有来自bpd的预测信息（TAGE），同样会进行重定向，该阶段有一个快速译码单元用于检查分支预测，并且这个周期会检查RVC指令并进行相应处理</p>
<h4 id="有效指令截断处理"><a href="#有效指令截断处理" class="headerlink" title="有效指令截断处理"></a>有效指令截断处理</h4><p>也就是32位的指令分布在两个指令包</p>
<blockquote>
<p>小插曲：f3_prev_is_half的值来自bank_prev_is_half，而bank_prev_is_half是一个var，也就是可变变量,这里他在for循环内多次被赋值，实际上就是给f3_prev_is_half提供了多个赋值条件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...   </span><br><span class="line"> bank_prev_is_half = Mux(f3_bank_mask(b),</span><br><span class="line">      (!(bank_mask(bankWidth-2) &amp;&amp; !isRVC(bank_insts(bankWidth-2))) &amp;&amp; !isRVC(last_inst)),</span><br><span class="line">      bank_prev_is_half)</span><br><span class="line">...</span><br><span class="line">  when (f3.io.deq.fire) &#123;</span><br><span class="line">    f3_prev_is_half := bank_prev_is_half</span><br><span class="line">    f3_prev_half    := bank_prev_half</span><br><span class="line">    assert(f3_bpd_resp.io.deq.bits.pc === f3_fetch_bundle.pc)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>下面是一个测试用例</p>
<p><img src="/2025/02/05/diplomacy&boom/1732097110110.png" alt="1732097110110"></p>
<p><img src="/2025/02/05/diplomacy&boom/1732097127143.png" alt="1732097127143"></p>
</blockquote>
<p>首先先解析bank信号，bank_data可以看到就是每个bank的data，对于largeboom就是64位的数据（其中bankwidth为4，bank为2）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">val bank_data  = f3_data((b+1)*bankWidth*16-1, b*bankWidth*16)</span><br><span class="line">val bank_mask  = Wire(Vec(bankWidth, Bool()))</span><br><span class="line">val bank_insts = Wire(Vec(bankWidth, UInt(32.W)))</span><br></pre></td></tr></table></figure>

<p>bank_mask和之前提到的mask类似,揭示了一个bank每条指令是否有效,</p>
<p>当f3的指令有效并且没有收到重定向信号,就对bank_mask赋值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  for (b &lt;- 0 until nBanks) &#123;</span><br><span class="line">.....</span><br><span class="line"></span><br><span class="line">    for (w &lt;- 0 until bankWidth) &#123;</span><br><span class="line">      val i = (b * bankWidth) + w</span><br><span class="line">      bank_mask(w) := f3.io.deq.valid &amp;&amp; f3_imemresp.mask(i) &amp;&amp; valid &amp;&amp; !redirect_found</span><br></pre></td></tr></table></figure>

<p>bank_inst主要逻辑在内层循环内</p>
<p>主要有4种情况:</p>
<ol>
<li>当w&#x3D;0,也就是第一条指令,注意这条指令可能是不完整的32bit指令,如果这条指令是不完整,那么就将之前存的half指令拼接到这个不完整的指令,形成32bit(bank_data(15,0), f3_prev_half),注意如果此时b&gt;0,也即是现在是bank1,那么之前的一半指令就是(bank_data(15,0), last_inst)拼接,如果这个指令是完整的指令,就直接为bank_data(31,0),valid一定为true</li>
<li>当w&#x3D;1,bank_inst就直接为bank_data(47,16),</li>
<li>当w&#x3D;bankWidth -1,注意这里可能会发生32bit的指令不完整的情况,bank_inst为16个0和bank_data(bankWidth*16-1,(bankWidth-1)*16)拼接,</li>
<li>其他情况,bank_data(w<em>16+32-1,w</em>16)</li>
</ol>
<p>valid信号四种情况</p>
<p>w&#x3D;0,恒为高</p>
<p>w&#x3D;1,如果之前的指令为bank_prev_is_half,或者不满足括号条件(之前的指令有效但不是RVC指令),说明这个inst和之前的inst无关,valid拉高</p>
<p>w&#x3D;bankWidth -1,这里列举所有情况:</p>
<ol>
<li>本条不是RVC,且上条也不是RVC:1.本条指令和上一条是一条指令,那么本条指令就无效,本条指令是下一个bank的前半部分指令,那么本条就为有效</li>
<li>本条不是RVC,但上一条是RVC:恒为高</li>
<li>本条是RVC,但上一条不是RVC,恒为高,因为上一条一定是32bit指令的后半部分,其bank_mask一定为低,!((bank_mask(w-1) &amp;&amp;!isRVC(bank_insts(w-1)))一定为高</li>
<li>本条是RVC,上条也是RVC:恒为高</li>
</ol>
<p>其他情况:只要上条指令不满足(bank_mask(w-1) &amp;&amp;!isRVC(bank_insts(w-1),就为高(上条指令无效,上条指令为32bit指令的后半部分或上条指令为RVC指令)</p>
<blockquote>
<p>如下面的矩形,绿色代表4字节的指令,蓝色代表2字节的指令,四个块一个bank,其中情况1的b&gt;0情况,第四个块就是last_inst,b&#x3D;0的情况就是第一个块为4字节指令的后一半,前一半在f3_prev_half中存储,也就是之前的指令包的w&#x3D;bankWidth -1,的指令</p>
</blockquote>
<p><img src="/2025/02/05/diplomacy&boom/1732108893805.png" alt="1732108893805"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    for (w &lt;- 0 until bankWidth) &#123;</span><br><span class="line">...</span><br><span class="line">      val brsigs = Wire(new BranchDecodeSignals)</span><br><span class="line">      if (w == 0) &#123;</span><br><span class="line">        val inst0 = Cat(bank_data(15,0), f3_prev_half)</span><br><span class="line">        val inst1 = bank_data(31,0)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">        when (bank_prev_is_half) &#123;</span><br><span class="line">          bank_insts(w)                := inst0</span><br><span class="line">...</span><br><span class="line">          if (b &gt; 0) &#123;</span><br><span class="line">            val inst0b     = Cat(bank_data(15,0), last_inst)</span><br><span class="line">...</span><br><span class="line">            when (f3_bank_mask(b-1)) &#123;</span><br><span class="line">              bank_insts(w)                := inst0b</span><br><span class="line">              f3_fetch_bundle.insts(i)     := inst0b</span><br><span class="line">              f3_fetch_bundle.exp_insts(i) := exp_inst0b</span><br><span class="line">              brsigs                       := bpd_decoder0b.io.out</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; .otherwise &#123;</span><br><span class="line">          bank_insts(w)                := inst1</span><br><span class="line">...</span><br><span class="line">        &#125;</span><br><span class="line">        valid := true.B</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        val inst = Wire(UInt(32.W))</span><br><span class="line">..</span><br><span class="line">        val pc = f3_aligned_pc + (i &lt;&lt; log2Ceil(coreInstBytes)).U</span><br><span class="line">...</span><br><span class="line">        bank_insts(w)                := inst</span><br><span class="line">...</span><br><span class="line">        if (w == 1) &#123;</span><br><span class="line">          // Need special case since 0th instruction may carry over the wrap around</span><br><span class="line">          inst  := bank_data(47,16)</span><br><span class="line">          valid := bank_prev_is_half || !(bank_mask(0) &amp;&amp; !isRVC(bank_insts(0)))</span><br><span class="line">        &#125; else if (w == bankWidth - 1) &#123;</span><br><span class="line">          inst  := Cat(0.U(16.W), bank_data(bankWidth*16-1,(bankWidth-1)*16))</span><br><span class="line">          valid := !((bank_mask(w-1) &amp;&amp; !isRVC(bank_insts(w-1))) ||</span><br><span class="line">            !isRVC(inst))</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          inst  := bank_data(w*16+32-1,w*16)</span><br><span class="line">          valid := !(bank_mask(w-1) &amp;&amp; !isRVC(bank_insts(w-1)))</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   last_inst = bank_insts(bankWidth-1)(15,0)</span><br><span class="line">   ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>OK,bank信号已经解释完了,接下来进行分支指令解码</p>
<h4 id="分支指令预解码"><a href="#分支指令预解码" class="headerlink" title="分支指令预解码"></a>分支指令预解码</h4><p>ExpandRVC判断这个指令是否为RVC,如果为RVC,返回相应的扩展指令,如果不是RVC,直接返回输入的inst,inst0和1对应的是两种情况,一种是本指令包的第一条为32位指令,但有一半在上个指令包,另一种就是指令是整齐的</p>
<blockquote>
<p>如果这个指令对应两条RVC指令呢?</p>
<p>RVC和RVI指令如何区分的呢</p>
<p>f3_bank_mask信号有用吗</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">val inst0 = Cat(bank_data(15,0), f3_prev_half)</span><br><span class="line">val inst1 = bank_data(31,0)</span><br><span class="line">val exp_inst0 = ExpandRVC(inst0)</span><br><span class="line">val exp_inst1 = ExpandRVC(inst1)//inst0和1分别对应了RVI指令和未知的指令</span><br><span class="line">val pc0 = (f3_aligned_pc + (i &lt;&lt; log2Ceil(coreInstBytes)).U - 2.U)</span><br><span class="line">val pc1 = (f3_aligned_pc + (i &lt;&lt; log2Ceil(coreInstBytes)).U)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>分支预解码也是分情况</p>
<ol>
<li>w&#x3D;0,如果遇到了不完整的指令,就采用decoder0的结果,b&gt;0,同样要做出处理,将inst0的f3_prev_half换为last_inst(其实这里bank_prev_half也可以),之后对这个指令解码就可以,否则就使用inst1的解码结果</li>
<li>其他情况,就直接对inst解码,注意inst的生成也会分情况(之前讲过)</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> for (b &lt;- 0 until nBanks) &#123;</span><br><span class="line">...</span><br><span class="line">    for (w &lt;- 0 until bankWidth) &#123;</span><br><span class="line">...</span><br><span class="line">      val brsigs = Wire(new BranchDecodeSignals)</span><br><span class="line">      if (w == 0) &#123;</span><br><span class="line">        val inst0 = Cat(bank_data(15,0), f3_prev_half)</span><br><span class="line">        val inst1 = bank_data(31,0)</span><br><span class="line">        val exp_inst0 = ExpandRVC(inst0)</span><br><span class="line">        val exp_inst1 = ExpandRVC(inst1)//inst0和1分别对应了RVI指令和未知的指令</span><br><span class="line">        val pc0 = (f3_aligned_pc + (i &lt;&lt; log2Ceil(coreInstBytes)).U - 2.U)</span><br><span class="line">        val pc1 = (f3_aligned_pc + (i &lt;&lt; log2Ceil(coreInstBytes)).U)</span><br><span class="line">        val bpd_decoder0 = Module(new BranchDecode)</span><br><span class="line">        bpd_decoder0.io.inst := exp_inst0</span><br><span class="line">        bpd_decoder0.io.pc   := pc0</span><br><span class="line">        val bpd_decoder1 = Module(new BranchDecode)</span><br><span class="line">        bpd_decoder1.io.inst := exp_inst1</span><br><span class="line">        bpd_decoder1.io.pc   := pc1</span><br><span class="line"></span><br><span class="line">        when (bank_prev_is_half) &#123;</span><br><span class="line">          bank_insts(w)                := inst0</span><br><span class="line">...</span><br><span class="line">          bpu.io.pc                    := pc0</span><br><span class="line">          brsigs                       := bpd_decoder0.io.out//指令不完整.且一定为32位,选择decode0的br信号</span><br><span class="line">...</span><br><span class="line">          if (b &gt; 0) &#123;</span><br><span class="line">            val inst0b     = Cat(bank_data(15,0), last_inst)</span><br><span class="line">            val exp_inst0b = ExpandRVC(inst0b)</span><br><span class="line">            val bpd_decoder0b = Module(new BranchDecode)</span><br><span class="line">            bpd_decoder0b.io.inst := exp_inst0b</span><br><span class="line">            bpd_decoder0b.io.pc   := pc0</span><br><span class="line"></span><br><span class="line">            when (f3_bank_mask(b-1)) &#123;</span><br><span class="line">...</span><br><span class="line">              brsigs                       := bpd_decoder0b.io.out</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; .otherwise &#123;</span><br><span class="line">...</span><br><span class="line">          bpu.io.pc                    := pc1</span><br><span class="line">          brsigs                       := bpd_decoder1.io.out</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        valid := true.B</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        val inst = Wire(UInt(32.W))</span><br><span class="line">        val exp_inst = ExpandRVC(inst)</span><br><span class="line">        val pc = f3_aligned_pc + (i &lt;&lt; log2Ceil(coreInstBytes)).U</span><br><span class="line">        val bpd_decoder = Module(new BranchDecode)</span><br><span class="line">        bpd_decoder.io.inst := exp_inst</span><br><span class="line">        bpd_decoder.io.pc   := pc</span><br><span class="line">...</span><br><span class="line">        bpu.io.pc                    := pc</span><br><span class="line">        brsigs                       := bpd_decoder.io.out</span><br><span class="line">...</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>f3阶段的目标来自多个地方(f3_targs):如果是jalr指令,那么目标地址只能为bpd预测的地址,如果是条件分支或者jal,目标地址就是解码出来的地址</p>
<p>如果是jal指令:需要对目标地址检测,如果目标地址预测正确,不刷新BTB表项,</p>
<p>如果进行重定向,那么先检测是不是ret指令.如果是,就从RAS取出数据,否则从f3_targs取数据,</p>
<p>如果不重定向,就对pc+bankbyte或者fetchbyte</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">      f3_targs (i) := Mux(brsigs.cfi_type === CFI_JALR,</span><br><span class="line">        f3_bpd_resp.io.deq.bits.preds(i).predicted_pc.bits,</span><br><span class="line">        brsigs.target)</span><br><span class="line"></span><br><span class="line">      // Flush BTB entries for JALs if we mispredict the target</span><br><span class="line">      f3_btb_mispredicts(i) := (brsigs.cfi_type === CFI_JAL &amp;&amp; valid &amp;&amp;</span><br><span class="line">        f3_bpd_resp.io.deq.bits.preds(i).predicted_pc.valid &amp;&amp;</span><br><span class="line">        (f3_bpd_resp.io.deq.bits.preds(i).predicted_pc.bits =/= brsigs.target)</span><br><span class="line">      )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      f3_npc_plus4_mask(i) := (if (w == 0) &#123;</span><br><span class="line">        !f3_is_rvc(i) &amp;&amp; !bank_prev_is_half</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        !f3_is_rvc(i)</span><br><span class="line">      &#125;)</span><br><span class="line">...  </span><br><span class="line">  val f3_predicted_target = Mux(f3_redirects.reduce(_||_),</span><br><span class="line">    Mux(f3_fetch_bundle.cfi_is_ret &amp;&amp; useBPD.B &amp;&amp; useRAS.B,</span><br><span class="line">      ras.io.read_addr,</span><br><span class="line">      f3_targs(PriorityEncoder(f3_redirects))</span><br><span class="line">    ),</span><br><span class="line">    nextFetch(f3_fetch_bundle.pc)</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>F3阶段算是前端的一个核心阶段,这个阶段进行分支预解码,TAGE出结果,并且对RVC指令检测,将RVC变为32位指令,之后将f3_fetch_bundle送入F4</p>
<h3 id="F4"><a href="#F4" class="headerlink" title="F4"></a>F4</h3><p>F4阶段主要进行的工作就是重定向操作,这个在F0中已经讲解,f4阶段还会将指令写入Fetchbuffer和FTQ</p>
<p>f4阶段还会修复前端的BTB或RAS,首先有一个仲裁器选择重定向信息来自FTQ还是f4阶段的BTB重定向信息,(低位优先级高),如果FTQ传来RAS修复信号,就对RAS进行修复</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">val bpd_update_arbiter = Module(new Arbiter(new BranchPredictionUpdate, 2))</span><br><span class="line">bpd_update_arbiter.io.in(0).valid := ftq.io.bpdupdate.valid</span><br><span class="line">bpd_update_arbiter.io.in(0).bits  := ftq.io.bpdupdate.bits</span><br><span class="line">assert(bpd_update_arbiter.io.in(0).ready)</span><br><span class="line">bpd_update_arbiter.io.in(1) &lt;&gt; f4_btb_corrections.io.deq</span><br><span class="line">bpd.io.update := bpd_update_arbiter.io.out</span><br><span class="line">bpd_update_arbiter.io.out.ready := true.B</span><br><span class="line"></span><br><span class="line">when (ftq.io.ras_update &amp;&amp; enableRasTopRepair.B) &#123;</span><br><span class="line">  ras.io.write_valid := true.B</span><br><span class="line">  ras.io.write_idx   := ftq.io.ras_update_idx</span><br><span class="line">  ras.io.write_addr  := ftq.io.ras_update_pc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="F5"><a href="#F5" class="headerlink" title="F5"></a>F5</h3><p>虚拟的阶段,主要对将IFU数据送入IDU,进行重定向操作</p>
<h2 id="BOOM-FTQ"><a href="#BOOM-FTQ" class="headerlink" title="BOOM FTQ"></a>BOOM FTQ</h2><p>获取目标队列是一个队列，用于保存从 i-cache 接收到的 PC 以及与该地址关联的分支预测信息。它保存此信息，供管道在执行其<a href="https://docs.boom-core.org/en/latest/sections/terminology.html#term-micro-op-uop">微操作 (UOP)</a>时参考。一旦提交指令，ROB 就会将其从队列中移出，并在重定向&#x2F;误推测期间进行更新。</p>
<h3 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h3><p>当do_enq拉高，表示入队信号拉高，进入入队逻辑，new_entry和new_ghist接受入队数据，如现阶段有分支预测失败，就将入队glist写入new_list，否则，按照之前的数据更新new_list,然后写入ghist和lhist</p>
<h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><blockquote>
<p>为什么bpd_idx要增加</p>
<p>为什么要用两个ghist,</p>
</blockquote>
<p>如下面波形,bpd_repair就是ftq_idx对应的pc</p>
<p><img src="/2025/02/05/diplomacy&boom/1732436351046.png" alt="1732436351046"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//下面是一次预测失败要经过的状态</span><br><span class="line">//| br_info   |  b2     |reg(b2)        |             |             |  </span><br><span class="line">//|   b1      |  red_val|mispred(false) |mispred(true)|mispred(false)|mispred(false)|          |____</span><br><span class="line">//|           |         |repair(false)  |repair(false)|repair(true) |repair(true)  |          |    |一直运行直到修复完成</span><br><span class="line">//                |                        repair_idx   repair_idx     repair_pc   |repair_idx| +__| </span><br><span class="line">//                |                        end_idx                     repair_idx  |          |</span><br><span class="line">// (找到分支预测失败的ftq表项)                                          ()  </span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">  when (io.redirect.valid) &#123;</span><br><span class="line">    bpd_update_mispredict := false.B</span><br><span class="line">    bpd_update_repair     := false.B</span><br><span class="line">  &#125; .elsewhen (RegNext(io.brupdate.b2.mispredict)) &#123;</span><br><span class="line">    bpd_update_mispredict := true.B</span><br><span class="line">    bpd_repair_idx        := RegNext(io.brupdate.b2.uop.ftq_idx)</span><br><span class="line">    bpd_end_idx           := RegNext(enq_ptr)</span><br><span class="line">  &#125; .elsewhen (bpd_update_mispredict) &#123;//</span><br><span class="line">    bpd_update_mispredict := false.B</span><br><span class="line">    bpd_update_repair     := true.B</span><br><span class="line">    bpd_repair_idx        := WrapInc(bpd_repair_idx, num_entries)</span><br><span class="line">  &#125; .elsewhen (bpd_update_repair &amp;&amp; RegNext(bpd_update_mispredict)) &#123;</span><br><span class="line">    bpd_repair_pc         := bpd_pc</span><br><span class="line">    bpd_repair_idx        := WrapInc(bpd_repair_idx, num_entries)</span><br><span class="line">  &#125; .elsewhen (bpd_update_repair) &#123;</span><br><span class="line">    bpd_repair_idx        := WrapInc(bpd_repair_idx, num_entries)</span><br><span class="line">    when (WrapInc(bpd_repair_idx, num_entries) === bpd_end_idx ||</span><br><span class="line">      bpd_pc === bpd_repair_pc)  &#123;</span><br><span class="line">      bpd_update_repair := false.B</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>分支预测失败的状态机如上面所示,</p>
<p>接下来就是传入更新信息,首先将enq_ptr设置为传入的ftq_idx+1,如果这个重定向来自分支预测失败,就将更新信息写入redirect_new_entry,然后下个周期将更新信息写入prev_entry,将重定向的信息写入entry_ram;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  when (io.redirect.valid) &#123;//传入更新信息</span><br><span class="line">    enq_ptr    := WrapInc(io.redirect.bits, num_entries)</span><br><span class="line"></span><br><span class="line">    when (io.brupdate.b2.mispredict) &#123;</span><br><span class="line">    val new_cfi_idx = (io.brupdate.b2.uop.pc_lob ^</span><br><span class="line">      Mux(redirect_entry.start_bank === 1.U, 1.U &lt;&lt; log2Ceil(bankBytes), 0.U))(log2Ceil(fetchWidth), 1)</span><br><span class="line">.......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">.......</span><br><span class="line"></span><br><span class="line">  &#125; .elsewhen (RegNext(io.redirect.valid)) &#123;//信息传入完成</span><br><span class="line">    prev_entry := RegNext(redirect_new_entry)</span><br><span class="line">    prev_ghist := bpd_ghist</span><br><span class="line">    prev_pc    := bpd_pc</span><br><span class="line"></span><br><span class="line">    ram(RegNext(io.redirect.bits)) := RegNext(redirect_new_entry)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="后端读pc"><a href="#后端读pc" class="headerlink" title="后端读pc"></a>后端读pc</h3><p>有两个端口,其中0端口是送入后端jmp_unit的,端口1主要是进行重定向获取pc的,主要代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (i &lt;- 0 until 2) &#123;</span><br><span class="line">  val idx = io.get_ftq_pc(i).ftq_idx</span><br><span class="line">  val next_idx = WrapInc(idx, num_entries)</span><br><span class="line">  val next_is_enq = (next_idx === enq_ptr) &amp;&amp; io.enq.fire</span><br><span class="line">  val next_pc = Mux(next_is_enq, io.enq.bits.pc, pcs(next_idx))</span><br><span class="line">  val get_entry = ram(idx)</span><br><span class="line">  val next_entry = ram(next_idx)</span><br><span class="line">  io.get_ftq_pc(i).entry     := RegNext(get_entry)</span><br><span class="line">  if (i == 1)</span><br><span class="line">    io.get_ftq_pc(i).ghist   := ghist(1).read(idx, true.B)</span><br><span class="line">  else</span><br><span class="line">    io.get_ftq_pc(i).ghist   := DontCare</span><br><span class="line">  io.get_ftq_pc(i).pc        := RegNext(pcs(idx))</span><br><span class="line">  io.get_ftq_pc(i).next_pc   := RegNext(next_pc)</span><br><span class="line">  io.get_ftq_pc(i).next_val  := RegNext(next_idx =/= enq_ptr || next_is_enq)</span><br><span class="line">  io.get_ftq_pc(i).com_pc    := RegNext(pcs(Mux(io.deq.valid, io.deq.bits, deq_ptr)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这些bpd_pc和mispred以及repair到底是干什么的</p>
<p>一条分支指令处理的流程</p>
<p>globalhistory的current_saw_branch_not_taken是干什么的</p>
<p>cfi这些信号是干什么的?</p>
</blockquote>
<h2 id="Fetch-Buffer"><a href="#Fetch-Buffer" class="headerlink" title="Fetch Buffer"></a>Fetch Buffer</h2><p>Fetch Buffer本质上是一个FIFO，寄存器堆构成,主要是作为缓冲,其可以配置为流式fifo，Fetch Buffer每次从F4阶段输入一个Fetch Packets，根据掩码将无效指令去掉后，从Buffer的尾部进入，每次从Buffer的头部输出coreWidth（后续流水线并行执行的宽度）个指令到译码级。</p>
<h3 id="入队出队信号"><a href="#入队出队信号" class="headerlink" title="入队出队信号"></a>入队出队信号</h3><p>might_hit_head得出这次访问可能会满,at_head表示tail已经和head重叠了,只有前面信号都不满足,才可以写入</p>
<blockquote>
<p>假如fb大小为8项,每次最多写入4条,最多读出四条,假设连续写入两次,这时候tail和head就重合了,表示写满了</p>
</blockquote>
<p>will_hit_tail信号揭示了head是否会和tail重合,也就是指令是否还够取(每次必须corewidth条)</p>
<blockquote>
<p>参数和上一个例子一样,假如没有读出head为01,然后tail指针为0000 1000,表示写入了三条指令,这样得出来的tail_collisions就为0000 1000,然后will_hit_tail就为高,表示内部没有四条指令(妙)</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  def rotateLeft(in: UInt, k: Int) = &#123;</span><br><span class="line">    val n = in.getWidth</span><br><span class="line">    Cat(in(n-k-1,0), in(n-1, n-k))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  val might_hit_head = (1 until fetchWidth).map(k =&gt; VecInit(rotateLeft(tail, k).asBools.zipWithIndex.filter</span><br><span class="line">    &#123;case (e,i) =&gt; i % coreWidth == 0&#125;.map &#123;case (e,i) =&gt; e&#125;).asUInt).map(tail =&gt; head &amp; tail).reduce(_|_).orR</span><br><span class="line">  val at_head = (VecInit(tail.asBools.zipWithIndex.filter &#123;case (e,i) =&gt; i % coreWidth == 0&#125;</span><br><span class="line">    .map &#123;case (e,i) =&gt; e&#125;).asUInt &amp; head).orR</span><br><span class="line">  val do_enq = !(at_head &amp;&amp; maybe_full || might_hit_head)</span><br><span class="line"></span><br><span class="line">  io.enq.ready := do_enq</span><br><span class="line">...  </span><br><span class="line">val tail_collisions = VecInit((0 until numEntries).map(i =&gt;</span><br><span class="line">                          head(i/coreWidth) &amp;&amp; (!maybe_full || (i % coreWidth != 0).B))).asUInt &amp; tail</span><br><span class="line">  val slot_will_hit_tail = (0 until numRows).map(i =&gt; tail_collisions((i+1)*coreWidth-1, i*coreWidth)).reduce(_|_)</span><br><span class="line">  val will_hit_tail = slot_will_hit_tail.orR</span><br><span class="line"></span><br><span class="line">  val do_deq = io.deq.ready &amp;&amp; !will_hit_tail</span><br></pre></td></tr></table></figure>

<h3 id="转换输入"><a href="#转换输入" class="headerlink" title="转换输入"></a>转换输入</h3><p>代码如下,注意当w&#x3D;0,需要考虑edge_inst,</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  for (b &lt;- 0 until nBanks) &#123;</span><br><span class="line">    for (w &lt;- 0 until bankWidth) &#123;</span><br><span class="line">      val i = (b * bankWidth) + w</span><br><span class="line">      val pc = (bankAlign(io.enq.bits.pc) + (i &lt;&lt; 1).U)</span><br><span class="line">      in_mask(i)                := io.enq.valid &amp;&amp; io.enq.bits.mask(i)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">      if (w == 0) &#123;</span><br><span class="line">        when (io.enq.bits.edge_inst(b)) &#123;</span><br><span class="line">          in_uops(i).debug_pc  := bankAlign(io.enq.bits.pc) + (b * bankBytes).U - 2.U</span><br><span class="line">          in_uops(i).pc_lob    := bankAlign(io.enq.bits.pc) + (b * bankBytes).U</span><br><span class="line">          in_uops(i).edge_inst := true.B</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      in_uops(i).ftq_idx        := io.enq.bits.ftq_idx</span><br><span class="line">      in_uops(i).inst           := io.enq.bits.exp_insts(i)</span><br><span class="line">      in_uops(i).debug_inst     := io.enq.bits.insts(i)</span><br><span class="line">      in_uops(i).is_rvc         := io.enq.bits.insts(i)(1,0) =/= 3.U</span><br><span class="line">      in_uops(i).taken          := io.enq.bits.cfi_idx.bits === i.U &amp;&amp; io.enq.bits.cfi_idx.valid</span><br><span class="line"></span><br><span class="line">      in_uops(i).xcpt_pf_if     := io.enq.bits.xcpt_pf_if</span><br><span class="line">      in_uops(i).xcpt_ae_if     := io.enq.bits.xcpt_ae_if</span><br><span class="line">      in_uops(i).bp_debug_if    := io.enq.bits.bp_debug_if_oh(i)</span><br><span class="line">      in_uops(i).bp_xcpt_if     := io.enq.bits.bp_xcpt_if_oh(i)</span><br><span class="line"></span><br><span class="line">      in_uops(i).debug_fsrc     := io.enq.bits.fsrc</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="生成oh写索引"><a href="#生成oh写索引" class="headerlink" title="生成oh写索引"></a>生成oh写索引</h3><p>向量大小为fetchwidth&#x3D;8,如果输入指令是有效的,就写入inc的索引,否则写入之前的值</p>
<blockquote>
<p>tail初始值为1,之后如果inc就将最高位移入最低位,哪一位为1就说明写入哪一位</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">val enq_idxs = Wire(Vec(fetchWidth, UInt(numEntries.W)))</span><br><span class="line"></span><br><span class="line">def inc(ptr: UInt) = &#123;</span><br><span class="line">  val n = ptr.getWidth</span><br><span class="line">  Cat(ptr(n-2,0), ptr(n-1))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var enq_idx = tail</span><br><span class="line">for (i &lt;- 0 until fetchWidth) &#123;</span><br><span class="line">  enq_idxs(i) := enq_idx</span><br><span class="line">  enq_idx = Mux(in_mask(i), inc(enq_idx), enq_idx)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="写入fb"><a href="#写入fb" class="headerlink" title="写入fb"></a>写入fb</h4><p>只将有效的写入fb,也就是,如果入队信号拉高,并且输入指令有效,且找到对应的写索引,就将数据写入fb</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (i &lt;- 0 until fetchWidth) &#123;</span><br><span class="line">  for (j &lt;- 0 until numEntries) &#123;</span><br><span class="line">    when (do_enq &amp;&amp; in_mask(i) &amp;&amp; enq_idxs(i)(j)) &#123;</span><br><span class="line">      ram(j) := in_uops(i)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="出队信号"><a href="#出队信号" class="headerlink" title="出队信号"></a>出队信号</h4><p>deq_vec就是把fb数据转换换为出队的,这里i&#x2F;coreWidth得出的是出去的是第几行,i%coreWidth表示的是行内的哪条uops,然后使用Mux1H选出head的前corewidth条数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Generate vec for dequeue read port.</span><br><span class="line">for (i &lt;- 0 until numEntries) &#123;</span><br><span class="line">  deq_vec(i/coreWidth)(i%coreWidth) := ram(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">io.deq.bits.uops zip deq_valids           map &#123;case (d,v) =&gt; d.valid := v&#125;</span><br><span class="line">io.deq.bits.uops zip Mux1H(head, deq_vec) map &#123;case (d,q) =&gt; d.bits  := q&#125;</span><br><span class="line">io.deq.valid := deq_valids.reduce(_||_)</span><br></pre></td></tr></table></figure>

<h4 id="指针状态更新"><a href="#指针状态更新" class="headerlink" title="指针状态更新"></a>指针状态更新</h4><p>如果入队信号来了,就修改tail指针为enq_idx,出队就inc head指针,如果clear,就重置指针</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">when (do_enq) &#123;</span><br><span class="line">  tail := enq_idx</span><br><span class="line">  when (in_mask.reduce(_||_)) &#123;</span><br><span class="line">    maybe_full := true.B</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">when (do_deq) &#123;</span><br><span class="line">  head := inc(head)</span><br><span class="line">  maybe_full := false.B</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">when (io.clear) &#123;</span><br><span class="line">  head := 1.U</span><br><span class="line">  tail := 1.U</span><br><span class="line">  maybe_full := false.B</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>这里使用oh编码来对地址编码,然后fb还通过一些特殊的方法来判断head和tail关系,十分巧妙</p>
<h2 id="分支预测器"><a href="#分支预测器" class="headerlink" title="分支预测器"></a>分支预测器</h2><p>composer模块将各个模块的请求和更新连接到IO,然后将各个模块的meta送出,</p>
<blockquote>
<p>所有模块共用meta,只不过是使用的位域不同,传入的meta同理,update信息之所以reverse,是因为低位的meta对应的是靠后的components</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var metas = 0.U(1.W)</span><br><span class="line">var meta_sz = 0</span><br><span class="line">for (c &lt;- components) &#123;</span><br><span class="line">  c.io.f0_valid  := io.f0_valid</span><br><span class="line">  c.io.f0_pc     := io.f0_pc</span><br><span class="line">  c.io.f0_mask   := io.f0_mask</span><br><span class="line">  c.io.f1_ghist  := io.f1_ghist</span><br><span class="line">  c.io.f1_lhist  := io.f1_lhist</span><br><span class="line">  c.io.f3_fire   := io.f3_fire</span><br><span class="line">  if (c.metaSz &gt; 0) &#123;</span><br><span class="line">    metas = (metas &lt;&lt; c.metaSz) | c.io.f3_meta(c.metaSz-1,0)</span><br><span class="line">  &#125;</span><br><span class="line">  meta_sz = meta_sz + c.metaSz</span><br><span class="line">&#125;</span><br><span class="line">require(meta_sz &lt; bpdMaxMetaLength)</span><br><span class="line">io.f3_meta := metas</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var update_meta = io.update.bits.meta</span><br><span class="line">for (c &lt;- components.reverse) &#123;</span><br><span class="line">  c.io.update := io.update</span><br><span class="line">  c.io.update.bits.meta := update_meta</span><br><span class="line">  update_meta = update_meta &gt;&gt; c.metaSz</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="BranchPredictor"><a href="#BranchPredictor" class="headerlink" title="BranchPredictor"></a>BranchPredictor</h3><p>分支预测器的选择都是在下面代码中,这里是分bank的,然后返回的为ComposedBranchPredictorBank</p>
<blockquote>
<p>为什么分bank?</p>
<p>respose_in是干什么的</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">val bpdStr = new StringBuilder</span><br><span class="line">bpdStr.append(BoomCoreStringPrefix(&quot;==Branch Predictor Memory Sizes==\n&quot;))</span><br><span class="line">val banked_predictors = (0 until nBanks) map ( b =&gt; &#123;</span><br><span class="line">  val m = Module(if (useBPD) new ComposedBranchPredictorBank else new NullBranchPredictorBank)</span><br><span class="line">  for ((n, d, w) &lt;- m.mems) &#123;</span><br><span class="line">    bpdStr.append(BoomCoreStringPrefix(f&quot;bank$b $n: $d x $w = $&#123;d * w / 8&#125;&quot;))</span><br><span class="line">    total_memsize = total_memsize + d * w / 8</span><br><span class="line">  &#125;</span><br><span class="line">  m</span><br><span class="line">&#125;)</span><br><span class="line">bpdStr.append(BoomCoreStringPrefix(f&quot;Total bpd size: $&#123;total_memsize / 1024&#125; KB\n&quot;))</span><br><span class="line">override def toString: String = bpdStr.toString</span><br></pre></td></tr></table></figure>

<p>然后这个bank内主要就是分发逻辑,将更新信号分发到每个预测器,以及将预测信息送出,下面代码中getBPDComponents就是获得预测器信息,然后返回预测结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">val (components, resp) = getBPDComponents(io.resp_in(0), p)</span><br><span class="line">io.resp := resp</span><br></pre></td></tr></table></figure>

<p>最终的分支预测信息来自下面代码,这是典型的TAGE_L结构,分支预测器的主要器件都包含在内</p>
<p><img src="/2025/02/05/diplomacy&boom/1732447150001.png" alt="1732447150001"></p>
<h4 id="预测请求传入"><a href="#预测请求传入" class="headerlink" title="预测请求传入"></a>预测请求传入</h4><p>预测请求分bank讨论,但这里只讨论bank为2的情况,只考虑全局历史</p>
<ol>
<li>传入请求的bank为0,这时bank0预测这个vpc,bank1预测下个bank的vpc</li>
<li>如果传入请求的bank为1,就让bank0预测下一个bank,bank预测这个bank</li>
</ol>
<p>具体代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">....</span><br><span class="line">    when (bank(io.f0_req.bits.pc) === 0.U) &#123;</span><br><span class="line">.......</span><br><span class="line"></span><br><span class="line">      banked_predictors(0).io.f0_valid := io.f0_req.valid</span><br><span class="line">      banked_predictors(0).io.f0_pc    := bankAlign(io.f0_req.bits.pc)</span><br><span class="line">      banked_predictors(0).io.f0_mask  := fetchMask(io.f0_req.bits.pc)</span><br><span class="line"></span><br><span class="line">      banked_predictors(1).io.f0_valid := io.f0_req.valid</span><br><span class="line">      banked_predictors(1).io.f0_pc    := nextBank(io.f0_req.bits.pc)</span><br><span class="line">      banked_predictors(1).io.f0_mask  := ~(0.U(bankWidth.W))</span><br><span class="line">    &#125; .otherwise &#123;</span><br><span class="line">....</span><br><span class="line">      banked_predictors(0).io.f0_valid := io.f0_req.valid &amp;&amp; !mayNotBeDualBanked(io.f0_req.bits.pc)</span><br><span class="line">      banked_predictors(0).io.f0_pc    := nextBank(io.f0_req.bits.pc)</span><br><span class="line">      banked_predictors(0).io.f0_mask  := ~(0.U(bankWidth.W))</span><br><span class="line">      banked_predictors(1).io.f0_valid := io.f0_req.valid</span><br><span class="line">      banked_predictors(1).io.f0_pc    := bankAlign(io.f0_req.bits.pc)</span><br><span class="line">      banked_predictors(1).io.f0_mask  := fetchMask(io.f0_req.bits.pc)</span><br><span class="line">    &#125;</span><br><span class="line">    when (RegNext(bank(io.f0_req.bits.pc) === 0.U)) &#123;</span><br><span class="line">      banked_predictors(0).io.f1_ghist  := RegNext(io.f0_req.bits.ghist.histories(0))</span><br><span class="line">      banked_predictors(1).io.f1_ghist  := RegNext(io.f0_req.bits.ghist.histories(1))</span><br><span class="line">    &#125; .otherwise &#123;</span><br><span class="line">      banked_predictors(0).io.f1_ghist  := RegNext(io.f0_req.bits.ghist.histories(1))</span><br><span class="line">      banked_predictors(1).io.f1_ghist  := RegNext(io.f0_req.bits.ghist.histories(0))</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="预测结果传出"><a href="#预测结果传出" class="headerlink" title="预测结果传出"></a>预测结果传出</h4><p>首先获得bank0和bank1的有效信号b0_fire,b1_fire,然后预测器送出f3阶段的预测信号,代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    val b0_fire = io.f3_fire &amp;&amp; RegNext(RegNext(RegNext(banked_predictors(0).io.f0_valid)))</span><br><span class="line">    val b1_fire = io.f3_fire &amp;&amp; RegNext(RegNext(RegNext(banked_predictors(1).io.f0_valid)))</span><br><span class="line">    banked_predictors(0).io.f3_fire := b0_fire</span><br><span class="line">    banked_predictors(1).io.f3_fire := b1_fire</span><br><span class="line"></span><br><span class="line">    banked_lhist_providers(0).io.f3_fire := b0_fire</span><br><span class="line">    banked_lhist_providers(1).io.f3_fire := b1_fire</span><br><span class="line">    // The branch prediction metadata is stored un-shuffled</span><br><span class="line">    io.resp.f3.meta(0)    := banked_predictors(0).io.f3_meta</span><br><span class="line">    io.resp.f3.meta(1)    := banked_predictors(1).io.f3_meta</span><br><span class="line"></span><br><span class="line">    io.resp.f3.lhist(0)   := banked_lhist_providers(0).io.f3_lhist</span><br><span class="line">    io.resp.f3.lhist(1)   := banked_lhist_providers(1).io.f3_lhist</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    when (bank(io.resp.f3.pc) === 0.U) &#123;</span><br><span class="line">      for (i &lt;- 0 until bankWidth) &#123;</span><br><span class="line">        io.resp.f3.preds(i)           := banked_predictors(0).io.resp.f3(i)</span><br><span class="line">        io.resp.f3.preds(i+bankWidth) := banked_predictors(1).io.resp.f3(i)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; .otherwise &#123;</span><br><span class="line">      for (i &lt;- 0 until bankWidth) &#123;</span><br><span class="line">        io.resp.f3.preds(i)           := banked_predictors(1).io.resp.f3(i)</span><br><span class="line">        io.resp.f3.preds(i+bankWidth) := banked_predictors(0).io.resp.f3(i)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="更新逻辑"><a href="#更新逻辑" class="headerlink" title="更新逻辑"></a>更新逻辑</h4><p>将输入的更新信息送入每个bank,这里给出仿真图辅助理解,指令包的起始地址80000004位于bank0,所以bank0的valid一定为1,但cfi_valid却为0,因为输入的cfi_idx为6,说明分支在第六条,不在这个bank,所以bank0的cfi_valid为0</p>
<p><img src="/2025/02/05/diplomacy&boom/1732456469917.png" alt="1732456469917"></p>
<p>接下来会基于largeboom(tage_l)来解析各个器件的主要逻辑,这些模块的IO都基于BranchPredictorBank,首先就是输入的分支预测请求,然后有预测信号resp,还有就是更新信号update,这三个信号是核心信号</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">val io = IO(new Bundle &#123;</span><br><span class="line">  val f0_valid = Input(Bool())</span><br><span class="line">  val f0_pc    = Input(UInt(vaddrBitsExtended.W))</span><br><span class="line">  val f0_mask  = Input(UInt(bankWidth.W))</span><br><span class="line">  // Local history not available until end of f1</span><br><span class="line">  val f1_ghist = Input(UInt(globalHistoryLength.W))</span><br><span class="line">  val f1_lhist = Input(UInt(localHistoryLength.W))</span><br><span class="line"></span><br><span class="line">  val resp_in = Input(Vec(nInputs, new BranchPredictionBankResponse))</span><br><span class="line">  val resp = Output(new BranchPredictionBankResponse)</span><br><span class="line"></span><br><span class="line">  // Store the meta as a UInt, use width inference to figure out the shape</span><br><span class="line">  val f3_meta = Output(UInt(bpdMaxMetaLength.W))</span><br><span class="line"></span><br><span class="line">  val f3_fire = Input(Bool())</span><br><span class="line"></span><br><span class="line">  val update = Input(Valid(new BranchPredictionBankUpdate))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="NLP分支预测"><a href="#NLP分支预测" class="headerlink" title="NLP分支预测"></a>NLP分支预测</h3><p>NLP的分支预测结构由BIM表,RAS和BTB组成,如过查询BTB是ret,说明目标来自RAS,如果条目是无条件跳转,不查询BIM,</p>
<h4 id="UBTB"><a href="#UBTB" class="headerlink" title="UBTB"></a>UBTB</h4><p><img src="/2025/02/05/diplomacy&boom/1732457973586.png" alt="1732457973586"></p>
<p>每个BTB条目对应的tag都是整个fetch_packet的pc这样的预测粒度就是一整个packet,当前端或者BPD被重定向,BTB更新,如果分支没找到条目,就分配一个条目</p>
<blockquote>
<p>BTB更新的tricky:</p>
</blockquote>
<p>UBTB默认参数如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">case class BoomFAMicroBTBParams(</span><br><span class="line">  nWays: Int = 16,</span><br><span class="line">  offsetSz: Int = 13</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h5 id="预测逻辑"><a href="#预测逻辑" class="headerlink" title="预测逻辑"></a>预测逻辑</h5><p>首先检查是否hitBTB,如果hit,就预测地址,从btb取出偏移量,得出最终地址,同时得出是br还是jal,以及是否taken,br默认不taken</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  for (w &lt;- 0 until bankWidth) &#123;</span><br><span class="line">    val entry_meta = meta(s1_hit_ways(w))(w)</span><br><span class="line">    s1_resp(w).valid := s1_valid &amp;&amp; s1_hits(w)</span><br><span class="line">    s1_resp(w).bits  := (s1_pc.asSInt + (w &lt;&lt; 1).S + btb(s1_hit_ways(w))(w).offset).asUInt</span><br><span class="line">    s1_is_br(w)      := s1_resp(w).valid &amp;&amp;  entry_meta.is_br</span><br><span class="line">    s1_is_jal(w)     := s1_resp(w).valid &amp;&amp; !entry_meta.is_br</span><br><span class="line">    s1_taken(w)      := !entry_meta.is_br || entry_meta.ctr(1)</span><br><span class="line"></span><br><span class="line">    s1_meta.hits(w)     := s1_hits(w)</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br><span class="line">  for (w &lt;- 0 until bankWidth) &#123;</span><br><span class="line">    io.resp.f1(w).predicted_pc := s1_resp(w)</span><br><span class="line">    io.resp.f1(w).is_br        := s1_is_br(w)</span><br><span class="line">    io.resp.f1(w).is_jal       := s1_is_jal(w)</span><br><span class="line">    io.resp.f1(w).taken        := s1_taken(w)</span><br><span class="line"></span><br><span class="line">    io.resp.f2(w) := RegNext(io.resp.f1(w))</span><br><span class="line">    io.resp.f3(w) := RegNext(io.resp.f2(w))</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>如果未命中,就会采用下面的分配逻辑,</p>
<blockquote>
<p>这个分配逻辑暂时未搞明白是什么,可能涉及到了折叠,可以看分支历史的折叠</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">val alloc_way = &#123;</span><br><span class="line">  val r_metas = Cat(VecInit(meta.map(e =&gt; VecInit(e.map(_.tag)))).asUInt, s1_idx(tagSz-1,0))</span><br><span class="line">  val l = log2Ceil(nWays)</span><br><span class="line">  val nChunks = (r_metas.getWidth + l - 1) / l</span><br><span class="line">  val chunks = (0 until nChunks) map &#123; i =&gt;</span><br><span class="line">    r_metas(min((i+1)*l, r_metas.getWidth)-1, i*l)</span><br><span class="line">  &#125;</span><br><span class="line">  chunks.reduce(_^_)</span><br><span class="line">&#125;</span><br><span class="line">s1_meta.write_way := Mux(s1_hits.reduce(_||_),</span><br><span class="line">  PriorityEncoder(s1_hit_ohs.map(_.asUInt).reduce(_|_)),</span><br><span class="line">  alloc_way)</span><br></pre></td></tr></table></figure>

<h5 id="更新逻辑-1"><a href="#更新逻辑-1" class="headerlink" title="更新逻辑"></a>更新逻辑</h5><p>BTB的更新主要分为更新offset和更新标签,更新offset,只要找到需要更新的way,然后将数据,传入这个way就可以,</p>
<p>更新meta,主要看ctr计数器,如果一开始这一项在预测时没有命中(新分配的项),则先初始化ctr,否则即使根据was_taken更新这个ctr计数器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Write the BTB with the target</span><br><span class="line">when (s1_update.valid &amp;&amp; s1_update.bits.cfi_taken &amp;&amp; s1_update.bits.cfi_idx.valid &amp;&amp; s1_update.bits.is_commit_update) &#123;</span><br><span class="line">  btb(s1_update_write_way)(s1_update_cfi_idx).offset := new_offset_value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Write the meta</span><br><span class="line">for (w &lt;- 0 until bankWidth) &#123;</span><br><span class="line">  when (s1_update.valid &amp;&amp; s1_update.bits.is_commit_update &amp;&amp;</span><br><span class="line">    (s1_update.bits.br_mask(w) ||</span><br><span class="line">      (s1_update_cfi_idx === w.U &amp;&amp; s1_update.bits.cfi_taken &amp;&amp; s1_update.bits.cfi_idx.valid))) &#123;</span><br><span class="line">    val was_taken = (s1_update_cfi_idx === w.U &amp;&amp; s1_update.bits.cfi_idx.valid &amp;&amp;</span><br><span class="line">      (s1_update.bits.cfi_taken || s1_update.bits.cfi_is_jal))</span><br><span class="line"></span><br><span class="line">    meta(s1_update_write_way)(w).is_br := s1_update.bits.br_mask(w)</span><br><span class="line">    meta(s1_update_write_way)(w).tag   := s1_update_idx</span><br><span class="line">    meta(s1_update_write_way)(w).ctr   := Mux(!s1_update_meta.hits(w),</span><br><span class="line">      Mux(was_taken, 3.U, 0.U),</span><br><span class="line">      bimWrite(meta(s1_update_write_way)(w).ctr, was_taken)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="BIM"><a href="#BIM" class="headerlink" title="BIM"></a>BIM</h4><p>BIM使用pc一部分索引,只在提交时更新(饱和计数器,即使少更新,只要训练到位,预测结果大差不差)</p>
<h5 id="方向预测逻辑"><a href="#方向预测逻辑" class="headerlink" title="方向预测逻辑"></a>方向预测逻辑</h5><p>BIM的默认set为2048,并且BIMset只能为2的幂次方,该预测器在f2阶段之后可以给出结果,s2阶段的resp就是预测方向信息,如果s2阶段有效,并且这个bank读出的bim表的项第1位为1,表示taken,否则为0</p>
<blockquote>
<p>注意,这里感觉浪费了空间,因为BIM的写入都是对每个w写入相同内容,而且读出也是相同,所以每个w读出的也是一样的</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  val s2_req_rdata    = RegNext(data.read(s0_idx   , s0_valid))</span><br><span class="line"></span><br><span class="line">  val s2_resp         = Wire(Vec(bankWidth, Bool()))</span><br><span class="line"></span><br><span class="line">  for (w &lt;- 0 until bankWidth) &#123;</span><br><span class="line"></span><br><span class="line">    s2_resp(w)        := s2_valid &amp;&amp; s2_req_rdata(w)(1) &amp;&amp; !doing_reset</span><br><span class="line">    s2_meta.bims(w)   := s2_req_rdata(w)</span><br><span class="line">  &#125;</span><br><span class="line">... </span><br><span class="line"> for (w &lt;- 0 until bankWidth) &#123;</span><br><span class="line">    io.resp.f2(w).taken := s2_resp(w)</span><br><span class="line">    io.resp.f3(w).taken := RegNext(io.resp.f2(w).taken)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h5 id="更新逻辑-2"><a href="#更新逻辑-2" class="headerlink" title="更新逻辑"></a>更新逻辑</h5><p>更新是在f1阶段,如果一个bank里有br指令(taken)或者jal,就说明taken,旧的BIM值是传入的重定向值,或者就是之前的bypass值</p>
<blockquote>
<p>这里设置bypass主要就是为了减少SRAM访问次数,如果上次更新的数据idx和这次的一样,就直接把上次的值作为旧的值,否则就是之前读出的值(只有commit时才可以更新这个bypass值)</p>
</blockquote>
<p>s1_update_wdata更新计数器的值,然后在提交时写入data,</p>
<blockquote>
<p>old_bim_value要得到的是正确的旧值,s1_update_meta可能是分支预测失败时传来的update值,bypass是提交的值,数据一定正确,而写入又是在提交阶段,所以old_value一定是正确的值,另一种做法就是在提交直接读出旧值,不过可能引入多余的延迟</p>
</blockquote>
<blockquote>
<p>为什么s1阶段更新,s2阶段给出预测结果?一方面防止同时读写,另一方面,s1阶段更新,s2阶段就可以享受到更新的结果</p>
</blockquote>
<blockquote>
<p>注意这里更新逻辑条件包括了jal&#x2F;jalr指令,看之前的issue,说这个地方不对,但目前都没改</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (w &lt;- 0 until bankWidth) &#123;</span><br><span class="line">  s1_update_wmask(w)         := false.B</span><br><span class="line">  s1_update_wdata(w)         := DontCare</span><br><span class="line"></span><br><span class="line">  val update_pc = s1_update.bits.pc + (w &lt;&lt; 1).U</span><br><span class="line"></span><br><span class="line">  when (s1_update.bits.br_mask(w) ||</span><br><span class="line">    (s1_update.bits.cfi_idx.valid &amp;&amp; s1_update.bits.cfi_idx.bits === w.U)) &#123;</span><br><span class="line">    val was_taken = (</span><br><span class="line">      s1_update.bits.cfi_idx.valid &amp;&amp;</span><br><span class="line">      (s1_update.bits.cfi_idx.bits === w.U) &amp;&amp;</span><br><span class="line">      (</span><br><span class="line">        (s1_update.bits.cfi_is_br &amp;&amp; s1_update.bits.br_mask(w) &amp;&amp; s1_update.bits.cfi_taken) ||</span><br><span class="line">        s1_update.bits.cfi_is_jal</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line">    val old_bim_value = Mux(wrbypass_hit, wrbypass(wrbypass_hit_idx)(w), s1_update_meta.bims(w))</span><br><span class="line"></span><br><span class="line">    s1_update_wmask(w)     := true.B</span><br><span class="line"></span><br><span class="line">    s1_update_wdata(w)     := bimWrite(old_bim_value, was_taken)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">when (doing_reset || (s1_update.valid &amp;&amp; s1_update.bits.is_commit_update)) &#123;</span><br><span class="line">  data.write(</span><br><span class="line">    Mux(doing_reset, reset_idx, s1_update_index),</span><br><span class="line">    Mux(doing_reset, VecInit(Seq.fill(bankWidth) &#123; 2.U &#125;), s1_update_wdata),</span><br><span class="line">    Mux(doing_reset, (~(0.U(bankWidth.W))), s1_update_wmask.asUInt).asBools</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="RAS"><a href="#RAS" class="headerlink" title="RAS"></a>RAS</h4><p>RAS的逻辑比较简单,主要分为读逻辑和写逻辑</p>
<p>读RAS在f3阶段,判断指令是否为ret,写RAS在ftq传入更新RAS信息或者f3阶段的指令为call指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class BoomRAS(implicit p: Parameters) extends BoomModule()(p)</span><br><span class="line">&#123;</span><br><span class="line">  val io = IO(new Bundle &#123;</span><br><span class="line">    val read_idx   = Input(UInt(log2Ceil(nRasEntries).W))</span><br><span class="line">    val read_addr  = Output(UInt(vaddrBitsExtended.W))</span><br><span class="line"></span><br><span class="line">    val write_valid = Input(Bool())</span><br><span class="line">    val write_idx   = Input(UInt(log2Ceil(nRasEntries).W))</span><br><span class="line">    val write_addr  = Input(UInt(vaddrBitsExtended.W))</span><br><span class="line">  &#125;)</span><br><span class="line">  val ras = Reg(Vec(nRasEntries, UInt(vaddrBitsExtended.W)))</span><br><span class="line"></span><br><span class="line">  io.read_addr := Mux(RegNext(io.write_valid &amp;&amp; io.write_idx === io.read_idx),</span><br><span class="line">    RegNext(io.write_addr),</span><br><span class="line">    RegNext(ras(io.read_idx)))</span><br><span class="line"></span><br><span class="line">  when (io.write_valid) &#123;</span><br><span class="line">    ras(io.write_idx) := io.write_addr</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="BPD"><a href="#BPD" class="headerlink" title="BPD"></a>BPD</h3><p>BPD仅仅对条件分支的方向进行预测,其他信息,比如那些指令是分支,目标是什么,无需在意,这些信息可以从BTB得知,所以BPD无需存储tag和分支目标地址,jal和jalr指令均由NLP预测,如果NLP预测失败,只能之后重定向</p>
<p><img src="/2025/02/05/diplomacy&boom/1732524502617.png" alt="1732524502617"></p>
<p>BPD在f3给出结果,f4进行重定向,</p>
<p>BPD采用全局历史,GHR进行推测更新,每个分支都有GHR快照,同时在BPD维护提交阶段的GHR</p>
<blockquote>
<p><strong>请注意，在F0</strong>阶段开始进行预测（读取全局历史记录时）和在F4阶段重定向<a href="https://docs.boom-core.org/en/latest/sections/terminology.html#term-front-end">前端</a>（更新全局历史记录时）之间存在延迟。这会导致“影子”，其中在F0中开始进行预测的分支将看不到程序中一个（或两个）周期之前出现的分支（或其结果）（目前处于F1&#x2F;2&#x2F;3阶段）。但至关重要的是，这些“影子分支”必须反映在全局历史快照中。</p>
</blockquote>
<blockquote>
<p>每个<a href="https://docs.boom-core.org/en/latest/sections/terminology.html#term-fetch-target-queue-ftq">FTQ</a>条目对应一个<strong>提取</strong>周期。对于每次预测，分支预测器都会打包稍后执行更新所需的数据。例如，分支预测器需要记住预测来自哪个 <em>索引，以便稍后更新该索引处的计数器。此数据存储在</em><a href="https://docs.boom-core.org/en/latest/sections/terminology.html#term-fetch-target-queue-ftq">FTQ</a>中。<a href="https://docs.boom-core.org/en/latest/sections/terminology.html#term-fetch-packet">当Fetch Packet</a>中的最后一条指令被提交时，<a href="https://docs.boom-core.org/en/latest/sections/terminology.html#term-fetch-target-queue-ftq">FTQ条目将被释放并返回到分支预测器。使用存储在</a><a href="https://docs.boom-core.org/en/latest/sections/terminology.html#term-fetch-target-queue-ftq">FTQ</a>条目中的数据，分支预测器可以对其预测状态执行任何所需的更新。</p>
</blockquote>
<blockquote>
<p>FTQ保存着在提交期间更新分支预测器所需的分支预测器数据（无论是<a href="https://docs.boom-core.org/en/latest/sections/terminology.html#term-fetch-target-queue-ftq">正确</a>预测还是错误预测）。但是，当分支预测器做出错误预测时，需要额外的状态，必须立即更新。例如，如果发生错误预测，则必须将推测更新的GHR重置为正确值，然后处理器才能再次开始提取（和预测）。<a href="https://docs.boom-core.org/en/latest/sections/terminology.html#term-global-history-register-ghr"></a></p>
</blockquote>
<blockquote>
<p><strong>此状态可能非常昂贵，但一旦在执行</strong>阶段解析了分支，就可以释放它。因此，状态与<a href="https://docs.boom-core.org/en/latest/sections/terminology.html#term-branch-rename-snapshot">分支重命名</a>快照并行存储。在<strong>解码</strong> 和<strong>重命名</strong>期间，会为每个分支分配一个 <strong>分支标记</strong> ，并制作重命名表的快照，以便在发生错误预测时进行单周期回滚。与分支标记和<strong>重命名映射表</strong>快照一样， 一旦分支在 执行阶段由分支单元解析，就可以释放相应的<a href="https://docs.boom-core.org/en/latest/sections/terminology.html#term-branch-rename-snapshot">分支重命名快照</a>。</p>
</blockquote>
<h5 id="抽象分支类"><a href="#抽象分支类" class="headerlink" title="抽象分支类"></a>抽象分支类</h5><p><img src="/2025/02/05/diplomacy&boom/1732526267100.png" alt="1732526267100"></p>
<h4 id="TAGE"><a href="#TAGE" class="headerlink" title="TAGE"></a>TAGE</h4><p>TAGE的默认参数如下.可以看到BOOM例化了6个表,最大历史长度为64,并且ubit的更新周期为2048个周期,饱和计数器为3bits,user为2bit,</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">case class BoomTageParams(</span><br><span class="line">  //                                           nSets, histLen, tagSz</span><br><span class="line">  tableInfo: Seq[Tuple3[Int, Int, Int]] = Seq((  128,       2,     7),</span><br><span class="line">                                              (  128,       4,     7),</span><br><span class="line">                                              (  256,       8,     8),</span><br><span class="line">                                              (  256,      16,     8),</span><br><span class="line">                                              (  128,      32,     9),</span><br><span class="line">                                              (  128,      64,     9)),</span><br><span class="line">  uBitPeriod: Int = 2048</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="TageTable"><a href="#TageTable" class="headerlink" title="TageTable"></a>TageTable</h5><p><strong>预测阶段</strong></p>
<p>首先计算出hash_idx,根据该idx得出ctr和user_bit以及tag,然后将读出的信息传入tage进一步处理</p>
<p><strong>写入逻辑</strong></p>
<p>写入逻辑主要写入userbit,table</p>
<p><strong>table:写入提交阶段传入的update_idx(这里的update同样有bypass)</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">table.write(</span><br><span class="line">  Mux(doing_reset, reset_idx                                          , update_idx),</span><br><span class="line">  Mux(doing_reset, VecInit(Seq.fill(bankWidth) &#123; 0.U(tageEntrySz.W) &#125;), VecInit(update_wdata.map(_.asUInt))),</span><br><span class="line">  Mux(doing_reset, ~(0.U(bankWidth.W))                                , io.update_mask.asUInt).asBools</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>user_bit分为两个段:hi和lo,主要讲hi:</p>
<p>写入的idx来自reset_idx,clear_idx和update_idx,user_bit需要定期清0,clear前缀的就是清零有关信号,这里就是每2048个周期就去清零高位或者低位,</p>
<blockquote>
<p>由于是sram结构,一周期只能读1写1,所以也没啥问题,但为啥不同时清0hi和lo,猜想可能是先缓冲一下</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  val doing_clear_u = clear_u_ctr(log2Ceil(uBitPeriod)-1,0) === 0.U</span><br><span class="line">  val doing_clear_u_hi = doing_clear_u &amp;&amp; clear_u_ctr(log2Ceil(uBitPeriod) + log2Ceil(nRows)) === 1.U</span><br><span class="line">  val doing_clear_u_lo = doing_clear_u &amp;&amp; clear_u_ctr(log2Ceil(uBitPeriod) + log2Ceil(nRows)) === 0.U</span><br><span class="line">  val clear_u_idx = clear_u_ctr &gt;&gt; log2Ceil(uBitPeriod)</span><br><span class="line">...  </span><br><span class="line">hi_us.write(</span><br><span class="line">    Mux(doing_reset, reset_idx, Mux(doing_clear_u_hi, clear_u_idx, update_idx)),</span><br><span class="line">    Mux(doing_reset || doing_clear_u_hi, VecInit((0.U(bankWidth.W)).asBools), update_hi_wdata),</span><br><span class="line">    Mux(doing_reset || doing_clear_u_hi, ~(0.U(bankWidth.W)), io.update_u_mask.asUInt).asBools</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>

<h5 id="TAGE主要逻辑"><a href="#TAGE主要逻辑" class="headerlink" title="TAGE主要逻辑"></a>TAGE主要逻辑</h5><p>首先，定义所有产生tag匹配的预测表中所需历史长度最长者为provider，而其余产生tag匹配的预测表（若存在的话）被称为altpred。</p>
<ol>
<li>当provider产生的预测被证实为一个正确的预测时，首先将产生的正确预测的对应provider表项的pred计数器自增1。其次，若此时的provider与altpred的预测结果不同，则provider的userfulness计数器自增1。</li>
<li>当provider产生的预测被证实为一个错误的预测时，首先将产生的错误预测的对应provider表项的pred预测器自减1。其次，若存在产生正确预测的altpred，则provider的usefulness计数器自减1。接下来，若该provider所源自的预测表并非所需历史长度最高的预测表，则此时执行如下的表项增添操作。首先，读取所有历史长度长于provider的预测表的usefulness计数器，若此时有某表的u计数器值为0，则在该表中分配一对应的表项。当有多个预测表（如Tj,Tk两项）的u计数器均为0，则将表项分配给Tk的几率为分配给Tj的2^(k-j)倍（这一概率分配在硬件上可以通过一个LFSR来实现）。若所有TAGE内预测表的u值均不为0，则所有预测表的u值同时减1。</li>
<li>只有provider和altpred的预测不同时才会更新</li>
</ol>
<h6 id="预测逻辑-1"><a href="#预测逻辑-1" class="headerlink" title="预测逻辑"></a>预测逻辑</h6><p>tage预测逻辑分为provider,和altpred,其中provider为历史最长的tag命中对应的table,altpred则是次高历史命中对应的table,如果table没有命中,则选择默认的结果,源论文为bim表得出的结果</p>
<blockquote>
<p>这里暂时不清楚默认预测器是什么,应该也是bim表</p>
</blockquote>
<p>这里首先遍历所有历史表,如果table hit,就将选择taken结果,如果ctr &#x3D;&#x3D;&#x3D;3.U|| ctr &#x3D;&#x3D;&#x3D;4.U,认为这个provider不可信,选择altpred的结果作为预测结果,否则选择ctr(2)为预测结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var altpred = io.resp_in(0).f3(w).taken</span><br><span class="line">val final_altpred = WireInit(io.resp_in(0).f3(w).taken)</span><br><span class="line">var provided = false.B</span><br><span class="line">var provider = 0.U</span><br><span class="line">io.resp.f3(w).taken := io.resp_in(0).f3(w).taken</span><br><span class="line">//</span><br><span class="line">for (i &lt;- 0 until tageNTables) &#123;</span><br><span class="line">  val hit = f3_resps(i)(w).valid</span><br><span class="line">  val ctr = f3_resps(i)(w).bits.ctr</span><br><span class="line">  when (hit) &#123;</span><br><span class="line">    io.resp.f3(w).taken := Mux(ctr === 3.U || ctr === 4.U, altpred, ctr(2))//预测可能不准</span><br><span class="line">    final_altpred       := altpred</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  provided = provided || hit</span><br><span class="line">  provider = Mux(hit, i.U, provider)</span><br><span class="line">  altpred  = Mux(hit, f3_resps(i)(w).bits.ctr(2), altpred)</span><br><span class="line">&#125;</span><br><span class="line">f3_meta.provider(w).valid := provided</span><br><span class="line">f3_meta.provider(w).bits  := provider</span><br><span class="line">f3_meta.alt_differs(w)    := final_altpred =/= io.resp.f3(w).taken//有预测未命中的项</span><br><span class="line">f3_meta.provider_u(w)     := f3_resps(provider)(w).bits.u</span><br><span class="line">f3_meta.provider_ctr(w)   := f3_resps(provider)(w).bits.ctr</span><br></pre></td></tr></table></figure>

<h6 id="更新逻辑-3"><a href="#更新逻辑-3" class="headerlink" title="更新逻辑"></a>更新逻辑</h6><p>更新阶段就是去更新ctr和u计数器,如果预测失败可能还会去分配新的表项</p>
<p>allocatable_slots就是找到未命中并且u为0的slot,如果这个多于一个,就通过LSFR大概率选择分支历史长的,这样就得到了要分配的table表项,如果是提交阶段更新,并且是条件分支指令,如果此时provider是有效的,就将信息写入对应的table,然后更新u_bit,以及ctr计数器,代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">val allocatable_slots = (</span><br><span class="line">  VecInit(f3_resps.map(r =&gt; !r(w).valid &amp;&amp; r(w).bits.u === 0.U)).asUInt &amp;</span><br><span class="line">  ~(MaskLower(UIntToOH(provider)) &amp; Fill(tageNTables, provided))</span><br><span class="line">)</span><br><span class="line">val alloc_lfsr = random.LFSR(tageNTables max 2)//如果u=0的个数大于1,使用LSFR选择,概率是历史长的大于历史短的</span><br><span class="line"></span><br><span class="line">val first_entry = PriorityEncoder(allocatable_slots)</span><br><span class="line">val masked_entry = PriorityEncoder(allocatable_slots &amp; alloc_lfsr)</span><br><span class="line">val alloc_entry = Mux(allocatable_slots(masked_entry),</span><br><span class="line">  masked_entry,</span><br><span class="line">  first_entry)</span><br><span class="line"></span><br><span class="line">f3_meta.allocate(w).valid := allocatable_slots =/= 0.U</span><br><span class="line">f3_meta.allocate(w).bits  := alloc_entry</span><br><span class="line"></span><br><span class="line">val update_was_taken = (s1_update.bits.cfi_idx.valid &amp;&amp;</span><br><span class="line">                        (s1_update.bits.cfi_idx.bits === w.U) &amp;&amp;</span><br><span class="line">                        s1_update.bits.cfi_taken)</span><br><span class="line">when (s1_update.bits.br_mask(w) &amp;&amp; s1_update.valid &amp;&amp; s1_update.bits.is_commit_update) &#123;</span><br><span class="line">  when (s1_update_meta.provider(w).valid) &#123;</span><br><span class="line">    val provider = s1_update_meta.provider(w).bits</span><br><span class="line"></span><br><span class="line">    s1_update_mask(provider)(w) := true.B</span><br><span class="line">    s1_update_u_mask(provider)(w) := true.B</span><br><span class="line"></span><br><span class="line">    val new_u = inc_u(s1_update_meta.provider_u(w),</span><br><span class="line">                      s1_update_meta.alt_differs(w),</span><br><span class="line">                      s1_update_mispredict_mask(w))</span><br><span class="line">    s1_update_u      (provider)(w) := new_u</span><br><span class="line">    s1_update_taken  (provider)(w) := update_was_taken</span><br><span class="line">    s1_update_old_ctr(provider)(w) := s1_update_meta.provider_ctr(w)</span><br><span class="line">    s1_update_alloc  (provider)(w) := false.B</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="分配逻辑"><a href="#分配逻辑" class="headerlink" title="分配逻辑"></a>分配逻辑</h6><p>分配阶段其实是在更新阶段内的,但有自己独特的操作,故列出单讲</p>
<p>首先分配表项是在提交阶段,发现provider预测失败,并且这个表项的表不是分支历史最长的表,进行表项分配,如果找到了可以分配的表项,就对表项分配,并且将对应的table表项u置为0,如果没有找到表项,就将符合条件的表项u置为0,但是不分配表项</p>
<blockquote>
<p>分配还会初始化ctr,原论文中新分配的表项为弱taken(4),这里只有这次更新taken才为4,否则为3</p>
</blockquote>
<blockquote>
<p>这里好像boom和源论文做法不一样,原论文是将ubit递减,而不是直接置为0</p>
</blockquote>
<p>主要代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">when (s1_update.valid &amp;&amp; s1_update.bits.is_commit_update &amp;&amp; s1_update.bits.cfi_mispredicted &amp;&amp; s1_update.bits.cfi_idx.valid) &#123;</span><br><span class="line">  val idx = s1_update.bits.cfi_idx.bits</span><br><span class="line">  val allocate = s1_update_meta.allocate(idx)</span><br><span class="line">  when (allocate.valid) &#123;</span><br><span class="line">    s1_update_mask (allocate.bits)(idx) := true.B</span><br><span class="line">    s1_update_taken(allocate.bits)(idx) := s1_update.bits.cfi_taken</span><br><span class="line">    s1_update_alloc(allocate.bits)(idx) := true.B</span><br><span class="line"></span><br><span class="line">    s1_update_u_mask(allocate.bits)(idx) := true.B</span><br><span class="line">    s1_update_u     (allocate.bits)(idx) := 0.U</span><br><span class="line"></span><br><span class="line">  &#125; .otherwise &#123;</span><br><span class="line">    val provider = s1_update_meta.provider(idx)</span><br><span class="line">    val decr_mask = Mux(provider.valid, ~MaskLower(UIntToOH(provider.bits)), 0.U)</span><br><span class="line"></span><br><span class="line">    for (i &lt;- 0 until tageNTables) &#123;</span><br><span class="line">      when (decr_mask(i)) &#123;</span><br><span class="line">        s1_update_u_mask(i)(idx) := true.B</span><br><span class="line">        s1_update_u     (i)(idx) := 0.U</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>目前前端逻辑还没搞明白ghist内部信号到底什么含义,还有wrbypass是为了干什么</p>
<blockquote>
<p>举个例子理解wrbypass,</p>
<p>假设下面指令:</p>
<p>test:	addi a1,a1,1</p>
<p>bne a1,a2,test</p>
<p>提交阶段可能是</p>
<p>假设bne为指令包1,addi,bne为指令包2,那么有</p>
<p>bne		|addi,bne				|</p>
<p>s0		|s1					|s2</p>
<p>|指令包1写入新的bim值	|写入完成,同时也写入bypass内</p>
<p>|					|指令包2写入新的bim值,此时旧的bim值来自bypass的,本身带的bim值太老</p>
<p>上面这种情况就解释了wrbypass的作用:及时的更新正确的bim值,防止出现performance bug</p>
</blockquote>
<blockquote>
<p>ghist是推测更新,也就是在分支预测每个阶段都会更新:</p>
<p>在f1阶段,这主要是UBTB,如果是br指令并且taken,就更新ghist</p>
<p>f2阶段是bim的结果,bim实际上也不需要使用ghist,f2阶段预测的按理一定是br分支,但boom加入了jal,绝对会对ghr产生影响</p>
<p>f3阶段是tage预测阶段,这个阶段ghist才有作用,</p>
<p>在f2和f3对之前的分支预测目标和方向进行检查,只要一个不满足,就重定向</p>
<p>之后就是后端传来的重定向信号,</p>
</blockquote>
<h1 id="分支预测全流程"><a href="#分支预测全流程" class="headerlink" title="分支预测全流程"></a>分支预测全流程</h1><p>分支指令在boom中会经过预测&#x2F;推测更新阶段(ifu)-&gt;检测&#x2F;重定向阶段(exu)-&gt;更新阶段,boom采用的checkpoint来恢复CPU状态,每个分支都有自己的掩码,分支预测失败根据这个掩码定向冲刷指令,更新,刷新,重定向前端,</p>
<h2 id="预测阶段"><a href="#预测阶段" class="headerlink" title="预测阶段"></a>预测阶段</h2><p>分支指令的预测阶段主要在F1,F2,F3阶段.这三个阶段会送出BPD的预测信息,并进行重定向操作,这个可以看之前IFU流水线讲解的F0阶段和F1阶段</p>
<blockquote>
<p>目前的问题是,一个fetchpacket可能有多条分支指令,如何去正确记录分支历史,比如bne,bne 指令包.前一个不taken,后一个taken,这时候就要正确记录之前没有taken的指令历史,可能这个是按照bank更新分支历史,</p>
<p>分支预测是将一个指令包的指令全部送进去预测,分别得出结果</p>
</blockquote>
<p>预测阶段每个周期都会有新的ghist生成,比如在f3阶段有f3_predicted_ghist,这个就是更新后的历史,注意这个存的还是旧历史,但分支的taken信息已经包含在内了,假如f3 taken,对前面重定向,f1_predicted_ghist,读出的旧历史就是f3阶段更新后的历史(他会延迟更新,等到其他的去update,才会更新旧值)</p>
<blockquote>
<p>注意,此时存入ftq的ghist不是f3_predicted_ghist,而是f3_fetch_bundle.ghist,也就是相当于只存入的旧值,并未存入taken信息</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">val f3_predicted_ghist = f3_fetch_bundle.ghist.update(</span><br><span class="line">  f3_fetch_bundle.br_mask,</span><br><span class="line">  f3_fetch_bundle.cfi_idx.valid,</span><br><span class="line">  f3_fetch_bundle.br_mask(f3_fetch_bundle.cfi_idx.bits),</span><br><span class="line">  f3_fetch_bundle.cfi_idx.bits,</span><br><span class="line">  f3_fetch_bundle.cfi_idx.valid,</span><br><span class="line">  f3_fetch_bundle.pc,</span><br><span class="line">  f3_fetch_bundle.cfi_is_call,</span><br><span class="line">  f3_fetch_bundle.cfi_is_ret</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="检测阶段"><a href="#检测阶段" class="headerlink" title="检测阶段"></a>检测阶段</h2><p>(alu)这里主要对br指令进行了检测,br或者jalr,目标地址可能出错,所以会对方向检测,如果pc_sel为npc,就说明实际不taken,预测失败就说明前端预测taken,如果为PC_BRJMP就说明实际taken,就需要对预测的taken信号取反</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">when (is_br || is_jalr) &#123;</span><br><span class="line">   if (!isJmpUnit) &#123;</span><br><span class="line">     assert (pc_sel =/= PC_JALR)</span><br><span class="line">   &#125;</span><br><span class="line">   when (pc_sel === PC_PLUS4) &#123;</span><br><span class="line">     mispredict := uop.taken</span><br><span class="line">   &#125;</span><br><span class="line">   when (pc_sel === PC_BRJMP) &#123;</span><br><span class="line">     mispredict := !uop.taken</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> val brinfo = Wire(new BrResolutionInfo)</span><br><span class="line"> // note: jal doesn&#x27;t allocate a branch-mask, so don&#x27;t clear a br-mask bit</span><br><span class="line"> brinfo.valid          := is_br || is_jalr</span><br><span class="line"> brinfo.mispredict     := mispredict</span><br><span class="line"> brinfo.uop            := uop</span><br><span class="line"> brinfo.cfi_type       := Mux(is_jalr, CFI_JALR,</span><br><span class="line">                          Mux(is_br  , CFI_BR, CFI_X))</span><br><span class="line"> brinfo.taken          := is_taken</span><br><span class="line"> brinfo.pc_sel         := pc_sel</span><br><span class="line"> brinfo.jalr_target    := DontCare</span><br></pre></td></tr></table></figure>

<p>如果此时发生分支预测失败,就将分支预测失败路径指令全部删除,并且重定向前端,修改前端信息,重定向信息分为b1,b2,其中b1是在第一个周期br_mask,b2就是携带了重定向信息(第二个周期),</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">val b1 = new BrUpdateMasks</span><br><span class="line">// On the second cycle we get indices to reset pointers</span><br><span class="line">val b2 = new BrResolutionInfo</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在core.scala中,如果发现了mispredict,就要得出真正预测的目标,以及重定向信号</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">val use_same_ghist = (brupdate.b2.cfi_type === CFI_BR &amp;&amp;//只有条件分支预测方向</span><br><span class="line">                      !brupdate.b2.taken &amp;&amp;//实际不用跳转</span><br><span class="line">                      bankAlign(block_pc) === bankAlign(npc))//最后一个条件意思是npc也在这个block内,如果是这样,那抹其实不需要更新ghist,</span><br><span class="line">val ftq_entry = io.ifu.get_pc(1).entry</span><br><span class="line">val cfi_idx = (brupdate.b2.uop.pc_lob ^</span><br><span class="line">  Mux(ftq_entry.start_bank === 1.U, 1.U &lt;&lt; log2Ceil(bankBytes), 0.U))(log2Ceil(fetchWidth), 1)//得到这个分支的位置</span><br><span class="line">val ftq_ghist = io.ifu.get_pc(1).ghist</span><br><span class="line">val next_ghist = ftq_ghist.update(</span><br><span class="line">  ftq_entry.br_mask.asUInt,</span><br><span class="line">  brupdate.b2.taken,</span><br><span class="line">  brupdate.b2.cfi_type === CFI_BR,</span><br><span class="line">  cfi_idx,</span><br><span class="line">  true.B,</span><br><span class="line">  io.ifu.get_pc(1).pc,</span><br><span class="line">  ftq_entry.cfi_is_call &amp;&amp; ftq_entry.cfi_idx.bits === cfi_idx,</span><br><span class="line">  ftq_entry.cfi_is_ret  &amp;&amp; ftq_entry.cfi_idx.bits === cfi_idx)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.ifu.redirect_ghist   := Mux(</span><br><span class="line">  use_same_ghist,</span><br><span class="line">  ftq_ghist,</span><br><span class="line">  next_ghist)</span><br><span class="line">io.ifu.redirect_ghist.current_saw_branch_not_taken := use_same_ghist</span><br></pre></td></tr></table></figure>

<h2 id="重定向阶段"><a href="#重定向阶段" class="headerlink" title="重定向阶段"></a>重定向阶段</h2><p>如果分支预测失败,进入重定向逻辑,刷新前端,此时读出ftq对应表项的内容,包括ghist</p>
<blockquote>
<p>猜测分支预测的粒度是bank,这样use_same_ghist就可以解释清楚了,如果没有taken,并且npc和这个指令在同一个bank,则认为这个分支可以使用和ftq一样的历史,然后将current_saw_branch_not_taken置为高,之后如果update就会发现有分支未taken</p>
<p>这样current_saw_branch_not_taken也可以解释清楚了</p>
</blockquote>
<p>对于ghist选择有ftq_ghist和next_ghist,根据use_same_ghist选择对应的分支历史</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    val use_same_ghist = (brupdate.b2.cfi_type === CFI_BR &amp;&amp;//只有条件分支预测方向</span><br><span class="line">                          !brupdate.b2.taken &amp;&amp;//实际不用跳转</span><br><span class="line">                          bankAlign(block_pc) === bankAlign(npc))//最后一个条件意思是npc也在这个block内,如果是这样,那么其实不需要更新ghist,如果是以bank为粒度预测,那么这个分支相当于没有预测,所以不计入历史</span><br><span class="line">...</span><br><span class="line">    val ftq_ghist = io.ifu.get_pc(1).ghist</span><br><span class="line">    val next_ghist = ftq_ghist.update(</span><br><span class="line">      ftq_entry.br_mask.asUInt,</span><br><span class="line">      brupdate.b2.taken,</span><br><span class="line">      brupdate.b2.cfi_type === CFI_BR,</span><br><span class="line">      cfi_idx,</span><br><span class="line">      true.B,</span><br><span class="line">      io.ifu.get_pc(1).pc,</span><br><span class="line">      ftq_entry.cfi_is_call &amp;&amp; ftq_entry.cfi_idx.bits === cfi_idx,</span><br><span class="line">      ftq_entry.cfi_is_ret  &amp;&amp; ftq_entry.cfi_idx.bits === cfi_idx)</span><br><span class="line">    io.ifu.redirect_ghist   := Mux(</span><br><span class="line">      use_same_ghist,</span><br><span class="line">      ftq_ghist,</span><br><span class="line">      next_ghist)</span><br></pre></td></tr></table></figure>

<h1 id="BOOM-Decode"><a href="#BOOM-Decode" class="headerlink" title="BOOM Decode"></a>BOOM Decode</h1><p>首先就是IO,Decode模块的enq是传入的指令,deq是输出的指令,之后是CSR逻辑,和中断,BOOM模块主要就是复用lrocket的decodelogic模块,其他并无特色的地方</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class DecodeUnitIo(implicit p: Parameters) extends BoomBundle</span><br><span class="line">&#123;</span><br><span class="line">  val enq = new Bundle &#123; val uop = Input(new MicroOp()) &#125;</span><br><span class="line">  val deq = new Bundle &#123; val uop = Output(new MicroOp()) &#125;</span><br><span class="line"></span><br><span class="line">  // from CSRFile</span><br><span class="line">  val status = Input(new freechips.rocketchip.rocket.MStatus())</span><br><span class="line">  val csr_decode = Flipped(new freechips.rocketchip.rocket.CSRDecodeIO)</span><br><span class="line">  val interrupt = Input(Bool())</span><br><span class="line">  val interrupt_cause = Input(UInt(xLen.W))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="BOOM-RENAME"><a href="#BOOM-RENAME" class="headerlink" title="BOOM RENAME"></a>BOOM RENAME</h1><p>boom采用的是统一的PRF结构，</p>
<p><img src="/2025/02/05/diplomacy&boom/1731307352707.png" alt="1731307352707"></p>
<p>RAT就是图中的map table，busytable揭示每个物理寄存器的忙碌情况，</p>
<h2 id="Busy-table"><a href="#Busy-table" class="headerlink" title="Busy table"></a>Busy table</h2><p>busytable在唤醒阶段把寄存器设置为空闲，在rename阶段将寄存器设置为忙</p>
<p>首先列出输入输出信号</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">val io = IO(new BoomBundle()(p) &#123;</span><br><span class="line">  val ren_uops = Input(Vec(plWidth, new MicroOp))</span><br><span class="line">  val busy_resps = Output(Vec(plWidth, new BusyResp))</span><br><span class="line">  val rebusy_reqs = Input(Vec(plWidth, Bool()))</span><br><span class="line"></span><br><span class="line">  val wb_pdsts = Input(Vec(numWbPorts, UInt(pregSz.W)))</span><br><span class="line">  val wb_valids = Input(Vec(numWbPorts, Bool()))</span><br><span class="line"></span><br><span class="line">  val debug = new Bundle &#123; val busytable = Output(Bits(numPregs.W)) &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>ren_uops表示查询busytable，busy_reps表示寄存器的忙碌状态，wb前缀的表示写回阶段要更新的寄存器状态，最后一个是debug信号</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">val busy_table = RegInit(0.U(numPregs.W))</span><br><span class="line">// Unbusy written back registers.</span><br><span class="line">val busy_table_wb = busy_table &amp; ~(io.wb_pdsts zip io.wb_valids)</span><br><span class="line">  .map &#123;case (pdst, valid) =&gt; UIntToOH(pdst) &amp; Fill(numPregs, valid.asUInt)&#125;.reduce(_|_)</span><br><span class="line">// Rebusy newly allocated registers.</span><br><span class="line">val busy_table_next = busy_table_wb | (io.ren_uops zip io.rebusy_reqs)</span><br><span class="line">  .map &#123;case (uop, req) =&gt; UIntToOH(uop.pdst) &amp; Fill(numPregs, req.asUInt)&#125;.reduce(_|_)</span><br><span class="line"></span><br><span class="line">busy_table := busy_table_next</span><br></pre></td></tr></table></figure>

<p>接下来是主要模块，首先将写回的寄存器unbusy，我们看busy_table_wb，首先看io.wb_pdsts zip io.wb_valids表示将两个作为一个元组，然后使用map函数，对每个院组都进行操作，操作的内容是后面｛｝内容，这个｛首先使用模式匹配case，然后输出的值是&#x3D;&gt;后面的值，也就是把写回的寄存器变成oh编码，然后把这些元素通过reduce按位或，得到写回寄存器的oh编码，然后取非再&amp;busytable，就相当于释放了写回的寄存器</p>
<p>之后的busy_table_next，就是为寄存器分配忙位</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Read the busy table.</span><br><span class="line">for (i &lt;- 0 until plWidth) &#123;</span><br><span class="line">  val prs1_was_bypassed = (0 until i).map(j =&gt;</span><br><span class="line">    io.ren_uops(i).lrs1 === io.ren_uops(j).ldst &amp;&amp; io.rebusy_reqs(j)).foldLeft(false.B)(_||_)</span><br><span class="line">  val prs2_was_bypassed = (0 until i).map(j =&gt;</span><br><span class="line">    io.ren_uops(i).lrs2 === io.ren_uops(j).ldst &amp;&amp; io.rebusy_reqs(j)).foldLeft(false.B)(_||_)</span><br><span class="line">  val prs3_was_bypassed = (0 until i).map(j =&gt;</span><br><span class="line">    io.ren_uops(i).lrs3 === io.ren_uops(j).ldst &amp;&amp; io.rebusy_reqs(j)).foldLeft(false.B)(_||_)</span><br><span class="line"></span><br><span class="line">  io.busy_resps(i).prs1_busy := busy_table(io.ren_uops(i).prs1) || prs1_was_bypassed &amp;&amp; bypass.B</span><br><span class="line">  io.busy_resps(i).prs2_busy := busy_table(io.ren_uops(i).prs2) || prs2_was_bypassed &amp;&amp; bypass.B</span><br><span class="line">  io.busy_resps(i).prs3_busy := busy_table(io.ren_uops(i).prs3) || prs3_was_bypassed &amp;&amp; bypass.B</span><br><span class="line">  if (!float) io.busy_resps(i).prs3_busy := false.B</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">io.debug.busytable := busy_table</span><br></pre></td></tr></table></figure>

<p>然后就是读busytable，这个的意思就是先检查写入的新映射关系有没有和src1一样的，有的话就说明这个可能有依赖（也即是RAW），也就是这个寄存器在使用，之后只要busytable和prs1_was_bypassed一个成立，就说明这个寄存器在使用</p>
<h2 id="Map-table"><a href="#Map-table" class="headerlink" title="Map table"></a>Map table</h2><p>其实就是RAT，首先先把交互信号放上来，以供后续阅读</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class MapReq(val lregSz: Int) extends Bundle</span><br><span class="line">&#123;</span><br><span class="line">  val lrs1 = UInt(lregSz.W)</span><br><span class="line">  val lrs2 = UInt(lregSz.W)</span><br><span class="line">  val lrs3 = UInt(lregSz.W)</span><br><span class="line">  val ldst = UInt(lregSz.W)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MapResp(val pregSz: Int) extends Bundle</span><br><span class="line">&#123;</span><br><span class="line">  val prs1 = UInt(pregSz.W)</span><br><span class="line">  val prs2 = UInt(pregSz.W)</span><br><span class="line">  val prs3 = UInt(pregSz.W)</span><br><span class="line">  val stale_pdst = UInt(pregSz.W)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class RemapReq(val lregSz: Int, val pregSz: Int) extends Bundle</span><br><span class="line">&#123;</span><br><span class="line">  val ldst = UInt(lregSz.W)</span><br><span class="line">  val pdst = UInt(pregSz.W)</span><br><span class="line">  val valid = Bool()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后就是Maptable的IO信号了，主要就是映射请求，映射答复，重新映射，保存snapshot，恢复snapshot</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">val io = IO(new BoomBundle()(p) &#123;</span><br><span class="line">  // Logical sources -&gt; physical sources.</span><br><span class="line">  val map_reqs    = Input(Vec(plWidth, new MapReq(lregSz)))</span><br><span class="line">  val map_resps   = Output(Vec(plWidth, new MapResp(pregSz)))</span><br><span class="line"></span><br><span class="line">  // Remapping an ldst to a newly allocated pdst?</span><br><span class="line">  val remap_reqs  = Input(Vec(plWidth, new RemapReq(lregSz, pregSz)))</span><br><span class="line"></span><br><span class="line">  // Dispatching branches: need to take snapshots of table state.</span><br><span class="line">  val ren_br_tags = Input(Vec(plWidth, Valid(UInt(brTagSz.W))))</span><br><span class="line"></span><br><span class="line">  // Signals for restoring state following misspeculation.</span><br><span class="line">  val brupdate      = Input(new BrUpdateInfo)</span><br><span class="line">  val rollback    = Input(Bool())</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>接下来就是这个模块的主要信号，首先map_table就是这个模块的核心了，存储寄存器映射关系的，然后就是snapshot，这里为什么要remap？就是把最新的寄存器关系写进去，具体需要看重命名过程干了什么（逻辑源寄存器读RAT，目的寄存器在freelist找空闲，目的寄存器读RAT，将读出的值写入ROB，目的寄存器写入RAT，更新新的映射关系）这样其实就理解了设置这些信号的含义，remap_pdsts就是把物理寄存器号提取出来，如果一周期重命名2条，那么这个就是一个大小为2的向量，remap_ldsts_oh就是给每个逻辑寄存器编码，假设两条指令目的寄存器为1，3，那么编码后的就是（32‘b…10,32’b…1000）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// The map table register array and its branch snapshots.</span><br><span class="line">val map_table = RegInit(VecInit(Seq.fill(numLregs)&#123;0.U(pregSz.W)&#125;))</span><br><span class="line">val br_snapshots = Reg(Vec(maxBrCount, Vec(numLregs, UInt(pregSz.W))))</span><br><span class="line"></span><br><span class="line">// The intermediate states of the map table following modification by each pipeline slot.</span><br><span class="line">val remap_table = Wire(Vec(plWidth+1, Vec(numLregs, UInt(pregSz.W))))</span><br><span class="line"></span><br><span class="line">// Uops requesting changes to the map table.</span><br><span class="line">val remap_pdsts = io.remap_reqs map (_.pdst)</span><br><span class="line">val remap_ldsts_oh = io.remap_reqs map (req =&gt; UIntToOH(req.ldst) &amp; Fill(numLregs, req.valid.asUInt))</span><br></pre></td></tr></table></figure>

<p>然后弄明白新的每个指令新的映射关系，第一个意思就是把0号寄存器清0，如果不是0号寄存器，就设置一个remapped_row，这个的大小是plwidth的大小，这个之后的意思就是，为每个逻辑寄存器找到他的映射关系是来自RAT还是传入的映射关系,我们首先需要知道scanleft的意思，这个的工作模式如下（从左到右依次是reduce，fold，scan），这个remapped_row干的事情就是先把ldst位提取出来，这表示哪个逻辑寄存器是有更新请求，然后zip pdst形成元组，假设有如下映射ldst1-&gt;pdst2,ldst3-&gt;pdst4,这里前面是逻辑。后面是物理，假设一周期2条指令，i&#x3D;1，这个zip形成的元组就是（true，2），（false，2），然后scanleft（有累积性）的初值为map_table（1）,也就是remapped_row第0个元素为来自map的值，然后这句话生成的元组就是（map，pdst2，pdst2），map为来自map-table的物理寄存器，最后把这些赋值给remaptable,然后假如i&#x3D;3，remapped_row就是（map，map，pdst4），此时remap_table（1）为（0，pdst2，map，map，…）remap（2）为（0，pdst2，map，pdst4，…）所以这里可以看到remaptable的最高索引才是正确的映射关系（巧妙但晦涩难懂的操作）</p>
<p><img src="/2025/02/05/diplomacy&boom/1731476588727.png" alt="1731476588727"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Figure out the new mappings seen by each pipeline slot.</span><br><span class="line">for (i &lt;- 0 until numLregs) &#123;</span><br><span class="line">  if (i == 0 &amp;&amp; !float) &#123;</span><br><span class="line">    for (j &lt;- 0 until plWidth+1) &#123;</span><br><span class="line">      remap_table(j)(i) := 0.U</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    val remapped_row = (remap_ldsts_oh.map(ldst =&gt; ldst(i)) zip remap_pdsts)</span><br><span class="line">      .scanLeft(map_table(i)) &#123;case (pdst, (ldst, new_pdst)) =&gt; Mux(ldst, new_pdst, pdst)&#125;</span><br><span class="line"></span><br><span class="line">    for (j &lt;- 0 until plWidth+1) &#123;</span><br><span class="line">      remap_table(j)(i) := remapped_row(j)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后更新新的映射关系，最后就是读map，注意这个处理了读出的映射关系是来自map_table还是remap请求(处理RAW)，当i&#x3D;0，映射关系来自RAT，（也就是第1条指令，最旧的指令）只讲解i&#x3D;1情况的prs1，foldleft和scan类似，但只输出最终结果，所以这里就是检查第一条的目的寄存器和这一条指令（也就是第二条）的源寄存器是否相等，如果相等就使用新的映射</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">when (io.brupdate.b2.mispredict) &#123;</span><br><span class="line">  // Restore the map table to a branch snapshot.</span><br><span class="line">  map_table := br_snapshots(io.brupdate.b2.uop.br_tag)</span><br><span class="line">&#125; .otherwise &#123;</span><br><span class="line">  // Update mappings.</span><br><span class="line">  map_table := remap_table(plWidth)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Read out mappings.</span><br><span class="line">for (i &lt;- 0 until plWidth) &#123;</span><br><span class="line">  io.map_resps(i).prs1       := (0 until i).foldLeft(map_table(io.map_reqs(i).lrs1)) ((p,k) =&gt;</span><br><span class="line">    Mux(bypass.B &amp;&amp; io.remap_reqs(k).valid &amp;&amp; io.remap_reqs(k).ldst === io.map_reqs(i).lrs1, io.remap_reqs(k).pdst, p))</span><br><span class="line">  io.map_resps(i).prs2       := (0 until i).foldLeft(map_table(io.map_reqs(i).lrs2)) ((p,k) =&gt;</span><br><span class="line">    Mux(bypass.B &amp;&amp; io.remap_reqs(k).valid &amp;&amp; io.remap_reqs(k).ldst === io.map_reqs(i).lrs2, io.remap_reqs(k).pdst, p))</span><br><span class="line">  io.map_resps(i).prs3       := (0 until i).foldLeft(map_table(io.map_reqs(i).lrs3)) ((p,k) =&gt;</span><br><span class="line">    Mux(bypass.B &amp;&amp; io.remap_reqs(k).valid &amp;&amp; io.remap_reqs(k).ldst === io.map_reqs(i).lrs3, io.remap_reqs(k).pdst, p))</span><br><span class="line">  io.map_resps(i).stale_pdst := (0 until i).foldLeft(map_table(io.map_reqs(i).ldst)) ((p,k) =&gt;</span><br><span class="line">    Mux(bypass.B &amp;&amp; io.remap_reqs(k).valid &amp;&amp; io.remap_reqs(k).ldst === io.map_reqs(i).ldst, io.remap_reqs(k).pdst, p))</span><br><span class="line"></span><br><span class="line">  if (!float) io.map_resps(i).prs3 := DontCare</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后这个链接对高阶函数做了简单总结：<a href="https://zhuanlan.zhihu.com/p/350301092">高级设计</a></p>
<h2 id="Free-list"><a href="#Free-list" class="headerlink" title="Free list"></a>Free list</h2><p>先列出IO信号</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">val io = IO(new BoomBundle()(p) &#123;</span><br><span class="line">  // Physical register requests.</span><br><span class="line">  val reqs          = Input(Vec(plWidth, Bool()))</span><br><span class="line">  val alloc_pregs   = Output(Vec(plWidth, Valid(UInt(pregSz.W))))</span><br><span class="line"></span><br><span class="line">  // Pregs returned by the ROB.</span><br><span class="line">  val dealloc_pregs = Input(Vec(plWidth, Valid(UInt(pregSz.W))))</span><br><span class="line"></span><br><span class="line">  // Branch info for starting new allocation lists.</span><br><span class="line">  val ren_br_tags   = Input(Vec(plWidth, Valid(UInt(brTagSz.W))))</span><br><span class="line"></span><br><span class="line">  // Mispredict info for recovering speculatively allocated registers.</span><br><span class="line">  val brupdate        = Input(new BrUpdateInfo)</span><br><span class="line"></span><br><span class="line">  val debug = new Bundle &#123;</span><br><span class="line">    val pipeline_empty = Input(Bool())</span><br><span class="line">    val freelist = Output(Bits(numPregs.W))</span><br><span class="line">    val isprlist = Output(Bits(numPregs.W))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>首先明白free list什么时候分配寄存器，什么时候写入用完的寄存器（分别是重命名阶段，和提交阶段），然后就明白上面信号什么意思了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// The free list register array and its branch allocation lists.</span><br><span class="line">val free_list = RegInit(UInt(numPregs.W), ~(1.U(numPregs.W)))</span><br><span class="line">val br_alloc_lists = Reg(Vec(maxBrCount, UInt(numPregs.W)))</span><br><span class="line"></span><br><span class="line">// Select pregs from the free list.</span><br><span class="line">val sels = SelectFirstN(free_list, plWidth)</span><br><span class="line">val sel_fire  = Wire(Vec(plWidth, Bool()))</span><br><span class="line"></span><br><span class="line">// Allocations seen by branches in each pipeline slot.</span><br><span class="line">val allocs = io.alloc_pregs map (a =&gt; UIntToOH(a.bits))</span><br><span class="line">val alloc_masks = (allocs zip io.reqs).scanRight(0.U(n.W)) &#123; case ((a,r),m) =&gt; m | a &amp; Fill(n,r) &#125;</span><br><span class="line"></span><br><span class="line">// Masks that modify the freelist array.</span><br><span class="line">val sel_mask = (sels zip sel_fire) map &#123; case (s,f) =&gt; s &amp; Fill(n,f) &#125; reduce(_|_)</span><br><span class="line">val br_deallocs = br_alloc_lists(io.brupdate.b2.uop.br_tag) &amp; Fill(n, io.brupdate.b2.mispredict)</span><br><span class="line">val dealloc_mask = io.dealloc_pregs.map(d =&gt; UIntToOH(d.bits)(numPregs-1,0) &amp; Fill(n,d.valid)).reduce(_|_) | br_deallocs</span><br><span class="line"></span><br><span class="line">val br_slots = VecInit(io.ren_br_tags.map(tag =&gt; tag.valid)).asUInt</span><br></pre></td></tr></table></figure>

<p>然后free_list是一个size为物理寄存器个数的寄存器，介绍sels之前先介绍PriorityEncoderOH，这个就是返回第一个为true的oh编码，然后sel是就是找到4个为true的索引，并且为oh编码，然后就是sel_mask,这个就是将sels得到的oh组合起来，dealloc_mask就是从ROB返回的物理寄存器，把他转换为onehot，（这里不管分支预测的snapshot），</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">object PriorityEncoderOH &#123;</span><br><span class="line">  private def encode(in: Seq[Bool]): UInt = &#123;</span><br><span class="line">    val outs = Seq.tabulate(in.size)(i =&gt; (BigInt(1) &lt;&lt; i).asUInt(in.size.W))</span><br><span class="line">    PriorityMux(in :+ true.B, outs :+ 0.U(in.size.W))</span><br><span class="line">  &#125;</span><br><span class="line">  def apply(in: Seq[Bool]): Seq[Bool] = &#123;</span><br><span class="line">    val enc = encode(in)</span><br><span class="line">    Seq.tabulate(in.size)(enc(_))</span><br><span class="line">  &#125;</span><br><span class="line">  def apply(in: Bits): UInt = encode((0 until in.getWidth).map(i =&gt; in(i)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后freelist更新，之后就是读出分配好的寄存器,这里有个sel_fire,注意这里的逻辑有些混乱,</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Update the free list.</span><br><span class="line">free_list := (free_list &amp; ~sel_mask | dealloc_mask) &amp; ~(1.U(numPregs.W))</span><br><span class="line"></span><br><span class="line">// Pipeline logic | hookup outputs.</span><br><span class="line">for (w &lt;- 0 until plWidth) &#123;</span><br><span class="line">  val can_sel = sels(w).orR</span><br><span class="line">  val r_valid = RegInit(false.B)</span><br><span class="line">  val r_sel   = RegEnable(OHToUInt(sels(w)), sel_fire(w))</span><br><span class="line"></span><br><span class="line">  r_valid := r_valid &amp;&amp; !io.reqs(w) || can_sel</span><br><span class="line">  sel_fire(w) := (!r_valid || io.reqs(w)) &amp;&amp; can_sel</span><br><span class="line"></span><br><span class="line">  io.alloc_pregs(w).bits  := r_sel</span><br><span class="line">  io.alloc_pregs(w).valid := r_valid</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="RenameStage"><a href="#RenameStage" class="headerlink" title="RenameStage"></a>RenameStage</h2><p>直接看链接<a href="https://zhuanlan.zhihu.com/p/399543947">重命名</a></p>
<p>其实有个问题：maptable本身支持解决RAW，但在rename模块将bypass给关闭了，然后在rename注册了BypassAllocations检查RAW相关，</p>
<p>还有：</p>
<p>rename有两级；第一级主要进行读RAT，第二阶段写RAT，读出freelist，写busytable（链接认为第一阶段还有读freelsit，但代码内使用的却是ren2_uops，也就是第二级）</p>
<p>其实感觉这里是一个比较逆天的操作,只看黄色框内容,由于r_sel是一个寄存器,在en后下个周期才可以得出新的值,这里虽然en(s2送入的请求)了,但实际上下个周期才会响应这个en,这里读出的还是之前的旧数据,但注意,这个旧寄存器值同样也是空闲的,因为他是由上一条指令读的,且freelist已经标记这个寄存器被分配出去了,非常逆天的操作,使用上个指令请求,然后这条指令正好读出,然后s2阶段就可以进行RAW检查了,这个操作完全可以在s1阶段产生请求,然后s2读出数据,还有下面这行代码,这个得结合流水线看,我们重命名一部分在decode&#x2F;rename,另一部分在rename&#x2F;dispatch,s1阶段主要进行读物理源寄存器(RAT),s2阶段读物理目的寄存器,然后把新的映射关系写入RAT,<strong>所以我们不仅要处理组内相关性,还要处理组间相关性</strong>,这句就是处理组间相关性,因为假设B指令的源寄存器和A指令的目的寄存器一样(一周期rename一条,B是新指令),B指令在s1读出的物理源寄存器可能不是最新的映射关系(A指令还没写入RAT),所以需要这行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">r_uop := GetNewUopAndBrMask(BypassAllocations(next_uop, ren2_uops, ren2_alloc_reqs), io.brupdate)</span><br></pre></td></tr></table></figure>

<p><img src="/2025/02/05/diplomacy&boom/1731584801027.png" alt="1731584801027"></p>
<p>下面简单讲一条指令在这个模块进行了什么操作：</p>
<h3 id="读RAT请求和写RAT"><a href="#读RAT请求和写RAT" class="headerlink" title="读RAT请求和写RAT"></a>读RAT请求和写RAT</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for ((((ren1,ren2),com),w) &lt;- (ren1_uops zip ren2_uops zip io.com_uops.reverse).zipWithIndex) &#123;</span><br><span class="line">  map_reqs(w).lrs1 := ren1.lrs1</span><br><span class="line">  map_reqs(w).lrs2 := ren1.lrs2</span><br><span class="line">  map_reqs(w).lrs3 := ren1.lrs3</span><br><span class="line">  map_reqs(w).ldst := ren1.ldst</span><br><span class="line"></span><br><span class="line">  remap_reqs(w).ldst := Mux(io.rollback, com.ldst      , ren2.ldst)</span><br><span class="line">  remap_reqs(w).pdst := Mux(io.rollback, com.stale_pdst, ren2.pdst)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意这里map_reqs是ren1传入，也就是从decode传入的，然后写入RAT就是ren2的逻辑和物理寄存器</p>
<h3 id="读freelist"><a href="#读freelist" class="headerlink" title="读freelist"></a>读freelist</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Freelist inputs.</span><br><span class="line">freelist.io.reqs := ren2_alloc_reqs</span><br><span class="line">freelist.io.dealloc_pregs zip com_valids zip rbk_valids map</span><br><span class="line">  &#123;case ((d,c),r) =&gt; d.valid := c || r&#125;</span><br><span class="line">freelist.io.dealloc_pregs zip io.com_uops map</span><br><span class="line">  &#123;case (d,c) =&gt; d.bits := Mux(io.rollback, c.pdst, c.stale_pdst)&#125;</span><br><span class="line">freelist.io.ren_br_tags := ren2_br_tags</span><br><span class="line">freelist.io.brupdate := io.brupdate</span><br><span class="line">freelist.io.debug.pipeline_empty := io.debug_rob_empty</span><br><span class="line"></span><br><span class="line">assert (ren2_alloc_reqs zip freelist.io.alloc_pregs map &#123;case (r,p) =&gt; !r || p.bits =/= 0.U&#125; reduce (_&amp;&amp;_),</span><br><span class="line">         &quot;[rename-stage] A uop is trying to allocate the zero physical register.&quot;)</span><br><span class="line"></span><br><span class="line">// Freelist outputs.</span><br><span class="line">for ((uop, w) &lt;- ren2_uops.zipWithIndex) &#123;</span><br><span class="line">  val preg = freelist.io.alloc_pregs(w).bits</span><br><span class="line">  uop.pdst := Mux(uop.ldst =/= 0.U || float.B, preg, 0.U)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到我们请求的前缀为ren2</p>
<h3 id="读busytable"><a href="#读busytable" class="headerlink" title="读busytable"></a>读busytable</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">busytable.io.ren_uops := ren2_uops  // expects pdst to be set up.</span><br><span class="line">busytable.io.rebusy_reqs := ren2_alloc_reqs</span><br><span class="line">busytable.io.wb_valids := io.wakeups.map(_.valid)</span><br><span class="line">busytable.io.wb_pdsts := io.wakeups.map(_.bits.uop.pdst)</span><br><span class="line"></span><br><span class="line">assert (!(io.wakeups.map(x =&gt; x.valid &amp;&amp; x.bits.uop.dst_rtype =/= rtype).reduce(_||_)),</span><br><span class="line"> &quot;[rename] Wakeup has wrong rtype.&quot;)</span><br><span class="line"></span><br><span class="line">for ((uop, w) &lt;- ren2_uops.zipWithIndex) &#123;</span><br><span class="line">  val busy = busytable.io.busy_resps(w)</span><br><span class="line"></span><br><span class="line">  uop.prs1_busy := uop.lrs1_rtype === rtype &amp;&amp; busy.prs1_busy</span><br><span class="line">  uop.prs2_busy := uop.lrs2_rtype === rtype &amp;&amp; busy.prs2_busy</span><br><span class="line">  uop.prs3_busy := uop.frs3_en &amp;&amp; busy.prs3_busy</span><br><span class="line"></span><br><span class="line">  val valid = ren2_valids(w)</span><br><span class="line">  assert (!(valid &amp;&amp; busy.prs1_busy &amp;&amp; rtype === RT_FIX &amp;&amp; uop.lrs1 === 0.U), &quot;[rename] x0 is busy??&quot;)</span><br><span class="line">  assert (!(valid &amp;&amp; busy.prs2_busy &amp;&amp; rtype === RT_FIX &amp;&amp; uop.lrs2 === 0.U), &quot;[rename] x0 is busy??&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样是在阶段2进行</p>
<h3 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (w &lt;- 0 until plWidth) &#123;</span><br><span class="line">  val can_allocate = freelist.io.alloc_pregs(w).valid</span><br><span class="line"></span><br><span class="line">  // Push back against Decode stage if Rename1 can&#x27;t proceed.</span><br><span class="line">  io.ren_stalls(w) := (ren2_uops(w).dst_rtype === rtype) &amp;&amp; !can_allocate</span><br><span class="line"></span><br><span class="line">  val bypassed_uop = Wire(new MicroOp)</span><br><span class="line">  if (w &gt; 0) bypassed_uop := BypassAllocations(ren2_uops(w), ren2_uops.slice(0,w), ren2_alloc_reqs.slice(0,w))</span><br><span class="line">  else       bypassed_uop := ren2_uops(w)</span><br><span class="line"></span><br><span class="line">  io.ren2_uops(w) := GetNewUopAndBrMask(bypassed_uop, io.brupdate)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意这里检测了一个指令包内的RAW，那我们还有WAW，但其实已经解决了，maptable的scanleft会写入最新的映射关系</p>
<h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><p>这里boom用了很多花活，巧妙但晦涩难懂，也体现了chisel的强大之处，本篇解读将分支预测失败的全部略过</p>
<h1 id="BOOM-Dispatch"><a href="#BOOM-Dispatch" class="headerlink" title="BOOM Dispatch"></a>BOOM Dispatch</h1><p><img src="/2025/02/05/diplomacy&boom/1731596242893.png" alt="1731596242893"></p>
<p>首先上IO.ren_uops由rename传来，然后后面的dis_uops表示送入每个IQ的指令，假设N 个IQ，每个IQ周期每个周期都可以接受dispawidth指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// incoming microops from rename2</span><br><span class="line">val ren_uops = Vec(coreWidth, Flipped(DecoupledIO(new MicroOp)))</span><br><span class="line"></span><br><span class="line">// outgoing microops to issue queues</span><br><span class="line">// N issues each accept up to dispatchWidth uops</span><br><span class="line">// dispatchWidth may vary between issue queues</span><br><span class="line">val dis_uops = MixedVec(issueParams.map(ip=&gt;Vec(ip.dispatchWidth, DecoupledIO(new MicroOp))))</span><br></pre></td></tr></table></figure>

<p>然后就是boom目前使用的dispatcher,首先是ren_ready,也就是指令已经被写入IQ，这时把他拉高，注意这里所有指令只能去一个IQ，所以有一个reduce，检查所有指令是否都送入这个IQ了，然后就是把ren_uops请求分发到对应IQ，对于Boom，有三个IQ，FP，MEM和ALU，其中IQ和MEM为一个issue unit，每周期轮换，这个有的问题就是如果一周期指令既有MEM，又有INT，会导致某些指令无法全部发出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class BasicDispatcher(implicit p: Parameters) extends Dispatcher</span><br><span class="line">&#123;</span><br><span class="line">  issueParams.map(ip=&gt;require(ip.dispatchWidth == coreWidth))</span><br><span class="line"></span><br><span class="line">  val ren_readys = io.dis_uops.map(d=&gt;VecInit(d.map(_.ready)).asUInt).reduce(_&amp;_)</span><br><span class="line"></span><br><span class="line">  for (w &lt;- 0 until coreWidth) &#123;</span><br><span class="line">    io.ren_uops(w).ready := ren_readys(w)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  for &#123;i &lt;- 0 until issueParams.size</span><br><span class="line">       w &lt;- 0 until coreWidth&#125; &#123;</span><br><span class="line">    val issueParam = issueParams(i)</span><br><span class="line">    val dis        = io.dis_uops(i)</span><br><span class="line"></span><br><span class="line">    dis(w).valid := io.ren_uops(w).valid &amp;&amp; ((io.ren_uops(w).bits.iq_type &amp; issueParam.iqType.U) =/= 0.U)</span><br><span class="line">    dis(w).bits  := io.ren_uops(w).bits</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来为Boom没使用的模块，这个模块是每周期尽可能送入发射队列，也就是没有只能发射到一个IQ的限制，只有在IQ满了才会stall，</p>
<p>这个模块的ren_ready就很清晰，意思和上面的一样，然后循环体内就是主要逻辑,ren大小和ren_ops大小一样(corewidth),然后uses_iq就是指出指令要送去哪个IQ,之后就是为ren_valid赋值,假如这次循环是检测INT的,对于lw,add,sub就是(false,true,true),之后有一个Boom自己的api,Compactor,意思是找出前k个有效的输出,然后将输出链接到dis,最后得出这个IQ是否空闲,如果use_iq为false,就说明空闲,</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  Tries to dispatch as many uops as it can to issue queues,</span><br><span class="line"> *  which may accept fewer than coreWidth per cycle.</span><br><span class="line"> *  When dispatchWidth == coreWidth, its behavior differs</span><br><span class="line"> *  from the BasicDispatcher in that it will only stall dispatch when</span><br><span class="line"> *  an issue queue required by a uop is full.</span><br><span class="line"> */</span><br><span class="line">class CompactingDispatcher(implicit p: Parameters) extends Dispatcher</span><br><span class="line">&#123;</span><br><span class="line">  issueParams.map(ip =&gt; require(ip.dispatchWidth &gt;= ip.issueWidth))</span><br><span class="line"></span><br><span class="line">  val ren_readys = Wire(Vec(issueParams.size, Vec(coreWidth, Bool())))</span><br><span class="line"></span><br><span class="line">  for (((ip, dis), rdy) &lt;- issueParams zip io.dis_uops zip ren_readys) &#123;</span><br><span class="line">    val ren = Wire(Vec(coreWidth, Decoupled(new MicroOp)))</span><br><span class="line">    ren &lt;&gt; io.ren_uops</span><br><span class="line"></span><br><span class="line">    val uses_iq = ren map (u =&gt; (u.bits.iq_type &amp; ip.iqType.U).orR)</span><br><span class="line"></span><br><span class="line">    // Only request an issue slot if the uop needs to enter that queue.</span><br><span class="line">    (ren zip io.ren_uops zip uses_iq) foreach &#123;case ((u,v),q) =&gt;</span><br><span class="line">      u.valid := v.valid &amp;&amp; q&#125;</span><br><span class="line"></span><br><span class="line">    val compactor = Module(new Compactor(coreWidth, ip.dispatchWidth, new MicroOp))</span><br><span class="line">    compactor.io.in  &lt;&gt; ren</span><br><span class="line">    dis &lt;&gt; compactor.io.out</span><br><span class="line"></span><br><span class="line">    // The queue is considered ready if the uop doesn&#x27;t use it.</span><br><span class="line">    rdy := ren zip uses_iq map &#123;case (u,q) =&gt; u.ready || !q&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  (ren_readys.reduce((r,i) =&gt;</span><br><span class="line">      VecInit(r zip i map &#123;case (r,i) =&gt;</span><br><span class="line">        r &amp;&amp; i&#125;)) zip io.ren_uops) foreach &#123;case (r,u) =&gt;</span><br><span class="line">          u.ready := r&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接下来介绍<strong>Compactor</strong>,作用就是在n个valid选出k个,首先gen为数据的类型,首先IO为n入k出,如果n&#x3D;k,就直接把输出连到输入,否则就要去选出前k个,sels得出的是选择哪一个的OH编码,假如in_valid为(0,1,1)</p>
<p>n&#x3D;3,k&#x3D;2,sels就为(0010,0100),in_readys的意思就是可以传入数据了,也就是这批指令已经分配完IQ了,这个模块的找前几个有效的数据设置也很巧妙,</p>
<h1 id="BOOM-ROB"><a href="#BOOM-ROB" class="headerlink" title="BOOM ROB"></a>BOOM ROB</h1><ul>
<li><input disabled type="checkbox"> 由于ROB有很多信号目前是从执行级传来，导致解析可能有误，之后会更新解析</li>
</ul>
<p><img src="/2025/02/05/diplomacy&boom/1731673694620.png" alt="1731673694620"></p>
<p>首先先理清,ROB在Dispatch写入指令信息,在提交阶段读出信息,提交总是最旧的指令,这里ROB是W个存储体(W&#x3D;dispatch长度),每次写入ROB就是一个W宽度的指令信息,ROB仅存储一个指令包的首地址,bank(0)(指令包地址连续),但遇到分支指令就得产生气泡,重新开一行,不然无法读到正确的PC,<strong>运行图就是下图,注意0x0008有问题,跳转地址为0x0028</strong></p>
<p><img src="/2025/02/05/diplomacy&boom/1731675223257.png" alt="1731675223257"></p>
<h2 id="ROB状态机"><a href="#ROB状态机" class="headerlink" title="ROB状态机"></a>ROB状态机</h2><p>ROB状态机有四个状态，这种情况是不含CRAT，也就是checkpoint，然后还有含有CRAT，这时候就会少一个s_rollback</p>
<p><img src="/2025/02/05/diplomacy&boom/1731739470401.png" alt="1731739470401"></p>
<p><strong>is_unique</strong> 信号是定义在 MicroOp 中的一个成员，表示只允许该指令一条指令存在于流水线中，流水线要对 is_unique 的指令做出的响应包括：</p>
<ul>
<li>等待 STQ (Store Queue) 中的指令全部提交</li>
<li>清空该指令之后的取到的指令</li>
<li>ROB 标记为 unready，等待清空</li>
</ul>
<p>RISCV 指令集中 is_unique 有效的指令主要包括：</p>
<ul>
<li>CSR(Control and Status Register) 指令</li>
<li>原子指令</li>
<li>内存屏障指令</li>
<li>休眠指令</li>
<li>机器模式特权指令</li>
</ul>
<p>下面是状态机代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// ROB FSM</span><br><span class="line">if (!enableCommitMapTable) &#123;</span><br><span class="line">  switch (rob_state) &#123;</span><br><span class="line">    is (s_reset) &#123;</span><br><span class="line">      rob_state := s_normal</span><br><span class="line">    &#125;</span><br><span class="line">    is (s_normal) &#123;</span><br><span class="line">      // Delay rollback 2 cycles so branch mispredictions can drain</span><br><span class="line">      when (RegNext(RegNext(exception_thrown))) &#123;</span><br><span class="line">        rob_state := s_rollback</span><br><span class="line">      &#125; .otherwise &#123;</span><br><span class="line">        for (w &lt;- 0 until coreWidth) &#123;</span><br><span class="line">          when (io.enq_valids(w) &amp;&amp; io.enq_uops(w).is_unique) &#123;</span><br><span class="line">            rob_state := s_wait_till_empty</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    is (s_rollback) &#123;</span><br><span class="line">      when (empty) &#123;</span><br><span class="line">        rob_state := s_normal</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    is (s_wait_till_empty) &#123;</span><br><span class="line">      when (RegNext(exception_thrown)) &#123;</span><br><span class="line">        rob_state := s_rollback</span><br><span class="line">      &#125; .elsewhen (empty) &#123;</span><br><span class="line">        rob_state := s_normal</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  switch (rob_state) &#123;</span><br><span class="line">    is (s_reset) &#123;</span><br><span class="line">      rob_state := s_normal</span><br><span class="line">    &#125;</span><br><span class="line">    is (s_normal) &#123;</span><br><span class="line">      when (exception_thrown) &#123;</span><br><span class="line">        ; //rob_state := s_rollback</span><br><span class="line">      &#125; .otherwise &#123;</span><br><span class="line">        for (w &lt;- 0 until coreWidth) &#123;</span><br><span class="line">          when (io.enq_valids(w) &amp;&amp; io.enq_uops(w).is_unique) &#123;</span><br><span class="line">            rob_state := s_wait_till_empty</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    is (s_rollback) &#123;</span><br><span class="line">      when (rob_tail_idx  === rob_head_idx) &#123;</span><br><span class="line">        rob_state := s_normal</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    is (s_wait_till_empty) &#123;</span><br><span class="line">      when (exception_thrown) &#123;</span><br><span class="line">        ; //rob_state := s_rollback</span><br><span class="line">      &#125; .elsewhen (rob_tail === rob_head) &#123;</span><br><span class="line">        rob_state := s_normal</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ROB输入"><a href="#ROB输入" class="headerlink" title="ROB输入"></a>ROB输入</h2><p>输入就是在dispatch入队</p>
<p>BOOM 为每个bank中的所有指令定义了若干变量记录重命名缓存的状态信息，主要包括：</p>
<ul>
<li>rob_val         ：当前 bank 中每行指令的有效信号，初始化为0</li>
<li>rob_bsy        ：当前 bank 中每行指令的 busy 信号，busy&#x3D;1时表示指令还在流水线中，当入队的指令不是fence或者fence.i都为busy，fence是保证内存顺序，不执行任何操作，故不busy</li>
<li>rob_unsafe   ：当前 bank 中每行指令的 unsafe 信号，指令 safe 表示一定可以被提交</li>
<li>rob_uop       ：当前 bank 中的每行指令</li>
</ul>
<p>其中unsafe有四种情况：</p>
<ul>
<li>使用LD队列</li>
<li>使用ST队列，并且不是fence指令</li>
<li>是分支或者jalr</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def unsafe           = uses_ldq || (uses_stq &amp;&amp; !is_fence) || is_br || is_jalr</span><br></pre></td></tr></table></figure>

<p>当输入的指令有效时，就把相关信息写入ROB的tail位置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">when (io.enq_valids(w)) &#123;</span><br><span class="line">  rob_val(rob_tail)       := true.B</span><br><span class="line">  rob_bsy(rob_tail)       := !(io.enq_uops(w).is_fence ||</span><br><span class="line">                               io.enq_uops(w).is_fencei)</span><br><span class="line">  rob_unsafe(rob_tail)    := io.enq_uops(w).unsafe</span><br><span class="line">  rob_uop(rob_tail)       := io.enq_uops(w)</span><br><span class="line">  rob_exception(rob_tail) := io.enq_uops(w).exception</span><br><span class="line">  rob_predicated(rob_tail)   := false.B</span><br><span class="line">  rob_fflags(rob_tail)    := 0.U</span><br><span class="line"></span><br><span class="line">  assert (rob_val(rob_tail) === false.B, &quot;[rob] overwriting a valid entry.&quot;)</span><br><span class="line">  assert ((io.enq_uops(w).rob_idx &gt;&gt; log2Ceil(coreWidth)) === rob_tail)</span><br><span class="line">&#125; .elsewhen (io.enq_valids.reduce(_|_) &amp;&amp; !rob_val(rob_tail)) &#123;</span><br><span class="line">  rob_uop(rob_tail).debug_inst := BUBBLE // just for debug purposes</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="写回级操作"><a href="#写回级操作" class="headerlink" title="写回级操作"></a>写回级操作</h2><p>这个就是响应写回级操作，当写回有效，并且匹配到相关的bank，将busy和unsafe置为低，然后rob的pred设置为写回的pred，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (i &lt;- 0 until numWakeupPorts) &#123;</span><br><span class="line">  val wb_resp = io.wb_resps(i)</span><br><span class="line">  val wb_uop = wb_resp.bits.uop</span><br><span class="line">  val row_idx = GetRowIdx(wb_uop.rob_idx)</span><br><span class="line">  when (wb_resp.valid &amp;&amp; MatchBank(GetBankIdx(wb_uop.rob_idx))) &#123;</span><br><span class="line">    rob_bsy(row_idx)      := false.B</span><br><span class="line">    rob_unsafe(row_idx)   := false.B</span><br><span class="line">    rob_predicated(row_idx)  := wb_resp.bits.predicated</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="响应LSU输入"><a href="#响应LSU输入" class="headerlink" title="响应LSU输入"></a>响应LSU输入</h2><blockquote>
<p>注意：这里引用的<a href="https://www.zhihu.com/search?type=content&q=boom%20ROB">ROB</a>，目前我还不太清楚LSU操作，故先引用，之后可能会加入自己理解</p>
</blockquote>
<ul>
<li>lsu_clr_bsy       ：当要 LSU 模块正确接受了要保存的数据时，清除 store 命令的 busy 状态，同时将指令标记为 safe。clr_bsy 信号的值与存储目标地址是否有效、TLB是否命中、是否处于错误的分支预测下、该指令在存储队列中的状态等因素有关。</li>
<li>lsu_clr_unsafe   ：推测 load 命令除了 Memory Ordering Failure 之外不会出现其他异常时，将 load 指令标记为 safe。lsu_clr_unsafe 信号要等广播异常之后才能输出，采用 RegNext 类型寄存器来延迟一个时钟周期。</li>
<li>lxcpt                  ：来自LSU的异常，包括异常的指令、异常是否有效、异常原因等信息。异常的指令在 rob_exception 中对应的值将置为1。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (clr_rob_idx &lt;- io.lsu_clr_bsy) &#123;</span><br><span class="line">  when (clr_rob_idx.valid &amp;&amp; MatchBank(GetBankIdx(clr_rob_idx.bits))) &#123;</span><br><span class="line">    val cidx = GetRowIdx(clr_rob_idx.bits)</span><br><span class="line">    rob_bsy(cidx)    := false.B</span><br><span class="line">    rob_unsafe(cidx) := false.B</span><br><span class="line">    assert (rob_val(cidx) === true.B, &quot;[rob] store writing back to invalid entry.&quot;)</span><br><span class="line">    assert (rob_bsy(cidx) === true.B, &quot;[rob] store writing back to a not-busy entry.&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">for (clr &lt;- io.lsu_clr_unsafe) &#123;</span><br><span class="line">  when (clr.valid &amp;&amp; MatchBank(GetBankIdx(clr.bits))) &#123;</span><br><span class="line">    val cidx = GetRowIdx(clr.bits)</span><br><span class="line">    rob_unsafe(cidx) := false.B</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">when (io.lxcpt.valid &amp;&amp; MatchBank(GetBankIdx(io.lxcpt.bits.uop.rob_idx))) &#123;</span><br><span class="line">  rob_exception(GetRowIdx(io.lxcpt.bits.uop.rob_idx)) := true.B</span><br><span class="line">  when (io.lxcpt.bits.cause =/= MINI_EXCEPTION_MEM_ORDERING) &#123;</span><br><span class="line">    // In the case of a mem-ordering failure, the failing load will have been marked safe already.</span><br><span class="line">    assert(rob_unsafe(GetRowIdx(io.lxcpt.bits.uop.rob_idx)),</span><br><span class="line">      &quot;An instruction marked as safe is causing an exception&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">can_throw_exception(w) := rob_val(rob_head) &amp;&amp; rob_exception(rob_head)</span><br></pre></td></tr></table></figure>

<p><strong>store</strong> 命令特殊之处在于不需要写回 (Write Back) 寄存器，因此 LSU 模块将 store 指令从存储队列提交后，store 命令就可以从流水线中退休，即 io.lsu_clr_bsy 信号将 store 指令置为 safe 时同时置为 unbusy。</p>
<p><strong>MINI_EXCEPTION_MEM_ORDERING</strong> 是指发生存储-加载顺序异常(Memory Ordering Failure)。当 store 指令与其后的 load 指令有共同的目标地址时，类似 RAW 冲突，若 load 指令在 store 之前发射(Issue)，load 命令将从内存中读取错误的值。处理器在提交 store 指令时需要检查是否发生了 Memory Ordering Failure，如果有，则需要刷新流水线、修改重命名映射表等。Memory Ordering Failure 是处理器乱序执行带来的问题,是处理器设计的缺陷，不属于 RISCV 规定的异常，采用 MINI_EXCEPTION_MEM_ORSERING 来弥补。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">can_throw_exception(w) := rob_val(rob_head) &amp;&amp; rob_exception(rob_head)</span><br></pre></td></tr></table></figure>

<p>当位于 ROB头(head) 的指令有效且异常时，才允许抛出异常。</p>
<h2 id="响应提交"><a href="#响应提交" class="headerlink" title="响应提交"></a>响应提交</h2><p>在 ROB 头的指令有效且已不在流水线中且未收到来自 CSR 的暂停信号（例如wfi指令）时有效，表示此时在 ROB 头的指令可以提交。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">can_commit(w) := rob_val(rob_head) &amp;&amp; !(rob_bsy(rob_head)) &amp;&amp; !io.csr_stall</span><br></pre></td></tr></table></figure>

<p>提交和抛出异常只能在提交阶段</p>
<p><strong>will_commit</strong> 这一段代码的主要作用是为 head 指针指向的 ROB 行中的每一个 bank 生成 will_commit 信号，will_commit 信号指示下一时钟周期指令是否提交。will_commit 信号有效的条件是：</p>
<ul>
<li>该 bank 中的指令可以提交</li>
<li>该 bank 中的指令不会抛出异常</li>
<li>ROB 的提交没有被封锁</li>
</ul>
<p><strong>block_commit</strong>  block_commit&#x3D;1 时，ROB 既不能提交指令，也不能抛出异常。对于每个bank，都有一个自己的 block_commit 信号，只要一个 bank 被封锁提交，其后的所有 bank 都将被封锁提交。block_commit 信号保证 ROB 只能顺序提交。若 ROB 处于 s_rollback 或 s_reset 状态，或在前两个时钟周期内抛出异常时，block_commit将被初始化为1,即该行所有指令的提交都被封锁。</p>
<p> <strong>will_throw_exception</strong> ： 表示下一时钟周期将要抛出异常，该信号初始化为0，使信号有效的条件包括：</p>
<ul>
<li>当前bank可以抛出异常</li>
<li>没有封锁提交</li>
<li>上一个bank没有要提交的指令</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var block_commit = (rob_state =/= s_normal) &amp;&amp; (rob_state =/= s_wait_till_empty) || RegNext(exception_thrown) || RegNext(RegNext(exception_thrown))</span><br><span class="line">var will_throw_exception = false.B</span><br><span class="line">var block_xcpt   = false.B</span><br><span class="line"></span><br><span class="line">for (w &lt;- 0 until coreWidth) &#123;</span><br><span class="line">  will_throw_exception = (can_throw_exception(w) &amp;&amp; !block_commit &amp;&amp; !block_xcpt) || will_throw_exception</span><br><span class="line"></span><br><span class="line">  will_commit(w)       := can_commit(w) &amp;&amp; !can_throw_exception(w) &amp;&amp; !block_commit</span><br><span class="line">  block_commit         = (rob_head_vals(w) &amp;&amp;</span><br><span class="line">                         (!can_commit(w) || can_throw_exception(w))) || block_commit</span><br><span class="line">  block_xcpt           = will_commit(w)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="异常跟踪逻辑"><a href="#异常跟踪逻辑" class="headerlink" title="异常跟踪逻辑"></a>异常跟踪逻辑</h2><p>ROB接受的异常信息来自两个方面：</p>
<ul>
<li>前端发生的异常，输入端口为 io.enq_valid 和 io.enq_uops.exception</li>
<li>LSU发生的异常，输入端口为 io.lxcpt</li>
</ul>
<p>只存储最旧的异常，因为本来异常就冲刷流水线，之后的异常无意义，首先将dispatch异常原因写入enq_xcpts,</p>
<p>然后就是r_xcpt_uop的更新逻辑,</p>
<p>如果发生回滚，或者冲刷流水线，或者异常被抛出了，不更新，</p>
<p>如果是lsu的异常，首先将uop更新为lsu的uop，然后检查这个是否是最旧的异常（IsOlder）或者是否有效，如果是最旧的异常，或者r_xcpt_val无效，就进入更新逻辑更新next_xcpt_uop（其实就是next_xcpt_uop），</p>
<p>如果是dispatch的，且是最旧的指令，更新信息</p>
<p>如果这个异常位于分支预测失败路径，直接把r_xcpt_val无效</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">val next_xcpt_uop = Wire(new MicroOp())</span><br><span class="line">next_xcpt_uop := r_xcpt_uop</span><br><span class="line">val enq_xcpts = Wire(Vec(coreWidth, Bool()))</span><br><span class="line">for (i &lt;- 0 until coreWidth) &#123;</span><br><span class="line">  enq_xcpts(i) := io.enq_valids(i) &amp;&amp; io.enq_uops(i).exception</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">when (!(io.flush.valid || exception_thrown) &amp;&amp; rob_state =/= s_rollback) &#123;</span><br><span class="line">  when (io.lxcpt.valid) &#123;</span><br><span class="line">    val new_xcpt_uop = io.lxcpt.bits.uop</span><br><span class="line"></span><br><span class="line">    when (!r_xcpt_val || IsOlder(new_xcpt_uop.rob_idx, r_xcpt_uop.rob_idx, rob_head_idx)) &#123;</span><br><span class="line">      r_xcpt_val              := true.B</span><br><span class="line">      next_xcpt_uop           := new_xcpt_uop</span><br><span class="line">      next_xcpt_uop.exc_cause := io.lxcpt.bits.cause</span><br><span class="line">      r_xcpt_badvaddr         := io.lxcpt.bits.badvaddr</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; .elsewhen (!r_xcpt_val &amp;&amp; enq_xcpts.reduce(_|_)) &#123;</span><br><span class="line">    val idx = enq_xcpts.indexWhere&#123;i: Bool =&gt; i&#125;</span><br><span class="line"></span><br><span class="line">    // if no exception yet, dispatch exception wins</span><br><span class="line">    r_xcpt_val      := true.B</span><br><span class="line">    next_xcpt_uop   := io.enq_uops(idx)</span><br><span class="line">    r_xcpt_badvaddr := AlignPCToBoundary(io.xcpt_fetch_pc, icBlockBytes) | io.enq_uops(idx).pc_lob</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">r_xcpt_uop         := next_xcpt_uop</span><br><span class="line">r_xcpt_uop.br_mask := GetNewBrMask(io.brupdate, next_xcpt_uop)</span><br><span class="line">when (io.flush.valid || IsKilledByBranch(io.brupdate, next_xcpt_uop)) &#123;</span><br><span class="line">  r_xcpt_val := false.B</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="分支预测失败"><a href="#分支预测失败" class="headerlink" title="分支预测失败"></a>分支预测失败</h2><p>主要是消除mask一样的分支，否则就更新这个指令的br_mask，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// -----------------------------------------------</span><br><span class="line">// Kill speculated entries on branch mispredict</span><br><span class="line">for (i &lt;- 0 until numRobRows) &#123;</span><br><span class="line">  val br_mask = rob_uop(i).br_mask</span><br><span class="line"></span><br><span class="line">  //kill instruction if mispredict &amp; br mask match</span><br><span class="line">  when (IsKilledByBranch(io.brupdate, br_mask))</span><br><span class="line">  &#123;</span><br><span class="line">    rob_val(i) := false.B</span><br><span class="line">    rob_uop(i.U).debug_inst := BUBBLE</span><br><span class="line">  &#125; .elsewhen (rob_val(i)) &#123;</span><br><span class="line">    // clear speculation bit even on correct speculation</span><br><span class="line">    rob_uop(i).br_mask := GetNewBrMask(io.brupdate, br_mask)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ROB-Head-Logic"><a href="#ROB-Head-Logic" class="headerlink" title="ROB Head Logic"></a>ROB Head Logic</h2><p>当一个bank的所有指令都可以提交，才可以改变head指针状态，finished_committing_row只有当commit指令有效，并且将在下个周期提交，并且head有效</p>
<ul>
<li><input disabled type="checkbox"> 弄明白r_partial_row是什么意思</li>
</ul>
<p>这时就会自增ROB的head指针，否则将rob_head_lsb指向第一个为1的bank</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">val rob_deq = WireInit(false.B)</span><br><span class="line">val r_partial_row = RegInit(false.B)</span><br><span class="line"></span><br><span class="line">when (io.enq_valids.reduce(_|_)) &#123;</span><br><span class="line">  r_partial_row := io.enq_partial_stall</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">val finished_committing_row =</span><br><span class="line">  (io.commit.valids.asUInt =/= 0.U) &amp;&amp;</span><br><span class="line">  ((will_commit.asUInt ^ rob_head_vals.asUInt) === 0.U) &amp;&amp;</span><br><span class="line">  !(r_partial_row &amp;&amp; rob_head === rob_tail &amp;&amp; !maybe_full)</span><br><span class="line"></span><br><span class="line">when (finished_committing_row) &#123;</span><br><span class="line">  rob_head     := WrapInc(rob_head, numRobRows)</span><br><span class="line">  rob_head_lsb := 0.U</span><br><span class="line">  rob_deq      := true.B</span><br><span class="line">&#125; .otherwise &#123;</span><br><span class="line">  rob_head_lsb := OHToUInt(PriorityEncoderOH(rob_head_vals.asUInt))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ROB-Tail-Logic"><a href="#ROB-Tail-Logic" class="headerlink" title="ROB Tail Logic"></a>ROB Tail Logic</h2><p>tail主要有以下优先级：</p>
<ol>
<li>当处于回滚状态，并且还没操作完或者ROB满了，此时自减tail，设置deq为true，</li>
<li>当处于回滚，但tail等于head并且没有满，lsb设置为head的lsb</li>
</ol>
<ul>
<li><input checked disabled type="checkbox"> lsb意思就是bank的偏移</li>
</ul>
<ol start="3">
<li>当分支预测失败，自增</li>
<li>当dispatch，自增，然后指向第0个bank</li>
<li>当指令未派遣完，将LSB设置为最后一个有效指令的下一个bank</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">val rob_enq = WireInit(false.B)</span><br><span class="line"></span><br><span class="line">when (rob_state === s_rollback &amp;&amp; (rob_tail =/= rob_head || maybe_full)) &#123;</span><br><span class="line">  // Rollback a row</span><br><span class="line">  rob_tail     := WrapDec(rob_tail, numRobRows)</span><br><span class="line">  rob_tail_lsb := (coreWidth-1).U</span><br><span class="line">  rob_deq := true.B</span><br><span class="line">&#125; .elsewhen (rob_state === s_rollback &amp;&amp; (rob_tail === rob_head) &amp;&amp; !maybe_full) &#123;</span><br><span class="line">  // Rollback an entry</span><br><span class="line">  rob_tail_lsb := rob_head_lsb</span><br><span class="line">&#125; .elsewhen (io.brupdate.b2.mispredict) &#123;</span><br><span class="line">  rob_tail     := WrapInc(GetRowIdx(io.brupdate.b2.uop.rob_idx), numRobRows)</span><br><span class="line">  rob_tail_lsb := 0.U</span><br><span class="line">&#125; .elsewhen (io.enq_valids.asUInt =/= 0.U &amp;&amp; !io.enq_partial_stall) &#123;</span><br><span class="line">  rob_tail     := WrapInc(rob_tail, numRobRows)</span><br><span class="line">  rob_tail_lsb := 0.U</span><br><span class="line">  rob_enq      := true.B</span><br><span class="line">&#125; .elsewhen (io.enq_valids.asUInt =/= 0.U &amp;&amp; io.enq_partial_stall) &#123;</span><br><span class="line">  rob_tail_lsb := PriorityEncoder(~MaskLower(io.enq_valids.asUInt))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ROB-PNR逻辑"><a href="#ROB-PNR逻辑" class="headerlink" title="ROB PNR逻辑"></a>ROB PNR逻辑</h2><ol>
<li><input disabled type="checkbox"> TODO</li>
</ol>
<h2 id="ROB输出逻辑"><a href="#ROB输出逻辑" class="headerlink" title="ROB输出逻辑"></a>ROB输出逻辑</h2><p>提交是否有效，以及回滚是否有效</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    io.commit.valids(w) := will_commit(w)</span><br><span class="line">    io.commit.arch_valids(w) := will_commit(w) &amp;&amp; !rob_predicated(com_idx)</span><br><span class="line">    io.commit.uops(w)   := rob_uop(com_idx)</span><br><span class="line">    io.commit.debug_insts(w) := rob_debug_inst_rdata(w)</span><br><span class="line">...</span><br><span class="line">    io.commit.rbk_valids(w) := rbk_row &amp;&amp; rob_val(com_idx) &amp;&amp; !(enableCommitMapTable.B)</span><br><span class="line">    io.commit.rollback := (rob_state === s_rollback)</span><br></pre></td></tr></table></figure>

<p>送往前端的flush信号</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> // delay a cycle for critical path considerations</span><br><span class="line">io.flush.valid          := flush_val</span><br><span class="line">io.flush.bits.ftq_idx   := flush_uop.ftq_idx</span><br><span class="line">io.flush.bits.pc_lob    := flush_uop.pc_lob</span><br><span class="line">io.flush.bits.edge_inst := flush_uop.edge_inst</span><br><span class="line">io.flush.bits.is_rvc    := flush_uop.is_rvc</span><br><span class="line">io.flush.bits.flush_typ := FlushTypes.getType(flush_val,</span><br><span class="line">                                              exception_thrown &amp;&amp; !is_mini_exception,</span><br><span class="line">                                              flush_commit &amp;&amp; flush_uop.uopc === uopERET,</span><br><span class="line">                                              refetch_inst)</span><br></pre></td></tr></table></figure>

<p>输出异常信息，提交异常</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  // Note: exception must be in the commit bundle.</span><br><span class="line">  // Note: exception must be the first valid instruction in the commit bundle.</span><br><span class="line">  exception_thrown := will_throw_exception</span><br><span class="line">  val is_mini_exception = io.com_xcpt.bits.cause === MINI_EXCEPTION_MEM_ORDERING</span><br><span class="line">  io.com_xcpt.valid := exception_thrown &amp;&amp; !is_mini_exception</span><br><span class="line">  io.com_xcpt.bits.cause := r_xcpt_uop.exc_cause</span><br><span class="line">...</span><br><span class="line">  io.com_xcpt.bits.badvaddr := Sext(r_xcpt_badvaddr, xLen)</span><br><span class="line">...</span><br><span class="line">  io.com_xcpt.bits.ftq_idx   := com_xcpt_uop.ftq_idx</span><br><span class="line">  io.com_xcpt.bits.edge_inst := com_xcpt_uop.edge_inst</span><br><span class="line">  io.com_xcpt.bits.is_rvc    := com_xcpt_uop.is_rvc</span><br><span class="line">  io.com_xcpt.bits.pc_lob    := com_xcpt_uop.pc_lob</span><br></pre></td></tr></table></figure>

<p>送往ren2&#x2F;dispatch的信号</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">io.empty        := empty</span><br><span class="line">io.ready        := (rob_state === s_normal) &amp;&amp; !full &amp;&amp; !r_xcpt_val</span><br></pre></td></tr></table></figure>

<h1 id="BOOM-V3-ISSUE-模块解析"><a href="#BOOM-V3-ISSUE-模块解析" class="headerlink" title="BOOM V3 ISSUE 模块解析"></a>BOOM V3 ISSUE 模块解析</h1><h2 id="issue-slot"><a href="#issue-slot" class="headerlink" title="issue slot"></a>issue slot</h2><p><img src="/2025/02/05/diplomacy&boom/1731223168047.png" alt="1731223168047"></p>
<p>首先明确：这个slot需要能写入东西，能读出东西，控制信号可以改变（唤醒）</p>
<p>写入就是dispatch模块写入，读出就是准备好了可以发射了</p>
<p>然後列出状态机:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">trait IssueUnitConstants</span><br><span class="line">&#123;</span><br><span class="line">  // invalid  : slot holds no valid uop.</span><br><span class="line">  // s_valid_1: slot holds a valid uop.</span><br><span class="line">  // s_valid_2: slot holds a store-like uop that may be broken into two micro-ops.</span><br><span class="line">  val s_invalid :: s_valid_1 :: s_valid_2 :: Nil = Enum(3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到有三个状态</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">val io = IO(new IssueSlotIO(numWakeupPorts))</span><br><span class="line"></span><br><span class="line">// slot invalid?</span><br><span class="line">// slot is valid, holding 1 uop</span><br><span class="line">// slot is valid, holds 2 uops (like a store)</span><br><span class="line">def is_invalid = state === s_invalid</span><br><span class="line">def is_valid = state =/= s_invalid</span><br><span class="line"></span><br><span class="line">val next_state      = Wire(UInt()) // the next state of this slot (which might then get moved to a new slot)</span><br><span class="line">val next_uopc       = Wire(UInt()) // the next uopc of this slot (which might then get moved to a new slot)</span><br><span class="line">val next_lrs1_rtype = Wire(UInt()) // the next reg type of this slot (which might then get moved to a new slot)</span><br><span class="line">val next_lrs2_rtype = Wire(UInt()) // the next reg type of this slot (which might then get moved to a new slot)</span><br><span class="line"></span><br><span class="line">val state = RegInit(s_invalid)</span><br><span class="line">val p1    = RegInit(false.B)</span><br><span class="line">val p2    = RegInit(false.B)</span><br><span class="line">val p3    = RegInit(false.B)</span><br><span class="line">val ppred = RegInit(false.B)</span><br><span class="line"></span><br><span class="line">// Poison if woken up by speculative load.</span><br><span class="line">// Poison lasts 1 cycle (as ldMiss will come on the next cycle).</span><br><span class="line">// SO if poisoned is true, set it to false!</span><br><span class="line">val p1_poisoned = RegInit(false.B)</span><br><span class="line">val p2_poisoned = RegInit(false.B)</span><br><span class="line">p1_poisoned := false.B</span><br><span class="line">p2_poisoned := false.B</span><br><span class="line">val next_p1_poisoned = Mux(io.in_uop.valid, io.in_uop.bits.iw_p1_poisoned, p1_poisoned)</span><br><span class="line">val next_p2_poisoned = Mux(io.in_uop.valid, io.in_uop.bits.iw_p2_poisoned, p2_poisoned)</span><br><span class="line"></span><br><span class="line">val slot_uop = RegInit(NullMicroOp)</span><br><span class="line">val next_uop = Mux(io.in_uop.valid, io.in_uop.bits, slot_uop)</span><br></pre></td></tr></table></figure>

<p>接下来为主要信号，next_state這個slot的下一個狀態,之后这些next前缀的都是这个意思,他们是去构造压缩式队列使用的,然后state是这个slot的状态,p1,p2,p3表示操作数是否准备好了,ppred涉及到load的推测唤醒,但目前他们文档说不支持,下面的p1_poisoned表示推测唤醒失败,需要将这个p1给置为false,next_p1_poisoned是指输入的bit的p1是否被poisoned,slot_uop保存这个slot内容,然后next_uop,仍然用于压缩队列</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//-----------------------------------------------------------------------------</span><br><span class="line">// next slot state computation</span><br><span class="line">// compute the next state for THIS entry slot (in a collasping queue, the</span><br><span class="line">// current uop may get moved elsewhere, and a new uop can enter</span><br><span class="line"></span><br><span class="line">when (io.kill) &#123;</span><br><span class="line">  state := s_invalid</span><br><span class="line">&#125; .elsewhen (io.in_uop.valid) &#123;</span><br><span class="line">  state := io.in_uop.bits.iw_state</span><br><span class="line">&#125; .elsewhen (io.clear) &#123;</span><br><span class="line">  state := s_invalid</span><br><span class="line">&#125; .otherwise &#123;</span><br><span class="line">  state := next_state</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后就是下一个slot状态计算,kill表示冲刷流水线,clear表示slot被移到其他的地方了,如果输入的uop.valid有效,就把state置为输入uop的state,否则就为next_state</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//-----------------------------------------------------------------------------</span><br><span class="line">// &quot;update&quot; state</span><br><span class="line">// compute the next state for the micro-op in this slot. This micro-op may</span><br><span class="line">// be moved elsewhere, so the &quot;next_state&quot; travels with it.</span><br><span class="line"></span><br><span class="line">// defaults</span><br><span class="line">next_state := state</span><br><span class="line">next_uopc := slot_uop.uopc</span><br><span class="line">next_lrs1_rtype := slot_uop.lrs1_rtype</span><br><span class="line">next_lrs2_rtype := slot_uop.lrs2_rtype</span><br><span class="line"></span><br><span class="line">when (io.kill) &#123;</span><br><span class="line">  next_state := s_invalid</span><br><span class="line">&#125; .elsewhen ((io.grant &amp;&amp; (state === s_valid_1)) ||</span><br><span class="line">  (io.grant &amp;&amp; (state === s_valid_2) &amp;&amp; p1 &amp;&amp; p2 &amp;&amp; ppred)) &#123;</span><br><span class="line">  // try to issue this uop.</span><br><span class="line">  when (!(io.ldspec_miss &amp;&amp; (p1_poisoned || p2_poisoned))) &#123;</span><br><span class="line">    next_state := s_invalid</span><br><span class="line">  &#125;</span><br><span class="line">&#125; .elsewhen (io.grant &amp;&amp; (state === s_valid_2)) &#123;</span><br><span class="line">  when (!(io.ldspec_miss &amp;&amp; (p1_poisoned || p2_poisoned))) &#123;</span><br><span class="line">    next_state := s_valid_1</span><br><span class="line">    when (p1) &#123;</span><br><span class="line">      slot_uop.uopc := uopSTD</span><br><span class="line">      next_uopc := uopSTD</span><br><span class="line">      slot_uop.lrs1_rtype := RT_X</span><br><span class="line">      next_lrs1_rtype := RT_X</span><br><span class="line">    &#125; .otherwise &#123;</span><br><span class="line">      slot_uop.lrs2_rtype := RT_X</span><br><span class="line">      next_lrs2_rtype := RT_X</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">when (io.in_uop.valid) &#123;</span><br><span class="line">  slot_uop := io.in_uop.bits</span><br><span class="line">  assert (is_invalid || io.clear || io.kill, &quot;trying to overwrite a valid issue slot.&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当冲刷流水线,就把next_state设置为无效,当grant为高,可以并且状态为v1(s_valid_1),或者是v2,且操作数准备好了,就说明可以发射了,如果没有遇到load推测唤醒失败,就把next_state设置为s_invalid,假如state为v2并且grant,如果没发生load推测唤醒失败,就把next_state设置为v1,然后看准备好的是数据还是地址,分别被uopc赋值为相应类型,如果in_uop.valid,就把slot更新为io.in_uop.bits</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Wakeup Compare Logic</span><br><span class="line"></span><br><span class="line">// these signals are the &quot;next_p*&quot; for the current slot&#x27;s micro-op.</span><br><span class="line">// they are important for shifting the current slot_uop up to an other entry.</span><br><span class="line">val next_p1 = WireInit(p1)</span><br><span class="line">val next_p2 = WireInit(p2)</span><br><span class="line">val next_p3 = WireInit(p3)</span><br><span class="line">val next_ppred = WireInit(ppred)</span><br><span class="line"></span><br><span class="line">when (io.in_uop.valid) &#123;</span><br><span class="line">  p1 := !(io.in_uop.bits.prs1_busy)</span><br><span class="line">  p2 := !(io.in_uop.bits.prs2_busy)</span><br><span class="line">  p3 := !(io.in_uop.bits.prs3_busy)</span><br><span class="line">  ppred := !(io.in_uop.bits.ppred_busy)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">when (io.ldspec_miss &amp;&amp; next_p1_poisoned) &#123;</span><br><span class="line">  assert(next_uop.prs1 =/= 0.U, &quot;Poison bit can&#x27;t be set for prs1=x0!&quot;)</span><br><span class="line">  p1 := false.B</span><br><span class="line">&#125;</span><br><span class="line">when (io.ldspec_miss &amp;&amp; next_p2_poisoned) &#123;</span><br><span class="line">  assert(next_uop.prs2 =/= 0.U, &quot;Poison bit can&#x27;t be set for prs2=x0!&quot;)</span><br><span class="line">  p2 := false.B</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (i &lt;- 0 until numWakeupPorts) &#123;</span><br><span class="line">  when (io.wakeup_ports(i).valid &amp;&amp;</span><br><span class="line">       (io.wakeup_ports(i).bits.pdst === next_uop.prs1)) &#123;</span><br><span class="line">    p1 := true.B</span><br><span class="line">  &#125;</span><br><span class="line">  when (io.wakeup_ports(i).valid &amp;&amp;</span><br><span class="line">       (io.wakeup_ports(i).bits.pdst === next_uop.prs2)) &#123;</span><br><span class="line">    p2 := true.B</span><br><span class="line">  &#125;</span><br><span class="line">  when (io.wakeup_ports(i).valid &amp;&amp;</span><br><span class="line">       (io.wakeup_ports(i).bits.pdst === next_uop.prs3)) &#123;</span><br><span class="line">    p3 := true.B</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">when (io.pred_wakeup_port.valid &amp;&amp; io.pred_wakeup_port.bits === next_uop.ppred) &#123;</span><br><span class="line">  ppred := true.B</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (w &lt;- 0 until memWidth) &#123;</span><br><span class="line">  assert (!(io.spec_ld_wakeup(w).valid &amp;&amp; io.spec_ld_wakeup(w).bits === 0.U),</span><br><span class="line">    &quot;Loads to x0 should never speculatively wakeup other instructions&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// TODO disable if FP IQ.</span><br><span class="line">for (w &lt;- 0 until memWidth) &#123;</span><br><span class="line">  when (io.spec_ld_wakeup(w).valid &amp;&amp;</span><br><span class="line">    io.spec_ld_wakeup(w).bits === next_uop.prs1 &amp;&amp;</span><br><span class="line">    next_uop.lrs1_rtype === RT_FIX) &#123;</span><br><span class="line">    p1 := true.B</span><br><span class="line">    p1_poisoned := true.B</span><br><span class="line">    assert (!next_p1_poisoned)</span><br><span class="line">  &#125;</span><br><span class="line">  when (io.spec_ld_wakeup(w).valid &amp;&amp;</span><br><span class="line">    io.spec_ld_wakeup(w).bits === next_uop.prs2 &amp;&amp;</span><br><span class="line">    next_uop.lrs2_rtype === RT_FIX) &#123;</span><br><span class="line">    p2 := true.B</span><br><span class="line">    p2_poisoned := true.B</span><br><span class="line">    assert (!next_p2_poisoned)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来是唤醒逻辑,首先定义了四个next前缀的信号,这些信号用于压缩队列,然后就是如果输入有效数据,检查输入的rs1,rs2,rs3是否busy,也就是是否被写入prf(在Busytable没表项),如果推测唤醒失败,就把p1置为false,其他同理,然后检查每个wakeupport,如果有port有效,并且pdst等于slot的src,就把该寄存器ready,然后是推测唤醒逻辑:</p>
<p>TODO</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Request Logic</span><br><span class="line">io.request := is_valid &amp;&amp; p1 &amp;&amp; p2 &amp;&amp; p3 &amp;&amp; ppred &amp;&amp; !io.kill</span><br><span class="line">val high_priority = slot_uop.is_br || slot_uop.is_jal || slot_uop.is_jalr</span><br><span class="line">io.request_hp := io.request &amp;&amp; high_priority</span><br><span class="line"></span><br><span class="line">when (state === s_valid_1) &#123;</span><br><span class="line">  io.request := p1 &amp;&amp; p2 &amp;&amp; p3 &amp;&amp; ppred &amp;&amp; !io.kill</span><br><span class="line">&#125; .elsewhen (state === s_valid_2) &#123;</span><br><span class="line">  io.request := (p1 || p2) &amp;&amp; ppred &amp;&amp; !io.kill</span><br><span class="line">&#125; .otherwise &#123;</span><br><span class="line">  io.request := false.B</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接下来为req逻辑,只要p1,p2,p3准备好就可以req了,由于大部分指令为两个src,所以p3一般为默认值,也就是true,最后就是一些连线逻辑</p>
<h2 id="Issue-Unit"><a href="#Issue-Unit" class="headerlink" title="Issue Unit"></a>Issue Unit</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Abstract top level issue unit</span><br><span class="line"> *</span><br><span class="line"> * @param numIssueSlots depth of issue queue</span><br><span class="line"> * @param issueWidth amoutn of operations that can be issued at once</span><br><span class="line"> * @param numWakeupPorts number of wakeup ports for issue unit</span><br><span class="line"> * @param iqType type of issue queue (mem, int, fp)</span><br><span class="line"> */</span><br><span class="line">abstract class IssueUnit(</span><br><span class="line">  val numIssueSlots: Int,</span><br><span class="line">  val issueWidth: Int,</span><br><span class="line">  val numWakeupPorts: Int,</span><br><span class="line">  val iqType: BigInt,</span><br><span class="line">  val dispatchWidth: Int)</span><br><span class="line">  (implicit p: Parameters)</span><br><span class="line">  extends BoomModule</span><br><span class="line">  with IssueUnitConstants</span><br><span class="line">&#123;</span><br><span class="line">  val io = IO(new IssueUnitIO(issueWidth, numWakeupPorts, dispatchWidth))</span><br><span class="line"></span><br><span class="line">  //-------------------------------------------------------------</span><br><span class="line">  // Set up the dispatch uops</span><br><span class="line">  // special case &quot;storing&quot; 2 uops within one issue slot.</span><br><span class="line"></span><br><span class="line">  val dis_uops = Array.fill(dispatchWidth) &#123;Wire(new MicroOp())&#125;</span><br><span class="line">  for (w &lt;- 0 until dispatchWidth) &#123;</span><br><span class="line">    dis_uops(w) := io.dis_uops(w).bits</span><br><span class="line">    dis_uops(w).iw_p1_poisoned := false.B</span><br><span class="line">    dis_uops(w).iw_p2_poisoned := false.B</span><br><span class="line">    dis_uops(w).iw_state := s_valid_1</span><br><span class="line"></span><br><span class="line">    if (iqType == IQT_MEM.litValue || iqType == IQT_INT.litValue) &#123;</span><br><span class="line">      // For StoreAddrGen for Int, or AMOAddrGen, we go to addr gen state</span><br><span class="line">      when ((io.dis_uops(w).bits.uopc === uopSTA &amp;&amp; io.dis_uops(w).bits.lrs2_rtype === RT_FIX) ||</span><br><span class="line">             io.dis_uops(w).bits.uopc === uopAMO_AG) &#123;</span><br><span class="line">        dis_uops(w).iw_state := s_valid_2</span><br><span class="line">        // For store addr gen for FP, rs2 is the FP register, and we don&#x27;t wait for that here</span><br><span class="line">      &#125; .elsewhen (io.dis_uops(w).bits.uopc === uopSTA &amp;&amp; io.dis_uops(w).bits.lrs2_rtype =/= RT_FIX) &#123;</span><br><span class="line">        dis_uops(w).lrs2_rtype := RT_X</span><br><span class="line">        dis_uops(w).prs2_busy  := false.B</span><br><span class="line">      &#125;</span><br><span class="line">      dis_uops(w).prs3_busy := false.B</span><br><span class="line">    &#125; else if (iqType == IQT_FP.litValue) &#123;</span><br><span class="line">      // FP &quot;StoreAddrGen&quot; is really storeDataGen, and rs1 is the integer address register</span><br><span class="line">      when (io.dis_uops(w).bits.uopc === uopSTA) &#123;</span><br><span class="line">        dis_uops(w).lrs1_rtype := RT_X</span><br><span class="line">        dis_uops(w).prs1_busy  := false.B</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (iqType != IQT_INT.litValue) &#123;</span><br><span class="line">      assert(!(io.dis_uops(w).bits.ppred_busy &amp;&amp; io.dis_uops(w).valid))</span><br><span class="line">      dis_uops(w).ppred_busy := false.B</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  </span><br></pre></td></tr></table></figure>

<p>我们这个抽象类,主要参数有issue queue大小,一次可以发射多少,唤醒port,issue的类型(mem,int,fp),然后创建了一个dis_uops,将来自dispatch的信号传入,然后将dip_uops初始化为dispatch数据,状态设置为v1(代表一般指令,),然后根据iq类型来分别进一步初始化,对于int类型的之后将prs3置为空闲,而mem不仅置为空闲,还检查是STA对state初始化为v2</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//-------------------------------------------------------------</span><br><span class="line">// Issue Table</span><br><span class="line"></span><br><span class="line">val slots = for (i &lt;- 0 until numIssueSlots) yield &#123; val slot = Module(new IssueSlot(numWakeupPorts)); slot &#125;</span><br><span class="line">val issue_slots = VecInit(slots.map(_.io))</span><br><span class="line"></span><br><span class="line">for (i &lt;- 0 until numIssueSlots) &#123;</span><br><span class="line">  issue_slots(i).wakeup_ports     := io.wakeup_ports</span><br><span class="line">  issue_slots(i).pred_wakeup_port := io.pred_wakeup_port</span><br><span class="line">  issue_slots(i).spec_ld_wakeup   := io.spec_ld_wakeup</span><br><span class="line">  issue_slots(i).ldspec_miss      := io.ld_miss</span><br><span class="line">  issue_slots(i).brupdate         := io.brupdate</span><br><span class="line">  issue_slots(i).kill             := io.flush_pipeline</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">io.event_empty := !(issue_slots.map(s =&gt; s.valid).reduce(_|_))</span><br><span class="line"></span><br><span class="line">val count = PopCount(slots.map(_.io.valid))</span><br><span class="line">dontTouch(count)</span><br></pre></td></tr></table></figure>

<p>接下来就是创建slot,连线,</p>
<h2 id="IssueUnitStatic"><a href="#IssueUnitStatic" class="headerlink" title="IssueUnitStatic"></a>IssueUnitStatic</h2><p>然后讲解非压缩队列</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">val entry_wen_oh = VecInit(Seq.fill(numIssueSlots)&#123; Wire(Bits(dispatchWidth.W)) &#125;)</span><br><span class="line">for (i &lt;- 0 until numIssueSlots) &#123;</span><br><span class="line">  issue_slots(i).in_uop.valid := entry_wen_oh(i).orR</span><br><span class="line">  issue_slots(i).in_uop.bits  := Mux1H(entry_wen_oh(i), dis_uops)</span><br><span class="line">  issue_slots(i).clear        := false.B</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先是表项写使能,这个entry_wen_oh会在后面赋值,这个是dispatch传来的,然后将数据传入issue slot,这里使用one hot 编码,这个会在之后讲解,将clear设置为false</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//-------------------------------------------------------------</span><br><span class="line">// Dispatch/Entry Logic</span><br><span class="line">// find a slot to enter a new dispatched instruction</span><br><span class="line"></span><br><span class="line">val entry_wen_oh_array = Array.fill(numIssueSlots,dispatchWidth)&#123;false.B&#125;</span><br><span class="line">var allocated = VecInit(Seq.fill(dispatchWidth)&#123;false.B&#125;) // did an instruction find an issue width?</span><br><span class="line"></span><br><span class="line">for (i &lt;- 0 until numIssueSlots) &#123;</span><br><span class="line">  var next_allocated = Wire(Vec(dispatchWidth, Bool()))</span><br><span class="line">  var can_allocate = !(issue_slots(i).valid)</span><br><span class="line"></span><br><span class="line">  for (w &lt;- 0 until dispatchWidth) &#123;</span><br><span class="line">    entry_wen_oh_array(i)(w) = can_allocate &amp;&amp; !(allocated(w))</span><br><span class="line"></span><br><span class="line">    next_allocated(w) := can_allocate | allocated(w)</span><br><span class="line">    can_allocate = can_allocate &amp;&amp; allocated(w)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  allocated = next_allocated</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这是分发逻辑,首先创建一个entry_wen_oh_array,记录每个slot是否有dispatch的指令,然后allocated表示这个指令已经被分配了,然后进入两重循环,最底层循环就是看看这个slot是否空闲,如果空闲就将使能信号写入进去,然后把这个表项锁住,也就是将can_allocate置低,举例:</p>
<p>假设dispatch为4位使用一个四位变量allocate&#x3D;(0,0,0,0)表示指令都没分发出去,假设指令0,找到了一个空slot,我们就可以把这个空槽占据了,然后next_allocate&#x3D;(1,0,0,0)然后can_allocate由于allocated为false,所以置低,最后第一次循环完,next_allocate为(1,0,0,0),can_allocate&#x3D;false,这个slot接受不到其他的指令了,已经被指令0占据了,内层循环完毕,把next_allocate赋值给allocate</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// if we can find an issue slot, do we actually need it?</span><br><span class="line">// also, translate from Scala data structures to Chisel Vecs</span><br><span class="line">for (i &lt;- 0 until numIssueSlots) &#123;</span><br><span class="line">  val temp_uop_val = Wire(Vec(dispatchWidth, Bool()))</span><br><span class="line"></span><br><span class="line">  for (w &lt;- 0 until dispatchWidth) &#123;</span><br><span class="line">    // TODO add ctrl bit for &quot;allocates iss_slot&quot;</span><br><span class="line">    temp_uop_val(w) := io.dis_uops(w).valid &amp;&amp;</span><br><span class="line">                       !dis_uops(w).exception &amp;&amp;</span><br><span class="line">                       !dis_uops(w).is_fence &amp;&amp;</span><br><span class="line">                       !dis_uops(w).is_fencei &amp;&amp;</span><br><span class="line">                       entry_wen_oh_array(i)(w)</span><br><span class="line">  &#125;</span><br><span class="line">  entry_wen_oh(i) := temp_uop_val.asUInt</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (w &lt;- 0 until dispatchWidth) &#123;</span><br><span class="line">  io.dis_uops(w).ready := allocated(w)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这段代码将上面得出的wen信号进一步处理,然后将wen赋值给一开始的entry_wen_oh,这样最上面的代码就可以找到哪个slot这次会被写入了,并且这个也得出了是那一条指令占据了哪个slot,假设有4个slot,dis大小也是4,最后这个entry_wen_oh可能是(1,0,0,0),(0,1,0,0),(0,0,1,0),(0,0,0,1),也就是得到了每条指令要写入哪个slot的信息,完成分配的信号就是allocate对应位为1,</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (w &lt;- 0 until issueWidth) &#123;</span><br><span class="line">  io.iss_valids(w) := false.B</span><br><span class="line">  io.iss_uops(w)   := NullMicroOp</span><br><span class="line">  // unsure if this is overkill</span><br><span class="line">  io.iss_uops(w).prs1 := 0.U</span><br><span class="line">  io.iss_uops(w).prs2 := 0.U</span><br><span class="line">  io.iss_uops(w).prs3 := 0.U</span><br><span class="line">  io.iss_uops(w).lrs1_rtype := RT_X</span><br><span class="line">  io.iss_uops(w).lrs2_rtype := RT_X</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来为仲裁逻辑,首先对issue信号初始化</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// TODO can we use flatten to get an array of bools on issue_slot(*).request?</span><br><span class="line">  val lo_request_not_satisfied = Array.fill(numIssueSlots)&#123;Bool()&#125;</span><br><span class="line">  val hi_request_not_satisfied = Array.fill(numIssueSlots)&#123;Bool()&#125;</span><br><span class="line"></span><br><span class="line">  for (i &lt;- 0 until numIssueSlots) &#123;</span><br><span class="line">    lo_request_not_satisfied(i) = issue_slots(i).request</span><br><span class="line">    hi_request_not_satisfied(i) = issue_slots(i).request_hp</span><br><span class="line">    issue_slots(i).grant := false.B // default</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  for (w &lt;- 0 until issueWidth) &#123;</span><br><span class="line">    var port_issued = false.B</span><br><span class="line"></span><br><span class="line">    // first look for high priority requests</span><br><span class="line">    for (i &lt;- 0 until numIssueSlots) &#123;</span><br><span class="line">      val can_allocate = (issue_slots(i).uop.fu_code &amp; io.fu_types(w)) =/= 0.U</span><br><span class="line"></span><br><span class="line">      when (hi_request_not_satisfied(i) &amp;&amp; can_allocate &amp;&amp; !port_issued) &#123;</span><br><span class="line">        issue_slots(i).grant := true.B</span><br><span class="line">        io.iss_valids(w)     := true.B</span><br><span class="line">        io.iss_uops(w)       := issue_slots(i).uop</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      val port_already_in_use     = port_issued</span><br><span class="line">      port_issued                 = (hi_request_not_satisfied(i) &amp;&amp; can_allocate) | port_issued</span><br><span class="line">      // deassert lo_request if hi_request is 1.</span><br><span class="line">      lo_request_not_satisfied(i) = (lo_request_not_satisfied(i) &amp;&amp; !hi_request_not_satisfied(i))</span><br><span class="line">      // if request is 0, stay 0. only stay 1 if request is true and can&#x27;t allocate</span><br><span class="line">      hi_request_not_satisfied(i) = (hi_request_not_satisfied(i) &amp;&amp; (!can_allocate || port_already_in_use))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // now look for low priority requests</span><br><span class="line">    for (i &lt;- 0 until numIssueSlots) &#123;</span><br><span class="line">      val can_allocate = (issue_slots(i).uop.fu_code &amp; io.fu_types(w)) =/= 0.U</span><br><span class="line"></span><br><span class="line">      when (lo_request_not_satisfied(i) &amp;&amp; can_allocate &amp;&amp; !port_issued) &#123;</span><br><span class="line">        issue_slots(i).grant := true.B</span><br><span class="line">        io.iss_valids(w)     := true.B</span><br><span class="line">        io.iss_uops(w)       := issue_slots(i).uop</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      val port_already_in_use     = port_issued</span><br><span class="line">      port_issued                 = (lo_request_not_satisfied(i) &amp;&amp; can_allocate) | port_issued</span><br><span class="line">      // if request is 0, stay 0. only stay 1 if request is true and can&#x27;t allocate or port already in use</span><br><span class="line">      lo_request_not_satisfied(i) = (lo_request_not_satisfied(i) &amp;&amp; (!can_allocate || port_already_in_use))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>首先把低级req和高级req从issue slot读出来,将grant置为低(初始化),然后进入仲裁逻辑,首先检查高优先级的req,首先有一个can_allocate信号,也就是匹配FU,如果匹配到FU,并且有高优先级请求,并且port_issue没有置为高,就发出grant信号,表示可以发射了,将slot的uop读出来,然后将这个port_issued置为高,接下来重新赋值低位请求,必须没有高位请求,低位请求才生效,如果有高级请求,但FU没匹配成功或者这个FU在用,就一直置为高位请求,接下来就是低级请求,其和高级请求的思路类似</p>
<h2 id="IssueUnitCollapsing"><a href="#IssueUnitCollapsing" class="headerlink" title="IssueUnitCollapsing"></a>IssueUnitCollapsing</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//-------------------------------------------------------------</span><br><span class="line">// Figure out how much to shift entries by</span><br><span class="line"></span><br><span class="line">val maxShift = dispatchWidth</span><br><span class="line">val vacants = issue_slots.map(s =&gt; !(s.valid)) ++ io.dis_uops.map(_.valid).map(!_.asBool)</span><br><span class="line">val shamts_oh = Array.fill(numIssueSlots+dispatchWidth) &#123;Wire(UInt(width=maxShift.W))&#125;</span><br><span class="line">// track how many to shift up this entry by by counting previous vacant spots</span><br><span class="line">def SaturatingCounterOH(count_oh:UInt, inc: Bool, max: Int): UInt = &#123;</span><br><span class="line">   val next = Wire(UInt(width=max.W))</span><br><span class="line">   next := count_oh</span><br><span class="line">   when (count_oh === 0.U &amp;&amp; inc) &#123;</span><br><span class="line">     next := 1.U</span><br><span class="line">   &#125; .elsewhen (!count_oh(max-1) &amp;&amp; inc) &#123;</span><br><span class="line">     next := (count_oh &lt;&lt; 1.U)</span><br><span class="line">   &#125;</span><br><span class="line">   next</span><br><span class="line">&#125;</span><br><span class="line">shamts_oh(0) := 0.U</span><br><span class="line">for (i &lt;- 1 until numIssueSlots + dispatchWidth) &#123;</span><br><span class="line">  shamts_oh(i) := SaturatingCounterOH(shamts_oh(i-1), vacants(i-1), maxShift)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先定义最大位移的数字maxshift,然后vacants就是把issue slot和要写入的看看是不是有效的,之后讲解SaturatingCounterOH方法,这个方法定义了每个位置要位移多少,首先最底部的绝对不用位移,之后的位置位移取决于下面的是否是空的,如果是空的,就在下面的一个位置位移的基础上左移一位(one hot编码),如果不是one hot,只要在下面位置位移的基础+1即可,然后我们经过这个循环就得到了每一项要位移的数(one hot),</p>
<blockquote>
<p>不太明白这个maxshift为什么要以dispatchwidth为最大值,不该为issuewidth吗</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//-------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">// which entries&#x27; uops will still be next cycle? (not being issued and vacated)</span><br><span class="line">val will_be_valid = (0 until numIssueSlots).map(i =&gt; issue_slots(i).will_be_valid) ++</span><br><span class="line">                    (0 until dispatchWidth).map(i =&gt; io.dis_uops(i).valid &amp;&amp;</span><br><span class="line">                                                      !dis_uops(i).exception &amp;&amp;</span><br><span class="line">                                                      !dis_uops(i).is_fence &amp;&amp;</span><br><span class="line">                                                      !dis_uops(i).is_fencei)</span><br><span class="line"></span><br><span class="line">val uops = issue_slots.map(s=&gt;s.out_uop) ++ dis_uops.map(s=&gt;s)</span><br><span class="line">for (i &lt;- 0 until numIssueSlots) &#123;</span><br><span class="line">  issue_slots(i).in_uop.valid := false.B</span><br><span class="line">  issue_slots(i).in_uop.bits  := uops(i+1)</span><br><span class="line">  for (j &lt;- 1 to maxShift by 1) &#123;</span><br><span class="line">    when (shamts_oh(i+j) === (1 &lt;&lt; (j-1)).U) &#123;</span><br><span class="line">      issue_slots(i).in_uop.valid := will_be_valid(i+j)</span><br><span class="line">      issue_slots(i).in_uop.bits  := uops(i+j)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  issue_slots(i).clear        := shamts_oh(i) =/= 0.U</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这几段代码主要讲的就是issue和dispatch的表项是否在下个周期还有效,也就是他是否发射出去了或者被清除了,然后循环内主要就是对slot移位,就是设置一个小循环,这个小循环检测是哪个移位进来的,</p>
<p>举例:</p>
<p>假设我们有四个slot,然后slot(0)是空的,其他都有数据,那么shamt(0)&#x3D;0,shamt(1)&#x3D;01,shamt(2)&#x3D;01,shamt(3)&#x3D;01,所以我们移位后就是3-&gt;2,2-&gt;1,1-&gt;0,假设i&#x3D;0,小循环第一次进入when,此时j&#x3D;1,这就完成了1-&gt;0的操作,由于slot(1)不是空的,所以这个循环只会进入一次when,最后出小循环将slot(0)的clear根据shamt(0)置为false</p>
<blockquote>
<p>最后一步的clear对移位后有数据的没什莫影响,因为in_valid优先级大于clear,但对高位置的slot有影响,比如这里就是对3有影响(假设没有指令dispatch进来)</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//-------------------------------------------------------------</span><br><span class="line">// Dispatch/Entry Logic</span><br><span class="line">// did we find a spot to slide the new dispatched uops into?</span><br><span class="line"></span><br><span class="line">val will_be_available = (0 until numIssueSlots).map(i =&gt;</span><br><span class="line">                          (!issue_slots(i).will_be_valid || issue_slots(i).clear) &amp;&amp; !(issue_slots(i).in_uop.valid))</span><br><span class="line">val num_available = PopCount(will_be_available)</span><br><span class="line">for (w &lt;- 0 until dispatchWidth) &#123;</span><br><span class="line">  io.dis_uops(w).ready := RegNext(num_available &gt; w.U)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码就是检测dispatch的指令是否写进来,will_be_available检查空的slot并且之后还被移入数据,然后num_available得到空slot的数目,如果num_available大于dispatchwidth,就说明分发好了,这里也就是空的slot大于分发的数目,注意,这里不保证每个都写进去,</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">//-------------------------------------------------------------</span><br><span class="line">// Issue Select Logic</span><br><span class="line"></span><br><span class="line">// set default</span><br><span class="line">for (w &lt;- 0 until issueWidth) &#123;</span><br><span class="line">  io.iss_valids(w) := false.B</span><br><span class="line">  io.iss_uops(w)   := NullMicroOp</span><br><span class="line">  // unsure if this is overkill</span><br><span class="line">  io.iss_uops(w).prs1 := 0.U</span><br><span class="line">  io.iss_uops(w).prs2 := 0.U</span><br><span class="line">  io.iss_uops(w).prs3 := 0.U</span><br><span class="line">  io.iss_uops(w).lrs1_rtype := RT_X</span><br><span class="line">  io.iss_uops(w).lrs2_rtype := RT_X</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">val requests = issue_slots.map(s =&gt; s.request)</span><br><span class="line">val port_issued = Array.fill(issueWidth)&#123;Bool()&#125;</span><br><span class="line">for (w &lt;- 0 until issueWidth) &#123;</span><br><span class="line">  port_issued(w) = false.B</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (i &lt;- 0 until numIssueSlots) &#123;</span><br><span class="line">  issue_slots(i).grant := false.B</span><br><span class="line">  var uop_issued = false.B</span><br><span class="line"></span><br><span class="line">  for (w &lt;- 0 until issueWidth) &#123;</span><br><span class="line">    val can_allocate = (issue_slots(i).uop.fu_code &amp; io.fu_types(w)) =/= 0.U</span><br><span class="line"></span><br><span class="line">    when (requests(i) &amp;&amp; !uop_issued &amp;&amp; can_allocate &amp;&amp; !port_issued(w)) &#123;</span><br><span class="line">      issue_slots(i).grant := true.B</span><br><span class="line">      io.iss_valids(w) := true.B</span><br><span class="line">      io.iss_uops(w) := issue_slots(i).uop</span><br><span class="line">    &#125;</span><br><span class="line">    val was_port_issued_yet = port_issued(w)</span><br><span class="line">    port_issued(w) = (requests(i) &amp;&amp; !uop_issued &amp;&amp; can_allocate) | port_issued(w)</span><br><span class="line">    uop_issued = (requests(i) &amp;&amp; can_allocate &amp;&amp; !was_port_issued_yet) | uop_issued</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后是仲裁逻辑,首先将issue信息初始化,然后找slot的req,之后去寻找可以issue的项,这里和非压缩类似,</p>
<h2 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h2><p>无论是压缩还是非压缩,issue都使用相同的slot,而且仲裁逻辑都是一样的,也就是从低slot扫描到高slot,直到凑齐发射指令</p>
<h1 id="Boom-regfile"><a href="#Boom-regfile" class="headerlink" title="Boom regfile"></a>Boom regfile</h1><h2 id="Regfile模块"><a href="#Regfile模块" class="headerlink" title="Regfile模块"></a>Regfile模块</h2><h3 id="读逻辑"><a href="#读逻辑" class="headerlink" title="读逻辑"></a>读逻辑</h3><p>首先检查是否有bypass数据,如果有的话,就选择读出的数据是bypass数据,注意这里选择bypass数据时是选择最新写入这个寄存器的值,,也就是采用Mux1H,得到bypass数据,注意这里提交都是等一个ROB行算完才可以提交并bypass,如果无bypass数据,就直接读出regfile的数</p>
<blockquote>
<p>这里的bypass是指W-&gt;R bypass</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (bypassableArray.reduce(_||_)) &#123;</span><br><span class="line">  val bypassable_wports = ArrayBuffer[Valid[RegisterFileWritePort]]()</span><br><span class="line">  io.write_ports zip bypassableArray map &#123; case (wport, b) =&gt; if (b) &#123; bypassable_wports += wport&#125; &#125;</span><br><span class="line"></span><br><span class="line">  for (i &lt;- 0 until numReadPorts) &#123;</span><br><span class="line">    val bypass_ens = bypassable_wports.map(x =&gt; x.valid &amp;&amp;</span><br><span class="line">      x.bits.addr === read_addrs(i))</span><br><span class="line">    //使用Mux1H得出最新的指令的bypass的结果</span><br><span class="line">    val bypass_data = Mux1H(VecInit(bypass_ens.toSeq), VecInit(bypassable_wports.map(_.bits.data).toSeq))</span><br><span class="line"></span><br><span class="line">    io.read_ports(i).data := Mux(bypass_ens.reduce(_|_), bypass_data, read_data(i))</span><br><span class="line">  &#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  for (i &lt;- 0 until numReadPorts) &#123;</span><br><span class="line">    io.read_ports(i).data := read_data(i)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="写逻辑"><a href="#写逻辑" class="headerlink" title="写逻辑"></a>写逻辑</h3><p>代码如下.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (wport &lt;- io.write_ports) &#123;</span><br><span class="line">  when (wport.valid) &#123;</span><br><span class="line">    regfile(wport.bits.addr) := wport.bits.data</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="RegisterRead模块"><a href="#RegisterRead模块" class="headerlink" title="RegisterRead模块"></a>RegisterRead模块</h2><h3 id="读端口逻辑"><a href="#读端口逻辑" class="headerlink" title="读端口逻辑"></a>读端口逻辑</h3><p>首先读出issue模块送入的rs的addr，将其送入rf模块，然后根据addr读出相应数据，主要这里读寄存器在issue，读出寄存器在RF阶段，然后exe_reg_uops是送往exe阶段的uops，这里的idx的意思就是充分利用每个端口，端口不与指令绑定，比如我有两条指令，一个需要2个读，一个需要1个写，所以我的读idx在循环内为（0，2）</p>
<ul>
<li><input disabled type="checkbox"> 暂时不知道为什么延迟的原因</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var idx = 0 // index into flattened read_ports array</span><br><span class="line">for (w &lt;- 0 until issueWidth) &#123;</span><br><span class="line">  val numReadPorts = numReadPortsArray(w)</span><br><span class="line"></span><br><span class="line">  // NOTE:</span><br><span class="line">  // rrdLatency==1, we need to send read address at end of ISS stage,</span><br><span class="line">  //    in order to get read data back at end of RRD stage.</span><br><span class="line"></span><br><span class="line">  val rs1_addr = io.iss_uops(w).prs1</span><br><span class="line">  val rs2_addr = io.iss_uops(w).prs2</span><br><span class="line">  val rs3_addr = io.iss_uops(w).prs3</span><br><span class="line">  val pred_addr = io.iss_uops(w).ppred</span><br><span class="line"></span><br><span class="line">  if (numReadPorts &gt; 0) io.rf_read_ports(idx+0).addr := rs1_addr</span><br><span class="line">  if (numReadPorts &gt; 1) io.rf_read_ports(idx+1).addr := rs2_addr</span><br><span class="line">  if (numReadPorts &gt; 2) io.rf_read_ports(idx+2).addr := rs3_addr</span><br><span class="line"></span><br><span class="line">  if (enableSFBOpt) io.prf_read_ports(w).addr := pred_addr</span><br><span class="line"></span><br><span class="line">  if (numReadPorts &gt; 0) rrd_rs1_data(w) := Mux(RegNext(rs1_addr === 0.U), 0.U, io.rf_read_ports(idx+0).data)</span><br><span class="line">  if (numReadPorts &gt; 1) rrd_rs2_data(w) := Mux(RegNext(rs2_addr === 0.U), 0.U, io.rf_read_ports(idx+1).data)</span><br><span class="line">  if (numReadPorts &gt; 2) rrd_rs3_data(w) := Mux(RegNext(rs3_addr === 0.U), 0.U, io.rf_read_ports(idx+2).data)</span><br><span class="line"></span><br><span class="line">  if (enableSFBOpt) rrd_pred_data(w) := Mux(RegNext(io.iss_uops(w).is_sfb_shadow), io.prf_read_ports(w).data, false.B)</span><br><span class="line"></span><br><span class="line">  val rrd_kill = io.kill || IsKilledByBranch(io.brupdate, rrd_uops(w))</span><br><span class="line"></span><br><span class="line">  exe_reg_valids(w) := Mux(rrd_kill, false.B, rrd_valids(w))</span><br><span class="line">  // TODO use only the valids signal, don&#x27;t require us to set nullUop</span><br><span class="line">  exe_reg_uops(w)   := Mux(rrd_kill, NullMicroOp, rrd_uops(w))</span><br><span class="line"></span><br><span class="line">  exe_reg_uops(w).br_mask := GetNewBrMask(io.brupdate, rrd_uops(w))</span><br><span class="line"></span><br><span class="line">  idx += numReadPorts</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="BYPASS逻辑"><a href="#BYPASS逻辑" class="headerlink" title="BYPASS逻辑"></a>BYPASS逻辑</h3><p>bypass不bypass寄存器rs3（FU），也就是只bypass INT，其中rs1_cases，rs2_cases得出了mux控制信号和data，然后MUXcase的意思就是默认为rrd_rs1_data，如果之后的条件满足，就选择之后的值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (w &lt;- 0 until issueWidth) &#123;</span><br><span class="line">  val numReadPorts = numReadPortsArray(w)</span><br><span class="line">  var rs1_cases = Array((false.B, 0.U(registerWidth.W)))</span><br><span class="line">  var rs2_cases = Array((false.B, 0.U(registerWidth.W)))</span><br><span class="line">  var pred_cases = Array((false.B, 0.U(1.W)))</span><br><span class="line"></span><br><span class="line">  val prs1       = rrd_uops(w).prs1</span><br><span class="line">  val lrs1_rtype = rrd_uops(w).lrs1_rtype</span><br><span class="line">  val prs2       = rrd_uops(w).prs2</span><br><span class="line">  val lrs2_rtype = rrd_uops(w).lrs2_rtype</span><br><span class="line">  val ppred      = rrd_uops(w).ppred</span><br><span class="line"></span><br><span class="line">  for (b &lt;- 0 until numTotalBypassPorts)</span><br><span class="line">  &#123;</span><br><span class="line">    val bypass = io.bypass(b)</span><br><span class="line">    // can&#x27;t use &quot;io.bypass.valid(b) since it would create a combinational loop on branch kills&quot;</span><br><span class="line">    rs1_cases ++= Array((bypass.valid &amp;&amp; (prs1 === bypass.bits.uop.pdst) &amp;&amp; bypass.bits.uop.rf_wen</span><br><span class="line">      &amp;&amp; bypass.bits.uop.dst_rtype === RT_FIX &amp;&amp; lrs1_rtype === RT_FIX &amp;&amp; (prs1 =/= 0.U), bypass.bits.data))</span><br><span class="line">    rs2_cases ++= Array((bypass.valid &amp;&amp; (prs2 === bypass.bits.uop.pdst) &amp;&amp; bypass.bits.uop.rf_wen</span><br><span class="line">      &amp;&amp; bypass.bits.uop.dst_rtype === RT_FIX &amp;&amp; lrs2_rtype === RT_FIX &amp;&amp; (prs2 =/= 0.U), bypass.bits.data))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  for (b &lt;- 0 until numTotalPredBypassPorts)</span><br><span class="line">  &#123;</span><br><span class="line">    val bypass = io.pred_bypass(b)</span><br><span class="line">    pred_cases ++= Array((bypass.valid &amp;&amp; (ppred === bypass.bits.uop.pdst) &amp;&amp; bypass.bits.uop.is_sfb_br, bypass.bits.data))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (numReadPorts &gt; 0) bypassed_rs1_data(w)  := MuxCase(rrd_rs1_data(w), rs1_cases)</span><br><span class="line">  if (numReadPorts &gt; 1) bypassed_rs2_data(w)  := MuxCase(rrd_rs2_data(w), rs2_cases)</span><br><span class="line">  if (enableSFBOpt)     bypassed_pred_data(w) := MuxCase(rrd_pred_data(w), pred_cases)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="送往执行阶段信号"><a href="#送往执行阶段信号" class="headerlink" title="送往执行阶段信号"></a>送往执行阶段信号</h3><p>代码如下，主要送了valid，数据和uops，注意这里是有pipe reg的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// set outputs to execute pipelines</span><br><span class="line">for (w &lt;- 0 until issueWidth) &#123;</span><br><span class="line">  val numReadPorts = numReadPortsArray(w)</span><br><span class="line"></span><br><span class="line">  io.exe_reqs(w).valid    := exe_reg_valids(w)</span><br><span class="line">  io.exe_reqs(w).bits.uop := exe_reg_uops(w)</span><br><span class="line">  if (numReadPorts &gt; 0) io.exe_reqs(w).bits.rs1_data := exe_reg_rs1_data(w)</span><br><span class="line">  if (numReadPorts &gt; 1) io.exe_reqs(w).bits.rs2_data := exe_reg_rs2_data(w)</span><br><span class="line">  if (numReadPorts &gt; 2) io.exe_reqs(w).bits.rs3_data := exe_reg_rs3_data(w)</span><br><span class="line">  if (enableSFBOpt)     io.exe_reqs(w).bits.pred_data := exe_reg_pred_data(w)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h3><p>regfile和regfile_read均有bypass逻辑，但前者只bypassW-&gt;R ,后者bypass所有有效的FU的数据（不包括FPU）</p>
<h1 id="BOOM-EXU"><a href="#BOOM-EXU" class="headerlink" title="BOOM EXU"></a>BOOM EXU</h1><p><img src="/2025/02/05/diplomacy&boom/1731814497133.png" alt="1731814497133"></p>
<p>BOOM是非数据捕捉模式，可以看到alu模块插入了寄存器，这里是为了和mul与FPU匹配，简化写入端口调度</p>
<h2 id="执行单元"><a href="#执行单元" class="headerlink" title="执行单元"></a>执行单元</h2><p><img src="/2025/02/05/diplomacy&boom/1731843369344.png" alt="1731843369344"></p>
<p>这个例子是一个INT ALU，和乘法器，issue每个issue端口，只与一个FU对话，执行单元就是一个抽象单元，其包装的rocketchip的功能单元</p>
<h3 id="PipelinedFunctionalUnit模块"><a href="#PipelinedFunctionalUnit模块" class="headerlink" title="PipelinedFunctionalUnit模块"></a>PipelinedFunctionalUnit模块</h3><p>这是流水线功能单元的抽象类,主要补充下面ALU的模块</p>
<h4 id="Response-信号"><a href="#Response-信号" class="headerlink" title="Response 信号"></a>Response 信号</h4><p>这里分了两种情况</p>
<ol>
<li>pipestage&gt;0:这时候,输出有效信号就是r_valid的最高索引,r_valid每个周期都检测是否有kill信号,以及分支预测失败,</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">io.resp.valid    := r_valids(numStages-1) &amp;&amp; !IsKilledByBranch(io.brupdate, r_uops(numStages-1))</span><br><span class="line">io.resp.bits.predicated := false.B</span><br><span class="line">io.resp.bits.uop := r_uops(numStages-1)</span><br><span class="line">io.resp.bits.uop.br_mask := GetNewBrMask(io.brupdate, r_uops(numStages-1))</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>pipestage&#x3D;&#x3D;0,这时候,输出有效信号直接是输入的有效信号并且不能在失败路径上,</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">io.resp.valid    := io.req.valid &amp;&amp; !IsKilledByBranch(io.brupdate, io.req.bits.uop)</span><br><span class="line">io.resp.bits.predicated := false.B</span><br><span class="line">io.resp.bits.uop := io.req.bits.uop</span><br><span class="line">io.resp.bits.uop.br_mask := GetNewBrMask(io.brupdate, io.req.bits.uop)</span><br></pre></td></tr></table></figure>

<h4 id="bypass-信号"><a href="#bypass-信号" class="headerlink" title="bypass 信号"></a>bypass 信号</h4><p>只有stage&gt;0才有bypass,如果earliestBypassStage为0(表示第一个周期就可以bypass),那么第一个bypass的uops就是输入的uops,之后的的bypass_uops就是相对应的r_uops,</p>
<blockquote>
<p>注:这里bypass为i,但r_uops为i-1,主要就是r_uops为流水线寄存器,在下一个周期才可以获得数据</p>
</blockquote>
<ul>
<li><input disabled type="checkbox"> 暂时不知道第一句是干什莫的,似乎在earliestBypassStage不为0才有用,但目前都是为0的情况</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">      if (numBypassStages &gt; 0) &#123;</span><br><span class="line">        io.bypass(i-1).bits.uop := r_uops(i-1)</span><br><span class="line">      &#125;</span><br><span class="line">...</span><br><span class="line">    if (numBypassStages &gt; 0 &amp;&amp; earliestBypassStage == 0) &#123;</span><br><span class="line">      io.bypass(0).bits.uop := io.req.bits.uop</span><br><span class="line"></span><br><span class="line">      for (i &lt;- 1 until numBypassStages) &#123;</span><br><span class="line">        io.bypass(i).bits.uop := r_uops(i-1)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="ALU模块"><a href="#ALU模块" class="headerlink" title="ALU模块"></a>ALU模块</h3><p>alu逻辑包含BR分支计算，以及正常指令计算</p>
<h4 id="数据选择"><a href="#数据选择" class="headerlink" title="数据选择"></a>数据选择</h4><ul>
<li>op1的数据来源有两个地方，PC以及读出的rs1</li>
<li>op2的数据来源有四个来源，IMM，IMM_C（仅限于CSR指令），RS2,NEXT（也即是下一个pc的位移，2or4）</li>
</ul>
<h4 id="分支处理"><a href="#分支处理" class="headerlink" title="分支处理"></a>分支处理</h4><ul>
<li>BR_N：也就是PC+4</li>
<li>BR_NE:不相等</li>
<li>BR_EQ：相等</li>
<li>。。。</li>
<li>BR_J:JUMP（jal）</li>
<li>BR_JR:JUMP REG（jalr）</li>
<li>PC_PLUS4：pc+4</li>
<li>PC_BRJMP：BR 目标地址</li>
<li>PC_BRJMP：jalr目标地址</li>
</ul>
<p>这里是检查送入的指令的类型是什么分支类型，根据控制信号该选什么样的target</p>
<p>is_taken的意思是这个分支是否跳转，假如输入有效，没有在错误路径，是分支指令并且PC不为pc+4，就进行跳转</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">val pc_sel = MuxLookup(uop.ctrl.br_type, PC_PLUS4,</span><br><span class="line">               Seq(   BR_N   -&gt; PC_PLUS4,</span><br><span class="line">                      BR_NE  -&gt; Mux(!br_eq,  PC_BRJMP, PC_PLUS4),</span><br><span class="line">                      BR_EQ  -&gt; Mux( br_eq,  PC_BRJMP, PC_PLUS4),</span><br><span class="line">                      BR_GE  -&gt; Mux(!br_lt,  PC_BRJMP, PC_PLUS4),</span><br><span class="line">                      BR_GEU -&gt; Mux(!br_ltu, PC_BRJMP, PC_PLUS4),</span><br><span class="line">                      BR_LT  -&gt; Mux( br_lt,  PC_BRJMP, PC_PLUS4),</span><br><span class="line">                      BR_LTU -&gt; Mux( br_ltu, PC_BRJMP, PC_PLUS4),</span><br><span class="line">                      BR_J   -&gt; PC_BRJMP,</span><br><span class="line">                      BR_JR  -&gt; PC_JALR</span><br><span class="line">                      ))</span><br><span class="line">val is_taken = io.req.valid &amp;&amp;</span><br><span class="line">                 !killed &amp;&amp;</span><br><span class="line">                 (uop.is_br || uop.is_jalr || uop.is_jal) &amp;&amp;</span><br><span class="line">                 (pc_sel =/= PC_PLUS4)</span><br></pre></td></tr></table></figure>

<h4 id="分支地址计算"><a href="#分支地址计算" class="headerlink" title="分支地址计算"></a>分支地址计算</h4><p>主要就是計算jalr的target,然后得出cfi_idx,访问前端FTQ,获得pc,next_val意思是下一条指令是否有效</p>
<p>jalr指令的误预测逻辑:</p>
<ul>
<li>下一条指令无效</li>
<li>下一条指令有效但pc不是实际计算的pc</li>
<li>没有被预测跳转,(在cfi找不到或者找到了但是无效预测)</li>
</ul>
<p>br指令的分支预测目标地址为target,供重定向使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    brinfo.jalr_target := jalr_target</span><br><span class="line">    val cfi_idx = ((uop.pc_lob ^ Mux(io.get_ftq_pc.entry.start_bank === 1.U, 1.U &lt;&lt; log2Ceil(bankBytes), 0.U)))(log2Ceil(fetchWidth),1)</span><br><span class="line"></span><br><span class="line">    when (pc_sel === PC_JALR) &#123;</span><br><span class="line">      mispredict := !io.get_ftq_pc.next_val ||</span><br><span class="line">                    (io.get_ftq_pc.next_pc =/= jalr_target) ||</span><br><span class="line">                    !io.get_ftq_pc.entry.cfi_idx.valid ||</span><br><span class="line">                    (io.get_ftq_pc.entry.cfi_idx.bits =/= cfi_idx)</span><br><span class="line">    &#125;</span><br><span class="line">brinfo.target_offset := target_offset</span><br></pre></td></tr></table></figure>

<h4 id="分支预测失败检测"><a href="#分支预测失败检测" class="headerlink" title="分支预测失败检测"></a>分支预测失败检测</h4><p>首先，jal不参与检查，因为jal是必然跳转，且地址固定，jalr和br进行地址检测</p>
<p>如果pc_sel为PC_PLUS4，说明实际为不跳转，如果之前为taken，就说明地址预测失败</p>
<p>如果pc_sel为PC_BRJMP,说明实际跳转，如果之前预测taken，则地址预测成功</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">when (is_br || is_jalr) &#123;</span><br><span class="line">  if (!isJmpUnit) &#123;</span><br><span class="line">    assert (pc_sel =/= PC_JALR)</span><br><span class="line">  &#125;</span><br><span class="line">  when (pc_sel === PC_PLUS4) &#123;</span><br><span class="line">    mispredict := uop.taken</span><br><span class="line">  &#125;</span><br><span class="line">  when (pc_sel === PC_BRJMP) &#123;</span><br><span class="line">    mispredict := !uop.taken</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Response逻辑"><a href="#Response逻辑" class="headerlink" title="Response逻辑"></a>Response逻辑</h4><p>ALU out有以下来源:</p>
<ul>
<li>如果是is_sfb_shadow,并且pred_data,如果是ldst_rs1需要rs1,则把rs1当作结果,否則就是rs2(这个和BOOM的SFB有关)</li>
<li>如果为MOV指令,就选择rs2为输出,否则就是选择alu计算的结果</li>
</ul>
<p>然后就是流水线逻辑,在s1将数据送入流水线,时候根据numstage选择流水级,最后输出的数据就是r_data的最高索引</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">r_val (0) := io.req.valid</span><br><span class="line">r_data(0) := Mux(io.req.bits.uop.is_sfb_br, pc_sel === PC_BRJMP, alu_out)</span><br><span class="line">r_pred(0) := io.req.bits.uop.is_sfb_shadow &amp;&amp; io.req.bits.pred_data</span><br><span class="line">for (i &lt;- 1 until numStages) &#123;</span><br><span class="line">  r_val(i)  := r_val(i-1)</span><br><span class="line">  r_data(i) := r_data(i-1)</span><br><span class="line">  r_pred(i) := r_pred(i-1)</span><br><span class="line">&#125;</span><br><span class="line">io.resp.bits.data := r_data(numStages-1)</span><br><span class="line">io.resp.bits.predicated := r_pred(numStages-1)</span><br></pre></td></tr></table></figure>

<h4 id="Bypass逻辑"><a href="#Bypass逻辑" class="headerlink" title="Bypass逻辑"></a>Bypass逻辑</h4><p>将各阶段的输出进行bypass,注意这里是有延迟一个周期的,也就是计算出来下个周期再bypass,</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">io.bypass(0).valid := io.req.valid</span><br><span class="line">io.bypass(0).bits.data := Mux(io.req.bits.uop.is_sfb_br, pc_sel === PC_BRJMP, alu_out)</span><br><span class="line">for (i &lt;- 1 until numStages) &#123;</span><br><span class="line">  io.bypass(i).valid := r_val(i-1)</span><br><span class="line">  io.bypass(i).bits.data := r_data(i-1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="其他模块"><a href="#其他模块" class="headerlink" title="其他模块"></a>其他模块</h3><ul>
<li>MemAddrCalcUnit:完成地址计算以及store_data接受,同时进行misalign检查</li>
<li>DIV模块,是unpipe的,调用rocket模块</li>
<li>MUL模块,调用了rocket的模块</li>
</ul>
<h2 id="ALUExeUnit"><a href="#ALUExeUnit" class="headerlink" title="ALUExeUnit"></a>ALUExeUnit</h2><p>这个模块是各种单独FU的集合,目前允许,ALU和MUL和DIV在一块,但MEM只能单独一个ALUExeUnit,</p>
<p>ALU Unit:这个模块包含BRU,他接受输入信号,然后只有ALU支持bypass</p>
<h3 id="输出逻辑"><a href="#输出逻辑" class="headerlink" title="输出逻辑"></a>输出逻辑</h3><p>输出信号主要有有效信号,数据,以及uops等,根据数据有效信号来得出数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">io.iresp.valid     := iresp_fu_units.map(_.io.resp.valid).reduce(_|_)</span><br><span class="line">io.iresp.bits.uop  := PriorityMux(iresp_fu_units.map(f =&gt;</span><br><span class="line">  (f.io.resp.valid, f.io.resp.bits.uop)).toSeq)</span><br><span class="line">io.iresp.bits.data := PriorityMux(iresp_fu_units.map(f =&gt;</span><br><span class="line">  (f.io.resp.valid, f.io.resp.bits.data)).toSeq)</span><br><span class="line">io.iresp.bits.predicated := PriorityMux(iresp_fu_units.map(f =&gt;</span><br><span class="line">  (f.io.resp.valid, f.io.resp.bits.predicated)).toSeq)</span><br></pre></td></tr></table></figure>

<h2 id="ExecutionUnits"><a href="#ExecutionUnits" class="headerlink" title="ExecutionUnits"></a>ExecutionUnits</h2><p>就是简单的连线模块</p>
<blockquote>
<p>为什么执行完直接写入寄存器，不会改变ARCH state吗?虽然写入寄存器，但仍然属于推测状态，这时，如果之前指令发生异常情况，这个指令的计算结果无效，从发生异常的指令重新执行，假如：r0之前的映射关系为（r0：p21），由于这里是统一PRF，只有改变了映射关系（提交阶段），状态才算改变，也就是虽然向p30写入数据了，但r0的映射关系目前还是p21，只有正确提交，r0的映射关系才会变为p30，如果下面指令之前有分支预测失败，假设我要是读取寄存器r0，那么还是p21的值，也就是最近正确写入的值</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">add r0，r1，r2</span><br><span class="line">add r0，r3，r0</span><br><span class="line">重命名后</span><br><span class="line">add p30，p11,p12</span><br><span class="line">add p31,p13,p30</span><br></pre></td></tr></table></figure>

<h1 id="BOOM-LSU"><a href="#BOOM-LSU" class="headerlink" title="BOOM LSU"></a>BOOM LSU</h1><h1 id="CDE学习记录"><a href="#CDE学习记录" class="headerlink" title="CDE学习记录"></a>CDE学习记录</h1><p>CDE其中有site&#x2F;here&#x2F;&#x2F;up:</p>
<p>site:记录查找发生时的Module的偏函数</p>
<p>here:在本模块的参数</p>
<p>up:上级链表的参数</p>
<p>接下来结合图片来解析如何进行参数创建和查询的,</p>
<p>引用自<a href="https://zhuanlan.zhihu.com/p/362770824">cde</a></p>
<p><img src="/2025/02/05/diplomacy&boom/1733282944206.png" alt="1733282944206"></p>
<p>首先是参数创建(Myconfig),参数继承于Config类,在这里定义的chain是这个参数列表的chain,Config使用辅助构造函数得到this(Parameters(f)),也就是传入的参数变为Parameters(f),</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Config(p: Parameters) extends Parameters &#123;</span><br><span class="line">  def this(f: (View, View, View) =&gt; PartialFunction[Any, Any]) =</span><br><span class="line">    this(Parameters(f))</span><br><span class="line"></span><br><span class="line">  protected[config] def chain[T](</span><br><span class="line">    site:  View,</span><br><span class="line">    here:  View,</span><br><span class="line">    up:    View,</span><br><span class="line">    pname: Field[T]</span><br><span class="line">  ) = p.chain(site, here, up, pname)</span><br><span class="line">  override def toString = this.getClass.getSimpleName</span><br><span class="line">  def toInstance = this</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Config继承自Parameters,而parameter内部含有apply方法,该方法返回新的对象PartialParameters(f),而这个PartialParameters,重载了chain:利用函数将数据转换为偏函数,然后找这个数据,如果找到了就返回数值,否则去上层链表查询,到这里其实已经完成了参数创建</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    def apply(f: (View, View, View) =&gt; PartialFunction[Any, Any]): Parameters =</span><br><span class="line">      new PartialParameters(f)</span><br><span class="line">...</span><br><span class="line">  private class PartialParameters(</span><br><span class="line">    f: (View, View, View) =&gt; PartialFunction[Any, Any])</span><br><span class="line">      extends Parameters &#123;</span><br><span class="line">    //如果找到了参数,就返回参数值,否则去上级链表查询</span><br><span class="line">    //使用Config创建的类chain的具体实现</span><br><span class="line">    protected[config] def chain[T](</span><br><span class="line">      site:  View,</span><br><span class="line">      here:  View,</span><br><span class="line">      up:    View,</span><br><span class="line">      pname: Field[T]</span><br><span class="line">    ) = &#123;</span><br><span class="line">      val g = f(site, here, up)</span><br><span class="line">      if (g.isDefinedAt(pname)) Some(g.apply(pname).asInstanceOf[T])</span><br><span class="line">      else up.find(pname)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接下来为链表增长,链表增长会使用alter方法,这个方法返回一个ChainParameters(rhs, this)类,这个类的第一个参数为新的参数,第二个参数为现在的参数,</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">final def alter(rhs: Parameters): Parameters =</span><br><span class="line">  new ChainParameters(rhs, this)</span><br><span class="line">final def alter(</span><br><span class="line">  f: (View, View, View) =&gt; PartialFunction[Any, Any]</span><br><span class="line">): Parameters =</span><br><span class="line">  alter(Parameters(f))</span><br><span class="line">final def alterPartial(f: PartialFunction[Any, Any]): Parameters =</span><br><span class="line">  alter(Parameters((_, _, _) =&gt; f))</span><br></pre></td></tr></table></figure>

<p>ChainParameters内部重载了方法chain,主要区别在于up变为了newChainView(y, site, up),也就是上级链表为y参数(传入的this),到这里完成了参数链表增长,组织成链表的最主要的就是ChainParameters</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  private class ChainView(head: Parameters, site: View, up: View) extends View &#123;</span><br><span class="line">    def find[T](pname: Field[T]) = head.chain(site, this, up, pname)</span><br><span class="line">  &#125;</span><br><span class="line">//将新的链表的up设置为本级链表</span><br><span class="line">  private class ChainParameters(x: Parameters, y: Parameters) extends Parameters &#123;</span><br><span class="line">    def chain[T](site: View, here: View, up: View, pname: Field[T]) = &#123;</span><br><span class="line">      x.chain(site, here, new ChainView(y, site, up), pname)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>接下来为参数链表查询,首先在Hello world模块内部含有p(WIDTH),这个调用了View类内部的apply方法,其作用就是查询pname,然后在Parameters类里面定义了find方法,调用chain,由于我们的p参数继承于Config,首先就会将chain方法重载为PartialParameters的方法,由于Hello world本身就是最底部链表,所以直接查询这个链表就行,显然这里是可以查询到的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    final def apply[T](pname: Field[T]): T = &#123;</span><br><span class="line">      val out = find(pname)</span><br><span class="line">      require(out.isDefined, s&quot;Key $&#123;pname&#125; is not defined in Parameters&quot;)</span><br><span class="line">      out.get</span><br><span class="line">    &#125;</span><br><span class="line">....</span><br><span class="line">    protected[config] def find[T](pname: Field[T]): Option[T] =</span><br><span class="line">      chain(this, this, new TerminalView, pname)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>ModuleA内部也含有p(WIDTH),这个参数来自新的参数链表,使用的chain为PartialParameters重载的chain方法,也就是先在本级chain查询,查询不到参数,去up列表查询,注意我们之前链表增长在ChainParameters修改了新的链表的up为newChainView(y, site, up),而这个里面有个find方法,这对应了PartialParameters内部chain的find方法,也就是在head参数的列表找参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def find[T](pname: Field[T]) = head.chain(site, this, up, pname)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2025/02/05/diplomacy&boom/1733290412999.png" alt="1733290412999"></p>
<p>假设我在Hello world模块的参数如上所示,在ModuleA内部搜索p(DBWIDTH),这个链表搜不到,去上级链表搜索,上级链表DBWIDTH &#x3D; &gt;2 *here(WIDTH),这里就是在Myconfig参数表搜索WIDTH</p>
<p><img src="/2025/02/05/diplomacy&boom/1733290760437.png" alt="1733290760437"></p>
<p><img src="/2025/02/05/diplomacy&boom/1733290799819.png" alt="1733290799819"></p>
<p>step 1: 在ModuleA的参数表中查找DBWIDTH。发现没找到。</p>
<p>step 2: 上一层查找。找到了DBWIDTH。发现调用了site(A_TYPE)</p>
<p>step3: 由于site指向的是ModuleA的参数表，所以返回来执行ModuleA的参数表，查到ATYPE&#x3D;big_a</p>
<p>step 4:根据big_a查到参数等于6</p>
<p>site相当定位此时在寻找参数的属于哪个参数列表</p>
]]></content>
      <categories>
        <category>RISCV</category>
      </categories>
  </entry>
  <entry>
    <title>简单的缓存一致性</title>
    <url>/2025/02/05/%E7%AE%80%E5%8D%95%E7%9A%84%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/</url>
    <content><![CDATA[<p>目录式协议(directory)—-物理存储器中数据块的共享状态被保存在一个称为目录的地方。目录式协议的实现开销比监听式协议的稍微大一些,但可用于实现更大规模的多处理机。<br>监听式协议(snooping)—-当物理存储器中的数据块被调入 Cache 时，其共享状态信息与该数据块一起放在该 Cache 中。系统中没有集中的状态表。这些 Cache 通常连在共享存储器的总线上。当某个 Cache 需要访问存储器时,它会把请求放到总线上广播出去,其他各个 Cache 控制器通过监听总线(它们一直在监听)来判断它们是否有总线上请求的数据块。如果有,就进行相应的操作。</p>
<p>无论是MSI还是MESI,MOESI,都差不多按照以下思路分析:r_hit,r_miss,w_hit,w_miss讨论状态机实现,其中每个transaction对应3,4,5个状态(MSI-&gt;MESI-&gt;MOESI),且都要考虑本地cache和其他cache,如右图所示</p>
<p><img src="/2025/02/05/%E7%AE%80%E5%8D%95%E7%9A%84%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/1729944912699.png" alt="1729944912699"></p>
<ul>
<li>M，modified，表示该数据已修改，即上述所说的“脏”数据，需要在合适的时机写回内存；</li>
<li>E，Exclusive，表示该数据独占，意指此时该数据只存在某个核中，其他核没有该数据，于是就不需要所谓的广播给其他的核，也就没有缓存一致性的问题；</li>
<li>S，Shared，表示数据共享，是从<strong>数据独占</strong>状态转移过来的。意指多个核中都有该数据，这个时候就会存在缓存一致性的问题；</li>
<li>I，Invalidated，表示数据已失效，可以丢弃掉Cache Block的数据了（高并发情况下可能出现两个CPU同时修改变量a，并同时向总线发出将各自的缓存行更改为M状态的情况， <strong>此时总线会采用相应的裁决机制进行裁决</strong> ，将其中一个置为M状态，另一个置为I状态，且I状态的缓存行修改无效）；</li>
</ul>
<p>MESI四种状态标志是存储在Cache Line中的</p>
<h1 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a><strong>内存模型</strong></h1><h2 id="SC"><a href="#SC" class="headerlink" title="SC"></a>SC</h2><p>所有线程访存一定能构成全局序</p>
<p><img src="/2025/02/05/%E7%AE%80%E5%8D%95%E7%9A%84%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/1730373908924.png" alt="1730373908924"></p>
<p>所有load结果都是全局序中最近的同地址store值</p>
<p>  <img src="/2025/02/05/%E7%AE%80%E5%8D%95%E7%9A%84%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/1730373977856.png" alt="1730373977856"></p>
<h2 id="TSO"><a href="#TSO" class="headerlink" title="TSO"></a>TSO</h2><p><img src="/2025/02/05/%E7%AE%80%E5%8D%95%E7%9A%84%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/1730374094456.png" alt="1730374094456"><img src="/2025/02/05/%E7%AE%80%E5%8D%95%E7%9A%84%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/1730374216003.png" alt="1730374216003"></p>
<h2 id="RVWMO"><a href="#RVWMO" class="headerlink" title="RVWMO"></a>RVWMO</h2><p><img src="/2025/02/05/%E7%AE%80%E5%8D%95%E7%9A%84%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/1730374321974.png" alt="1730374321974"></p>
<p><img src="/2025/02/05/%E7%AE%80%E5%8D%95%E7%9A%84%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/1730374367495.png" alt="1730374367495"></p>
<h2 id="香山乱序访存"><a href="#香山乱序访存" class="headerlink" title="香山乱序访存"></a>香山乱序访存</h2><p>数据也会存到SQ</p>
<p><img src="/2025/02/05/%E7%AE%80%E5%8D%95%E7%9A%84%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/1730380794423.png" alt="1730380794423"></p>
<p>设置一个SQ,在派遣时将进入SQ,FIFO结构,当指令</p>
<p><img src="/2025/02/05/%E7%AE%80%E5%8D%95%E7%9A%84%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/1730380916400.png" alt="1730380916400"></p>
<p><img src="/2025/02/05/%E7%AE%80%E5%8D%95%E7%9A%84%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/1730381086089.png" alt="1730381086089"></p>
<p><img src="/2025/02/05/%E7%AE%80%E5%8D%95%E7%9A%84%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/1730381113849.png" alt="1730381113849"></p>
<p>当<strong>sw遇到TLBmiss</strong> 让她退出流水,然后在SQ标记重发<img src="/2025/02/05/%E7%AE%80%E5%8D%95%E7%9A%84%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/1730381020649.png" alt="1730381020649"></p>
<p><strong>load流水线</strong></p>
<p>load指令一方面数据来自DCache,另一方面来自SQ,而且SQ优先级更高,在读数据要对SQ和DCache的数据合并</p>
<p><strong>Store&#x2F;load违例:load先于store执行</strong></p>
<p>1.阻塞,load得等,等到之前的store指令地址计算完,算是部分乱序</p>
<p>2.检测:检测到了违例,直接从lw之后把指令刷掉,(一种是ROB,但ROB太大)</p>
<p>所以可以设置一个LQ,FIFO,是ROB子集只用存LW指令,dispatch入队,sw指令会检测是否有比其更年轻的load(ROB地址值作为age)已经执行完了,从lw下面指令全部刷了.重新取</p>
<p><img src="/2025/02/05/%E7%AE%80%E5%8D%95%E7%9A%84%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/1730381962804.png" alt="1730381962804"></p>
<p>load异常事件:</p>
<p>TLBmiss</p>
<p><img src="/2025/02/05/%E7%AE%80%E5%8D%95%E7%9A%84%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/1730382130178.png" alt="1730382130178"></p>
<p><img src="/2025/02/05/%E7%AE%80%E5%8D%95%E7%9A%84%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/1730382342283.png" alt="1730382342283"></p>
<p>取回数据然后对唤醒LQ的指令</p>
]]></content>
      <categories>
        <category>计算机体系结构</category>
      </categories>
  </entry>
  <entry>
    <title>超标量处理器设计</title>
    <url>/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h1 id="分支预测"><a href="#分支预测" class="headerlink" title="分支预测"></a>分支预测</h1><h1 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h1><h2 id="一般设计"><a href="#一般设计" class="headerlink" title="一般设计"></a>一般设计</h2><p>1.时间相关性:被访问的数据将来很有可能再次被访问</p>
<p>2.空间相关性:一个数据被访问,其周围空间的数据也有可能被访问</p>
<p>Cache主要由两部分:TAG和DATA</p>
<h3 id="Cache术语"><a href="#Cache术语" class="headerlink" title="Cache术语"></a>Cache术语</h3><p>Cache line:一个tag和他对应的数据组成,其中的data部分称为data block</p>
<p>Cache set:一个index对应多个cache line 这些line组成cache set</p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729585610357.png" alt="1729585610357"></p>
<h3 id="cache实现方式"><a href="#cache实现方式" class="headerlink" title="cache实现方式"></a>cache实现方式</h3><ol>
<li>直接映射:物理内存中数据,在cache中只有一个地方可以存放</li>
</ol>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729586075965.png" alt="1729586075965"></p>
<p>特点:缺失率相对高,但延迟低</p>
<ol start="2">
<li>组相联:物理内存中数据,在cache中有多个地方可以存放</li>
</ol>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729586093262.png" alt="1729586093262"></p>
<p>特点:</p>
<p>延迟比直接的大,但缺失率低</p>
<ol start="3">
<li>全相连:物理内存中数据,在cache中任意地方都可以存放</li>
</ol>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729586217909.png" alt="1729586217909"></p>
<p>特点:</p>
<p>相当于只有一个index的组相连</p>
<p>灵活度高,缺失率低,但延迟大(一次访存要比较大量内容),所以设计时大小不会太大</p>
<h3 id="流水线设计"><a href="#流水线设计" class="headerlink" title="流水线设计"></a>流水线设计</h3><ol>
<li><p>并行访问tag和data</p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729587002847.png" alt="1729587002847"></p>
</li>
<li><p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729587015169.png" alt="1729587015169"></p>
<p>这是一个四级流水的并行访问结构,第一个周期将addr分为tag,index,offset,第二个周期访问data和tag ram,第三个周期进行hit判断,并选出数据,第四个周期输出数据</p>
<p>特点:低时钟频率,高功耗</p>
</li>
<li><p>串行访问tag和data</p>
</li>
</ol>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729587338356.png" alt="1729587338356"></p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729587367038.png" alt="1729587367038"></p>
<p>这个主要与并行的区别体现在234周期,第二个周期只发出tag ram请求,第三个周期判断hit,然后发出data ram请求,第四个周期得出数据送入第五个周期,第五个周期通过offset选出相应数据</p>
<p>特点:频率高,但处理器性能可能降低</p>
<h2 id="Cache写入"><a href="#Cache写入" class="headerlink" title="Cache写入"></a>Cache写入</h2><h3 id="当发生写入时"><a href="#当发生写入时" class="headerlink" title="当发生写入时"></a>当发生写入时</h3><ul>
<li>write through:数据写入Dcache同时也写入下级存储器</li>
<li>write back:数据写入DCache,但不写入下级存储器,这时给这个写入的cache line设置 dirty位,当这个cacheline被替换时,将这个脏数据写入下级存储</li>
</ul>
<h3 id="当发生写缺失时"><a href="#当发生写缺失时" class="headerlink" title="当发生写缺失时"></a>当发生写缺失时</h3><ul>
<li>write allocate:首先从下级存储器取出缺失行的数据,然后将写入DCache的数据合并到这个数据块中,最后将这个数据块写入DCache</li>
<li>write non-allocate:将数据直接写入下级存储器,而不写入DCache</li>
</ul>
<h3 id="两种常见配合方法"><a href="#两种常见配合方法" class="headerlink" title="两种常见配合方法"></a>两种常见配合方法</h3><ul>
<li><p>write non-allocate + write through</p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729588238715.png" alt="1729588238715"></p>
</li>
<li><p>write allocate + write back</p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729588282799.png" alt="1729588282799"></p>
</li>
</ul>
<h3 id="Cache替换策略"><a href="#Cache替换策略" class="headerlink" title="Cache替换策略"></a>Cache替换策略</h3><ul>
<li><p>PLRU<br>实现方式通常为二叉树,每次更新(hit or miss)都是对从叶节点一直更新到根节点</p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729588503421.png" alt="1729588503421"></p>
</li>
<li><p>Random</p>
<p>随机找一个行替换</p>
</li>
<li><p>SRRIP</p>
<p>抗扫描,insertion为RRPV&#x3D;2,也就是替换完初始化为2,这样一些之后不会被使用的块可以被快速驱逐,一些常用的块也会随着命中promotion为0</p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729588673325.png" alt="1729588673325"></p>
</li>
<li><p>DRRIP</p>
<p>抗抖动+扫描,主要实现方式是通过set dueling来选择到底是SRRIP还是BRRIP</p>
<p>BRRIP就是小概率在RRPV&#x3D;2插入,大概率在RRPV&#x3D;3插入</p>
<p>参考文献:</p>
<p>High Performance Cache Replacement Using Re-Reference Interval Prediction (RRIP)</p>
</li>
</ul>
<h2 id="一些提高cache性能的方法"><a href="#一些提高cache性能的方法" class="headerlink" title="一些提高cache性能的方法"></a>一些提高cache性能的方法</h2><h3 id="写缓存"><a href="#写缓存" class="headerlink" title="写缓存"></a>写缓存</h3><p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729588903433.png" alt="1729588903433"></p>
<p>对于write back:dirty数据被替换,存入write buf,然后就可以在下级存储读出数据了,这个write buf数据空闲时写入下级存储</p>
<p>对于write through:数据写入DCache同时写入write buf</p>
<p>但cache发生缺失,不仅要在下级存储寻找数据,还要在write buf 寻找数据,而且写缓存的数据为最新数据,如果同时读出write buf和下级存储的数据,采用writebuf 的数据</p>
<h3 id="流水线"><a href="#流水线" class="headerlink" title="流水线"></a>流水线</h3><p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729589648859.png" alt="1729589648859"></p>
<p>load在hit情况只需要一个周期,但store指令在hit时,第一个周期比较,第二个中秋选择是否写入数据,假如store后紧接着load,这时load的数据可能在delayed store data中,需要做一个bypass,但其实这个有一个问题,也就是假如发生load aft store,这样会导致两个指令竞争addr端口,必须对两个指令进行调度,或者使用双端口cache</p>
<h3 id="多级结构"><a href="#多级结构" class="headerlink" title="多级结构"></a>多级结构</h3><p>inclusive:L2包含L1全部内容,且要求L2相连度大于L1(便于cache一致性管理,检查数据只需要检查l2cache的数据,l2含有,那就置为无效,l2没有那么l1必然没有)</p>
<p>当L1 miss时,访问L2cache,如果L2 miss,会找到替换的line,并将该line对应的l1cache 的line无效,然后返回数据</p>
<p>exclusive:L2与l1数据不同</p>
<h3 id="Victim-Cache"><a href="#Victim-Cache" class="headerlink" title="Victim Cache"></a>Victim Cache</h3><p>和write buf 较为相似(他是保存被替换的数据)</p>
<h3 id="预取"><a href="#预取" class="headerlink" title="预取"></a>预取</h3><h4 id="硬件预取"><a href="#硬件预取" class="headerlink" title="硬件预取"></a>硬件预取</h4><ul>
<li>总是取出下一行</li>
</ul>
<h4 id="软件预取"><a href="#软件预取" class="headerlink" title="软件预取"></a>软件预取</h4><h3 id="多端口Cache"><a href="#多端口Cache" class="headerlink" title="多端口Cache"></a>多端口Cache</h3><h4 id="True-Multi-port"><a href="#True-Multi-port" class="headerlink" title="True Multi-port"></a>True Multi-port</h4><p>需要对TAG和DATA  SRAM进行复制,改变的是SRAM</p>
<h4 id="Multiple-Cache-Copies"><a href="#Multiple-Cache-Copies" class="headerlink" title="Multiple Cache Copies"></a>Multiple Cache Copies</h4><p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729591163588.png" alt="1729591163588"></p>
<p>不需要改变SRAM,写时候,同时写入两个SRAM,一个cache 替换,另一个也得替换</p>
<h4 id="Multi-banking"><a href="#Multi-banking" class="headerlink" title="Multi-banking"></a>Multi-banking</h4><p>将Cache 的DATA分为多个bank,每个bank都有一个端口,如果一个周期内,多个端口访问的地址位于不同bank,不会引起任何问题,如果位于相同bank,会引起bank冲突,这种可以采用多个bank来缓解这个问题</p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729591581007.png" alt="1729591581007"></p>
<p>下图是AMD Opteron 处理器的cache,其参数如下</p>
<p>total size:64KB</p>
<p>two way</p>
<p>Data block size:64B</p>
<p>故offset:[5:0]</p>
<p>index[14:6]</p>
<p>而由于采用了bank,所以offset的高三位[5:3]是寻址bank的</p>
<p>这是一个VIPT的结构,使用虚拟的index寻址,物理的tag做对比,每个端口都含有一个TLB和TAG RAM,但DATA RAM大小不变</p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729600137859.png" alt="1729600137859"></p>
<h1 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h1><p>本章假设页大小为4K</p>
<h2 id="本章术语"><a href="#本章术语" class="headerlink" title="本章术语"></a>本章术语</h2><p>VA;虚拟地址</p>
<p>VPN:虚拟页</p>
<p>PT:页表</p>
<p>PTR:页表寄存器</p>
<p>PTE:页表表项</p>
<p>PA:物理地址</p>
<h2 id="多级页表组织方式"><a href="#多级页表组织方式" class="headerlink" title="多级页表组织方式"></a>多级页表组织方式</h2><p>下图为三级页表组织方式,在riscv中64位至少为3级页表(SV39,SV48,SV57),RV32的是SV32</p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729601490679.png" alt="1729601490679"></p>
<p>下面讲解RISCV的组织方式,RISCV使用SATP这个csr寄存器来保存第一级页表在物理内存的基地址,而第一级页表基地址+VA给的偏移地址就组成了这个地址在第一级PT的位置,然后第一级页表读出的地址为第二级页表的基地址,以此类推</p>
<p>所以含有三级页表的CPU执行LW或SW指令,要访问4次物理内存(3次页表访问,一次数据访问)</p>
<h2 id="Page-Fault"><a href="#Page-Fault" class="headerlink" title="Page Fault"></a>Page Fault</h2><p>如果发生页缺失,且物理内存无空间,此时OS会对一个页进行替换,覆盖这个页之前,需要将他内容写入硬盘,所以在每个PTE上加一个脏位,一个页内某个地址被写入,这个页对应的PTE脏位为1</p>
<p>硬件上需要做到:</p>
<ol>
<li>发现 page fault,生成异常,跳转到相应地址</li>
<li>当store指令指令,需要将PTE的脏位置为1</li>
<li>当访问物理内存,需要将PTE的USE位置为1</li>
</ol>
<h2 id="RV分页机制"><a href="#RV分页机制" class="headerlink" title="RV分页机制"></a>RV分页机制</h2><p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1730514239279.png" alt="1730514239279"></p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1730514249374.png" alt="1730514249374"></p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1731208221157.png" alt="1731208221157"></p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1731208201787.png" alt="1731208201787"></p>
<p>首先将a&#x3D;satp.ppnxPAGESIZZE,让i&#x3D;LEVELS-1,SV32是PAGESIZE&#x3D;4k,LEV&#x3D;2,有效的模式为S和U,然后pte就是a+va.vpn[i]×PTESIZE.(PTESIZE&#x3D;4 for SV32)(为什么要xPTEsize呢,vpn存储的是表项的个数,乘size才会变为地址),然后会进行PMP和PMA检查,如果PTE有效,且R&#x3D;0,X&#x3D;0这个是指向下一个节点的指针,i&#x3D;i-1然后a&#x3D;pte.ppn×PAGESIZE ,接着寻址下一个页表的PTE,如果R&#x3D;1,X&#x3D;1,就说明叶子PTE找到了,然后进行PMP</p>
<p>如果i&gt;0且pte.ppn[i-1:0]≠0,这个是一个superpage并且没有对齐</p>
<p>然后翻译完成:</p>
<p>地址:pa.pgoff &#x3D; va.pgoff.</p>
<p>如果i&gt;0,这就是一个superpage翻译,pa.ppn[i-1:0] &#x3D; va.vpn[i-1:0]</p>
<p>pa.ppn[LEVELS-1:i] &#x3D; pte.ppn[LEVELS-1:i].</p>
<p><strong>SFENCE.VMA</strong></p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1730370582883.png" alt="1730370582883"></p>
<p>当rs1&#x3D;x0并且rs2&#x3D;x0时，将刷新TLB所有表项。<br>当rs1!&#x3D;x0并且rs2&#x3D;x0时，将刷新TLB中虚拟页号与rs1中储存的虚拟页号相等的表项。<br>当rs1&#x3D;x0并且rs2!&#x3D;x0时，将刷新TLB中ASID与rs2中储存的ASID相等的表项。<br>当rs1!&#x3D;x0并且rs2!&#x3D;x0时，将刷新TLB中虚拟页号与rs1中储存的虚拟页号相等，并且ASID与rs2中储存的ASID相等的表项。</p>
<h2 id="加入TLB和Cache"><a href="#加入TLB和Cache" class="headerlink" title="加入TLB和Cache"></a>加入TLB和Cache</h2><h3 id="TLB设计"><a href="#TLB设计" class="headerlink" title="TLB设计"></a>TLB设计</h3><p>为了减少TLB缺失(只有时间相关性),一般采用全相联来组织TLB,现代处理器一般采用两级TLB,第一级私有,第二级共享</p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729604171685.png" alt="1729604171685"></p>
<p>如果送入的地址和TLB其中一个VPN相等,则TLB命中,送出PFN,如果没有,则发生TLB缺失,要去物理内存访问页表:</p>
<ol>
<li>假设物理内存找到的PTE有效,那么直接从页表得到这个地址,同时写回TLB</li>
<li>假设未找到,这样应该产生Page Fault,操作系统从硬盘将相应页搬移到物理内存,将他在物理内存的首地址放在页表对应的PTE,将PTE内容写入TLB</li>
</ol>
<h4 id="TLB缺失"><a href="#TLB缺失" class="headerlink" title="TLB缺失"></a>TLB缺失</h4><h5 id="缺失的一些情况"><a href="#缺失的一些情况" class="headerlink" title="缺失的一些情况"></a>缺失的一些情况</h5><ol>
<li>虚拟地址对应的页不在物理内存,此时页表没有对应PTE,而TLB内容来自页表,所以必然缺失</li>
<li>虚拟地址对应的页在物理内存,但这个PTE并未放入TLB</li>
<li>虚拟地址对应的页在物理内存,这个PTE被替换掉了</li>
</ol>
<p>解决TLB缺失的本质是找到映射关系,然后将映射关系写入TLB,这个过程称为<strong>PTW,目前的两种方式:</strong></p>
<ol>
<li>软件:一旦TLB缺失,硬件吧产生tlb缺失的虚拟地址保存到一个特殊寄存器,然后产生TLB缺失异常,软件通过这个寄存器内容寻址页表,找到对应的PTE,写回TLB(处理器需要有支持TLB的指令)</li>
<li>硬件:由MMU完成</li>
</ol>
<h5 id="TLB写入"><a href="#TLB写入" class="headerlink" title="TLB写入"></a>TLB写入</h5><p>加入tlb后,处理器送出的地址首先会访问tlb,如果命中,从tlb得出物理地址,如果tlb采用写回.那么dirty的页表不会立马从tlb写回到页表,导致页表的状态为可能是过时的,,操作系统可以认为tlb记录的页都是要被使用的,操作系统可以得知哪些pte被放到了tlb中,</p>
<p>操作系统在page fault时如果从物理内存选出要替换的页是脏的,首先将这个页写入硬盘,然后再覆盖,但如果使用了dcache,若dcache的内容保留着这个页的数据,那麽dcache的数据也得写入硬盘</p>
<p>当TLB缺失时,需要从页表中将一个新的pte写入tlb，如果tlb此时已经满了那么就要替换掉tlb的表项，但假如被替换的表项数据存在于dcache，那么就需要操作系统可以控制dcache，从而使得最新内容在物理内存</p>
<h5 id="TLB控制"><a href="#TLB控制" class="headerlink" title="TLB控制"></a>TLB控制</h5><p>tlb是页表的子集，如果页的映射关系在页表不存在，那么在tlb也不该存在，需要有可以对tlb表项无效的指令</p>
<ol>
<li>进程结束，进程的指令数据堆栈占用的表项就要无效，此时需要将ITLB和DTLB的相关表项全部无效，如果无ASID，就直接无效整个TLB，如果有，只需无效对应asid的表项</li>
<li>进程占用物理空间太大，操作系统就会将一些不常用的写入硬盘，这样这些页在页表的映射关系应该置为无效，页需要将TLB对应表项置为无效</li>
</ol>
<p>对TLB进行管理需要以下：</p>
<ol>
<li>能将TLB（包含ITLB和DTLB）所有表项置为无效</li>
<li>能将TLB某个ASID对应表项置为无效</li>
<li>能将VPN对应表项置为无效</li>
</ol>
<p><strong>arm风格TLB管理</strong></p>
<ol>
<li><p>arm在协处理器CP15提供了ITLB控制寄存器</p>
<ol>
<li><p>将TLB的VPN匹配的表项置为无效，还需满足以下条件：<br>如果一个表项的Global无效，则需要ASID相等<br>如果Global有效，无需比较ASID</p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729651150915.png" alt="1729651150915"></p>
</li>
<li><p>将TLB的ASID对应表项无效，但有global位的不受影响</p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729651240363.png" alt="1729651240363"></p>
</li>
<li><p>将TLB没有锁定的表项无效，为了加快处理器关键程序的执行时间，将tlb一些表项设为锁定，这些内容不会被替换</p>
</li>
</ol>
</li>
<li><p>DTLB控制寄存器（和ITLB一样）</p>
</li>
<li><p>可写入和读出TLB的寄存器</p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729651376237.png" alt="1729651376237"></p>
<p>由于TLB一个表项大于32位，使用两个寄存器对对应一个表项，读TLB，TLB内容放入这两个寄存器，写TLB，这两个寄存器内容写入TLB</p>
</li>
</ol>
<p>总的来说，ARM的TLB管理主要由协处理器实现，只需要访问协处理器的指令就行</p>
<p><strong>MIPS的tlb管理</strong></p>
<p>主要由专门的TLB指令完成</p>
<p><strong>RISCV的TLB管理</strong></p>
<p>有粗粒度的sfence.vma,还有细粒度的Svinval扩展</p>
<h3 id="Cache设计"><a href="#Cache设计" class="headerlink" title="Cache设计"></a>Cache设计</h3><h4 id="Virtual-Cache"><a href="#Virtual-Cache" class="headerlink" title="Virtual Cache"></a>Virtual Cache</h4><p>使用TLB+物理cache，这样CPU先访问TLB，地址转换后才可以访问cache，增加了LOAD延迟</p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729652474236.png" alt="1729652474236"></p>
<p>所以可以直接使用虚拟cache，直接通过虚拟地址访问Cache，如果没有在Cache找到数据，那么就会在TLB进行地址转换然后从下级存储取出数据</p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729652639233.png" alt="1729652639233"></p>
<p>但会存在两个问题：</p>
<p>同义问题：多个不同的虚拟地址对应同一个物理地址，如printf</p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729652819051.png" alt="1729652819051"></p>
<p>如图，当执行store指令向虚拟地址VA1写入数据时，虚拟cache中的VA1改变，但如果之后有load读取VA2，那么会得到过时数据</p>
<p>这个问题取决于Cache的大小和页的大小，对于大小为4K的页，虚拟地址低12位不会变，如果有一个直接相连的Cache，这个Cache小于4K，那么index不会大于12位，即使两个虚拟地址对应同一位置，他们寻址Cache的地址也是相同的，只有Cache大于4K，才会出现同义问题</p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729653244081.png" alt="1729653244081"></p>
<p>可以使用bank解决（8K，直接相连）</p>
<ol>
<li>读取cache时，两个bank都会被读取，然后送到多路选择器，通过PA[12]选择数据</li>
<li>写Cache，通过PA[12]选择bank写入（提交的时候才会被写入，此时物理地址早就知道了，同名问题对应的物理地址一样，所以使用物理地址选择bank可以选出唯一的bank）</li>
</ol>
<p>同名问题：相同虚拟地址对应不同物理位置</p>
<p>这个只需要在TLB设置ASID就可以</p>
<h4 id="对Cache控制"><a href="#对Cache控制" class="headerlink" title="对Cache控制"></a>对Cache控制</h4><p>主要对以下情况控制</p>
<ol>
<li>DMA从外界搬运数据到物理内存的一个地址，这个地址在dcache被缓存，这样需要将dcache内容无效</li>
<li>DMA将数据搬运到外界，这个地址在DCache被缓存，需要先将DCache的新数据写入物理内存</li>
<li>发生page fault，需要从硬盘读取一个页写入物理内存，如果物理内存被覆盖的页是脏的，并且这个页的内容一部分存在于Dcache，需要将DCache的内容写入物理内存，然后进行覆盖</li>
<li>处理器的自修改指令，将修改的指令写入DCache，然后写入物理内存，ICache清空，将物理内存对应指令写入ICache</li>
</ol>
<p>也就是需要以下操作</p>
<ol>
<li>将ICache无效</li>
<li>将ICache的某个line无效</li>
<li>将DCache所有line clean</li>
<li>将DCache的某个line clean</li>
<li>将DCache所有line clean，然后无效</li>
<li>将DCache的某个line clean，然后无效</li>
</ol>
<p>对于ARM，仍然使用协处理器实现，MIPS使用Cache指令实现，RISCV使用zifence扩展（粗粒度）实现</p>
<h2 id="TLB和Cache放入流水线"><a href="#TLB和Cache放入流水线" class="headerlink" title="TLB和Cache放入流水线"></a>TLB和Cache放入流水线</h2><h3 id="PIPT"><a href="#PIPT" class="headerlink" title="PIPT"></a>PIPT</h3><p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729655372235.png" alt="1729655372235"></p>
<p>完全串行了TLB和Cache访问，但有以下优化方案，直接使用虚拟地址的offset寻址Cache（VIPT的一种情况）</p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729655459830.png" alt="1729655459830"></p>
<h3 id="VIPT"><a href="#VIPT" class="headerlink" title="VIPT"></a>VIPT</h3><p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729655542483.png" alt="1729655542483"></p>
<p>1.2的情况不会出现同义问题，实际上相当于图3.36的设计，但是会严重显示Cache容量大小，要严格控制一个WAY大小小于页的大小</p>
<p>所以将1.2归为情况一，3归为情况2</p>
<p>重点讲解情况2</p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729655973192.png" alt="1729655973192"></p>
<p>此时不能保证VA1和VA2寻址Cache的index是相同的，他们位12可能不同，于是他们可能放在不同的cache set，造成空间浪费，之前有bank可以解决</p>
<p>还可以采用让这些重名的虚拟地址只有一个存在于Cache，其他不允许存在，可以使用L2Cache实现，L2包含L1全部内容</p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729657181999.png" alt="1729657181999"></p>
<p>下面是一种实现方法，L2cache中保存着a的部分</p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729657227475.png" alt="1729657227475"></p>
<h3 id="VIVT"><a href="#VIVT" class="headerlink" title="VIVT"></a>VIVT</h3><p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729657611870.png" alt="1729657611870"></p>
<p><strong>小结</strong></p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729657649741.png" alt="1729657649741"></p>
<h2 id="方向预测"><a href="#方向预测" class="headerlink" title="方向预测"></a>方向预测</h2><h3 id="局部历史"><a href="#局部历史" class="headerlink" title="局部历史"></a>局部历史</h3><p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729666858722.png" alt="1729666858722"></p>
<p>每个BHT中的BHR都有自己的PHT，由于上图方法使用PC的一部分，所以会有重名问题，各分支相互干扰，而且PHT的表还很大，占用大量空间</p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729667068859.png" alt="1729667068859"></p>
<p>一种极端就是所有分支只使用一个PHT，此时不需要使用PC寻址PHTs，BHT所有的BHR来寻址这个PHT，但会发生两个不同指令的BHR相等，这样会寻址到同一个PHT表项，产生干扰导致预测精确率下降</p>
<p>其实每个BHR只会使用PHT的少数表项，所以多个BHR可以分别使用PHT的不同部分，但一定会有冲突发生：</p>
<ol>
<li>两条指令的PC的k部分相等，这样会干扰PHT表项</li>
<li>两条分支对对应不同的BHR，但BHR内容一样，这样也会索引到PHT同一表项</li>
</ol>
<p>为了避免这种情况，可以对PC和对应的BHR做处理，下图是对PC做哈希处理</p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729667539150.png" alt="1729667539150"></p>
<p>一般处理有两种方法，如下图所示</p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729667608315.png" alt="1729667608315"></p>
<h3 id="全局历史"><a href="#全局历史" class="headerlink" title="全局历史"></a>全局历史</h3><p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729668135079.png" alt="1729668135079"></p>
<p>所有分支都使用一个BHR，BHR索引PHTs的具体表项，PC进行HASH处理索引PHTs，还可以只使用一个PHT，节省空间，但这样导致两条不同指令对于GHR相等的话造成冲突</p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729668248761.png" alt="1729668248761"></p>
<p>所以采用以下方法解决</p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729668321244.png" alt="1729668321244"></p>
<p>基本的2-Level Predictor的方式，BHR是每个branch各自有的，而PHT是使用的branch是使用同一个，所以这样可以称之为per-address BHR - global PHT的方式，简写为PAg[2]。除了per-address BHR，global BHR的方式之外，[2]中提到了一种set的方式，即在per-address和global中间的一种折中的方式，使用来自一个set的branchs的分支历史。除了BHR是否使用global的，还是per-address的，还是set的方式，PHT也将其分为了global，per-address和set三种方式，这样组合下来，就有9中的组合方式，分别简写为 GAg, GAp, GAs, PAg, PAp, PAs, SAg, SAp 和SAs。比如per-address BHR的示意图如下：</p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729671251364.png" alt="1729671251364"></p>
<p>GPT小例子：</p>
<p><strong>例子背景</strong></p>
<p>假设我们有四条分支指令，分别位于地址 A、B、C 和 D，每条指令的行为可以是“跳转”（即分支被选中）或“不跳转”（即分支未被选中）。这些分支指令执行时的历史如下：</p>
<ul>
<li>地址 A 的分支：行为是  <strong>跳转、不跳转、跳转、不跳转</strong> ，周期性循环。</li>
<li>地址 B 的分支：行为是  <strong>跳转、跳转、不跳转、跳转</strong> 。</li>
<li>地址 C 的分支：行为是  <strong>不跳转、不跳转、跳转、不跳转</strong> 。</li>
<li>地址 D 的分支：行为是  <strong>跳转、跳转、跳转、不跳转</strong> 。</li>
</ul>
<p>我们使用这些行为数据来解释两种分支预测方案。</p>
<hr>
<p><strong>方案一：每地址历史（Per-Address History, P）</strong></p>
<p>在每地址历史方案中，每个分支指令地址（A、B、C、D）都有独立的历史寄存器。因此，预测系统会记录每条分支指令的独立行为模式：</p>
<ul>
<li><strong>地址 A</strong> 的历史记录：跳转、不跳转、跳转、不跳转</li>
<li><strong>地址 B</strong> 的历史记录：跳转、跳转、不跳转、跳转</li>
<li><strong>地址 C</strong> 的历史记录：不跳转、不跳转、跳转、不跳转</li>
<li><strong>地址 D</strong> 的历史记录：跳转、跳转、跳转、不跳转</li>
</ul>
<p>当预测系统遇到地址 A 的分支指令时，它只参考地址 A 的历史记录来预测。这样可以确保预测是基于该分支自身的历史行为，不受其他分支的影响。</p>
<p> <strong>优势</strong> ：每个地址有独立的历史记录，因此预测更精确，尤其在分支行为周期性强或特定地址的分支行为一致时。</p>
<p> <strong>劣势</strong> ：硬件成本较高，因为每个分支指令地址都需要一个单独的历史寄存器。</p>
<hr>
<p><strong>方案二：每集合历史（Per-Set History, S）</strong></p>
<p>在每集合历史方案中，系统将分支指令按地址分组。假设这里将地址 A 和 B 归为一组，地址 C 和 D 归为另一组，每组共享一个历史寄存器。于是，每组的分支指令 <strong>共享同一个历史信息</strong> ，不再有独立记录。</p>
<p>例如：</p>
<ul>
<li><strong>集合 1</strong> （包括地址 A 和 B）：历史记录会被更新为<strong>跳转、不跳转、跳转、不跳转、跳转、跳转、不跳转、跳转</strong></li>
<li><strong>集合 2</strong> （包括地址 C 和 D）：历史记录为<strong>不跳转、不跳转、跳转、不跳转、跳转、跳转、跳转、不跳转</strong></li>
</ul>
<p>由于集合 1 中的地址 A 和 B 共享一个历史寄存器，预测系统会参考<strong>集合 1 的整体历史</strong>来预测 A 或 B 的行为，而不是它们各自独立的行为。</p>
<p> <strong>优势</strong> ：节省硬件资源，因为多个分支指令共用一个历史寄存器。</p>
<p> <strong>劣势</strong> ：同一个集合内的分支行为会互相干扰。例如，地址 A 的周期性行为和地址 B 的不规则行为在同一历史寄存器中混合后，可能会降低预测准确性。</p>
<h3 id="TAGE"><a href="#TAGE" class="headerlink" title="TAGE"></a>TAGE</h3><p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729671704805.png" alt="1729671704805"></p>
<p>结构和PPM大致相似,特点:更新策略不同;</p>
<p>更新策略:1.更新u计数器,u计数器为2bit计数器,provider component的u计数器在alpred和其预测不同时递减,否则递增;并且该计数器会周期性重置,当预测失败时,首先更新provider component的pred计数器,其次如果provider component不是最长的历史.那么分配表项(分支历史大于provider component的),如果存在i&lt;j&lt;M,且u&#x3D;0,直接分配该项,其他u计数器全部递减(i&lt;j&lt;M);假如有多个u&#x3D;0,分配概率大的(一般历史短的)，最后初始化表项(u置为0,pred计数置为弱跳转)</p>
<h2 id="分支预测更新"><a href="#分支预测更新" class="headerlink" title="分支预测更新"></a>分支预测更新</h2><p>对于方向预测，需要更新的有BHR和PHT的饱和计数器</p>
<ol>
<li><p>更新BHR<br>在全局历史分支预测：</p>
<ol>
<li>取指阶段分支预测，然后根据预测结果直接更新GHR</li>
<li>当实际方向计算出来，此时更新BHR</li>
<li>提交阶段，离开流水线时，更新GHR</li>
</ol>
<p>使用方法3最为保守，最为安全，但会降低性能，其他分支也不会享受这个分支的结果</p>
</li>
</ol>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729672921097.png" alt="1729672921097"></p>
<p>BR2-BR5使用的都不是最新的GHR值，会对准确度造成影响</p>
<p>使用方法2更新提前了很多，但对于超标量处理器影响较大，乱序执行阶段分支预测可能会位于预测失败路径，导致结果不一定对</p>
<p>使用方法1，其根本原因是分支预测准确率较高，预测失败需要对GHR进行修复：</p>
<ol>
<li>提交阶段修复法：提交阶段放一个GHR，当分支指令退休时，将结果写入GHR<br><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729673275891.png" alt="1729673275891"><br>这种缺点是造成分支预测失败的惩罚增大</li>
<li>checkpoint修复法，对前端GHR更新时将旧的GHR保存起来，保存的值为checkpoint GHR，一旦这条分支结果被计算出来，就可以检查预测正误，如果预测正确，继续执行，预测失败，将checkpoint ghr恢复到前端，请从正确PC取指令</li>
</ol>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729673568437.png" alt="1729673568437"></p>
<p>上图有一个存储器保存所有的GHR，由于新指令结果从GHR右侧移入，此时将预测方向相反的值写入就行，前端是顺序的，所以按照FIFO写入就行，而后端如果是乱序的，那么执行阶段得到的结果也有可能是错的（预测失败路径或者异常），此时仍然需要在提交阶段检查，提交阶段仍然需要RGHR</p>
<p>而对于基于局部历史的，可以在退休阶段更新，因为他只在乎一条跳转指令的行为，如果训练完成，预测正确率较高，少一次结果不会影响大局</p>
<h2 id="目标预测"><a href="#目标预测" class="headerlink" title="目标预测"></a>目标预测</h2><h3 id="PC-relative"><a href="#PC-relative" class="headerlink" title="PC-relative"></a>PC-relative</h3><h4 id="BTB"><a href="#BTB" class="headerlink" title="BTB"></a>BTB</h4><p>不发生跳转：target&#x3D;pc+sizeof(fetch group)</p>
<p>发生跳转：target &#x3D; pc + signed(imm)</p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729676174524.png" alt="1729676174524"></p>
<p>我们可以保存下来BTA，然后预测成功时，取出BTA，但这样得保存整个pc地址，可以采用下面的方法</p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729676271119.png" alt="1729676271119"></p>
<p>这个是缩短pc位数，但缩短位数就会导致冲突，不同的pc寻址到相同BTB表项，这样其实概率不高，况且之后还可以对其进行修复</p>
<p>也可以采用异或的方法</p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729676437002.png" alt="1729676437002"></p>
<p>通过这种方式，既降低PC位数，又避免重名问题</p>
<h4 id="BTB缺失处理"><a href="#BTB缺失处理" class="headerlink" title="BTB缺失处理"></a>BTB缺失处理</h4><ol>
<li>停止执行，直到指令被计算出来，这个时候会导致有较多的气泡</li>
<li>继续执行，使用顺序的PC取指令，如果后续执行发现地址和计算的PC不同，则将分支指令之后的全部抹除</li>
</ol>
<h3 id="间接跳转"><a href="#间接跳转" class="headerlink" title="间接跳转"></a>间接跳转</h3><h4 id="CALL-RETURN指令"><a href="#CALL-RETURN指令" class="headerlink" title="CALL&#x2F;RETURN指令"></a>CALL&#x2F;RETURN指令</h4><p>CALL指令的目的地址比较固定，所以采用BTB</p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729690828057.png" alt="1729690828057"></p>
<p>return指令返回地址为上一次CALL指令调用的PC，所以使用RAS保存</p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729690912314.png" alt="1729690912314"></p>
<p>整个过程如下操作</p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729690951738.png" alt="1729690951738"></p>
<p>首先当遇到CALL指令，需要将其下一条PC写入RAS，然后读BTB得到TARGET，当遇到return指令，要弹出RAS，然后得到target<br>所以要得知指令是否为CALL还是return指令，但指令直到解码才会被得出，这可以通过在BTB添加指令类型，call、return、其他类型，再遇到这个指令，通过查询BTB就可以得出类型</p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729691186846.png" alt="1729691186846"></p>
<p>假如RAS满了，该如何进行操作，</p>
<ol>
<li>不对最新的call指令压栈，这样下一次执行return必然预测失败，而且RAS地址不能改变</li>
<li>继续写入，这样最旧的会被覆盖，所以也会出现一条预测失败，但考虑到递归这种情况，会增加正确率，但递归会大量消耗RAS空间，所以可以弄一个计数器，检测本次call是否跟上次一样，如果一样，那么只增加计数器，如果不一样，进行压栈，弹栈的时候，首先看计数器是否为0，如果不为0，计数器-1，然后不改变RAS指针，直到计数器为0，才可以改变RAS指针</li>
</ol>
<h4 id="其他预测方法"><a href="#其他预测方法" class="headerlink" title="其他预测方法"></a>其他预测方法</h4><p>target cache</p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729691627500.png" alt="1729691627500"></p>
<h2 id="分支预测失败恢复"><a href="#分支预测失败恢复" class="headerlink" title="分支预测失败恢复"></a>分支预测失败恢复</h2><p>在流水线很多阶段可以对分支预测是否正确进行检查，</p>
<ol>
<li>解码阶段，可以检查出直接跳转类型的指令，还可以得到这个指令地址</li>
<li>读取物理寄存器时，读到寄存器值，就可以对间接跳转进行检查</li>
<li>执行阶段，所以类型指令都可以得到结果，对分支预测是否正确做出检查</li>
</ol>
<p>分支预测失败可以使用ROB来解决，暂停取指令，但仍然执行流水线，当分支变为最旧的时候，将整个流水线清除，这种方法的缺点就是分支预测惩罚大，</p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729694791283.png" alt="1729694791283"></p>
<p>另一种就是使用checkpiont恢复，也就是发现分支指令，在分支指令改变CPU state之前，先保存CPU state，包括RAT,PC等，预测失败，直接把checkpoint的搬运过来，使用这种方法需要识别哪条指令位于错误路径，这可以对每个指令进行标号（解码阶段），所有在分支指令之后的都会得到这个编号，直到下一个分支指令</p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729695140867.png" alt="1729695140867"></p>
<p>所有在流水线的分支指令都会得到编号，编号保存在FIFO，他的容量就是流水线可以最多支持的分支指令，一旦满了，如果再解码出指令，就必须stall流水线，</p>
<p>一般性的设计方法可以是一个表格存没使用的编号，另一个存被使用的编号（和rename的RAT差不多），解码时刻对分支指令编号，之后的非分支指令均有这个编号，这两个表格本质就是FIFO</p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729695418178.png" alt="1729695418178"></p>
<p>前面说过，解码时刻也可以检查分支预测，如果预测失败，也要对其进行分配编号，因为其之前有可能有预测失败的指令</p>
<p>当分支指令在执行预测失败，需要抹除之后的所有指令</p>
<ol>
<li>发射阶段前的全部被清除，</li>
<li>发射阶段后的使用编号列表清除，这样不一定会在一个周期完成</li>
</ol>
<p>如何使用编号列表找到指令呢？</p>
<p>如果ROB存储了编号，编号列表就可以进行广播，ROB中所有的指令将自己的编号与广播值比较，如果相等，进行无效，假如一个有32个表项的编号列表，最坏情况ROB需要与32个编号比较，其实可以每周期只广播一个或几个值，当编号不是很多，几个周期就可以完成，必须状态恢复才可以允许新指令进入发射阶段</p>
<p><img src="https://file+.vscode-resource.vscode-cdn.net/c%3A/Users/Legion/Desktop/arch_note/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729695901482.png" alt="1729695901482"></p>
<p>但其实在流水线解码阶段，最多解码1，2条导致FIFO浪费，所以可以只允许一个周期解码一条分支指令，如果多条，那么第二条指令及之后的无法进入解码阶段</p>
<p>还有一个问题就是，在执行阶段如何得知预测的目标地址，可以把目标地址写入缓存PTA</p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729696659213.png" alt="1729696659213"></p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729696830422.png" alt="1729696830422"></p>
<h2 id="超标量分支预测"><a href="#超标量分支预测" class="headerlink" title="超标量分支预测"></a>超标量分支预测</h2><p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729696935982.png" alt="1729696935982"></p>
<p>要对指令组进行预测，就需要得到预测非跳转的PC，但这种不容易被接受，因为一个周期取出四条分支情况很少，大部分情况只会使用一个，而且一般为PC-relative，所以可以取出直接进行计算目标地址，也可以预解码，提前得知目标地址信息</p>
<p>多端口可以使用交叠，下面给出PHT的做法</p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729697495138.png" alt="1729697495138"></p>
<h1 id="寄存器重命名"><a href="#寄存器重命名" class="headerlink" title="寄存器重命名"></a>寄存器重命名</h1><p>程序中存在很多相关性：</p>
<ol>
<li><p>数据相关性</p>
<ol>
<li>WAW：两条指令都写入同一寄存器</li>
<li>WAR:一条指令目的寄存器和他前面某条指令的源寄存器是一样的</li>
<li>RAW:一条指令源寄存器来自他前面某条指令计算结果</li>
</ol>
</li>
<li><p>存储器数据相关性<br>load和store指令WAW,WAR,RAW</p>
</li>
<li><p>控制相关性</p>
</li>
<li><p>结构相关性<br>指令必须等到功能器件可以使用的时候才可以执行</p>
</li>
</ol>
<p>数据相关性的三种类型，只有RAW是真相关，其他两种可以通过使用不同寄存器名字解决</p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729740268426.png" alt="1729740268426"></p>
<p>所以这两种相关性称为假的相关性：</p>
<ol>
<li>有限个数寄存器</li>
<li>程序中循环体，假如一直向R1写入值，那么就会产生大量WAW</li>
<li>代码重用，很小的函数被频繁调用，原理同2</li>
</ol>
<p>总之就是寄存器有限，所以引入寄存器重命名，处理器中实际存在但寄存器个数要多于指令集定义的寄存器，指令集定义的寄存器被称逻辑寄存器，处理器实际存在的称为物理寄存器</p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729740664883.png" alt="1729740664883"></p>
<p>上图使用寄存器重命名解决WAW和WAR</p>
<h2 id="寄存器重命名方式"><a href="#寄存器重命名方式" class="headerlink" title="寄存器重命名方式"></a>寄存器重命名方式</h2><p>一般有三种：</p>
<ol>
<li>将ARF扩展实现重命名</li>
<li>使用统一的PRF</li>
<li>使用ROB</li>
</ol>
<p>一般实现寄存器重命名，要考虑</p>
<ol>
<li>什么时候占用寄存器，来自哪里</li>
<li>什么时候释放，去往何处</li>
<li>分支预测失败如何解决</li>
<li>异常如何解决</li>
</ol>
<h3 id="ROB进行重命名"><a href="#ROB进行重命名" class="headerlink" title="ROB进行重命名"></a>ROB进行重命名</h3><p>当一条指令被写入ROB中,ROB的表项就是这个指令目的寄存器对应的寄存器，这样就完成了一条指令目的寄存器重命名过程，如果一条指令离开流水线，另一条指令执行也使用了相同但目的寄存器，那么ARF就不是最新值了，需要重命名映射表指示逻辑寄存器值是位于ROB还是ARF</p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729751980699.png" alt="1729751980699"></p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729752011724.png" alt="1729752011724"></p>
<p>图7.5中如果一个逻辑寄存器位于ROB，那么重命名映射表也会给出这个逻辑寄存器在ROB的编号，指令计算完毕，存储到ROB对应空间，指令离开流水线将结果从ROB搬出送入ARF，位置变动信息需要更新到重命名映射表，这个方法缺点如下：</p>
<p>1.很多指令无目的寄存器，但仍占用ROB表项</p>
<p>2.对于一条指令，他既可以在ROB取操作数，也可以在ARF取操作数，所以会需要ROB和ARF读端口变多</p>
<h3 id="ARF扩展"><a href="#ARF扩展" class="headerlink" title="ARF扩展"></a>ARF扩展</h3><p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729752909299.png" alt="1729752909299"></p>
<p>很明显，这个是ROB的延伸，原理与ROB类似</p>
<h3 id="使用统一的PRF寄存器"><a href="#使用统一的PRF寄存器" class="headerlink" title="使用统一的PRF寄存器"></a>使用统一的PRF寄存器</h3><p>这统一的PRF，没有和指令产生映射关系的都是空闲，会使用free list 记录PRF哪各处于空闲，当一条指令被寄存器重命名，并且存在目的寄存器，他就会占据PRF一个寄存器，这个寄存器会经历值没有被计算，值被计算但没退休，退休三个过程，</p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729753351278.png" alt="1729753351278"></p>
<p>图7.7的free list可以使用FIFO实现，所有空闲的物理寄存器编号都位于其中，对于一个4-way，需要每周期最多可以读出4个值，每周期可以退休也是4条，最多有4个空闲编号送入这个free lsit（交叠）</p>
<p>一条指令在寄存器重命名时，需要对源寄存器和目的寄存器都处理，源寄存器查询RAT，目的寄存器就在free list找出一个空闲的，如果空闲列表空了，那么就要暂停重命名及其之前流水线，直到指令有退休的释放</p>
<p>还需要一个退休RAT，每当指令退休，把映射关系写入RAT，外界查找这个寄存器，就可以得到逻辑寄存器对应的物理寄存器</p>
<p>一个物理寄存器被占用后，何时变成空闲？当后边指令不再使用这个物理寄存器就可以，只要最后使用这个物理寄存器的退休，那么就可以变空闲，但不容易获得谁是最后一个使用的指令，所以处理器采用以下方法</p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729754030585.png" alt="1729754030585"></p>
<p>当一条指令和之后的指令都写同一个目的寄存器时，后面指令退休，那么前边指令对应的物理寄存器就没作用了，为了实现这个，在ROB除了记录逻辑寄存器对应的物理寄存器，还需要记录之前对应的物理寄存器，以便在退休时，将旧的映射关系释放</p>
<h2 id="重命名映射表"><a href="#重命名映射表" class="headerlink" title="重命名映射表"></a>重命名映射表</h2><p>一种是基于SRAM，一种是基于CAM，</p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729755104297.png" alt="1729755104297"></p>
<p>SRAM的方法相对比较常用，每次新写入sRAT的值会覆盖原来的值，将原来的写入ROB，但cRAT也不错，他checkpoint只需要保存V位，不需要保存整个cRAT，只需要保存V位，易于状态保存（之前有个疑问是，如果映射关系变了呢，但显然映射关系不会改变）</p>
<h2 id="超标量寄存器重命名"><a href="#超标量寄存器重命名" class="headerlink" title="超标量寄存器重命名"></a>超标量寄存器重命名</h2><p>一条指令重命名过程：</p>
<ol>
<li>RAT找到src1和src2的映射关系</li>
<li>从Free list找到空闲寄存器（为目的寄存器找映射）</li>
<li>将之前的映射关系写入ROB，将映射关系写入RAT，这样就完成了重命名</li>
</ol>
<p>对于超标量4-WAY，需要RAT 至少12R4W</p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729757341771.png" alt="1729757341771"></p>
<p>但其实这只是一小部分，还需要解决WAW,WAR,RAW</p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729757396874.png" alt="1729757396874"></p>
<p>A指令和B指令存在RAW，那么B的源寄存器的r0应该来自P30，而不是RAT</p>
<p>A,B,D存在WAW，但实际寄存器重命名消除不了相关性：</p>
<ol>
<li>写入RAT，只需将一个逻辑寄存器最新映射写入RAT就行，所以一个周期重命名的寄存器，只需将最新的指令映射关系写入即可</li>
<li>当将旧的映射关系写到ROB，关系不止来自RAT，还来自WAW相关指令</li>
</ol>
<p>所以需要进行WAW检查</p>
<p>B,D存在WAR，B读r0，D写r0，这个可以消除</p>
<p>所以超标量设计需要考虑RAW和WAW，</p>
<h3 id="解决RAW"><a href="#解决RAW" class="headerlink" title="解决RAW"></a>解决RAW</h3><p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729758083027.png" alt="1729758083027"></p>
<p>如果指令存在RAW相关性，对于R5&#x3D;R6XR1，源寄存器R1对应的物理寄存器来自第一条指令，所以他的映射关系来自空闲列表读出的P31，而不是RAT读出的P25，其一般性电路如下</p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729758231238.png" alt="1729758231238"></p>
<h3 id="解决WAW"><a href="#解决WAW" class="headerlink" title="解决WAW"></a>解决WAW</h3><p>主要就是检查写RAT和ROB</p>
<p><strong>写RAT</strong></p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729758743463.png" alt="1729758743463"></p>
<p><strong>写ROB</strong></p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729758836199.png" alt="1729758836199"></p>
<p>选择写入ROB的旧映射关系是RAT还是freelist得出的值</p>
<h2 id="寄存器重命名恢复"><a href="#寄存器重命名恢复" class="headerlink" title="寄存器重命名恢复"></a>寄存器重命名恢复</h2><p>三种一般性恢复方法：</p>
<ol>
<li>使用Checkpoint恢复</li>
<li>使用WALK对RAT恢复</li>
<li>使用ARCH state对RAT恢复</li>
</ol>
<h3 id="使用checkpoint"><a href="#使用checkpoint" class="headerlink" title="使用checkpoint"></a>使用checkpoint</h3><p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729759401159.png" alt="1729759401159"></p>
<p>随机访问的一个周期完成，串行的慢一些</p>
<h3 id="使用WALK"><a href="#使用WALK" class="headerlink" title="使用WALK"></a>使用WALK</h3><p>可用ROB恢复，每条指令ROB都存了他之前对应的物理寄存器，当分支预测失败，通过这个分支编号将所有相关指令抹除，暂停流水线，从ROB底部开始逐条将每条指令之前对应的映射关系写到RAT，这个过程被称为WALK，这个过程慢，但消耗硬件少</p>
<h3 id="使用Arch-state"><a href="#使用Arch-state" class="headerlink" title="使用Arch state"></a>使用Arch state</h3><p>在统一PRF重命名中，处理器提交阶段也有一个RAT，称为aRAT，这个信息必然正确，当执行阶段发现分支预测失败，不立马进行RAT状态恢复，而是等分支指令变为最旧指令，这时候对sRAT进行恢复，但这个可能会加大分支预测惩罚（，其之前还有load导致的cache缺失）</p>
<h1 id="发射"><a href="#发射" class="headerlink" title="发射"></a>发射</h1><h2 id="集中VS分布"><a href="#集中VS分布" class="headerlink" title="集中VS分布"></a>集中VS分布</h2><p>总结来说集中式从储量庞大的指令寻找到几条可以执行的指令，这些指令还需要唤醒其他相关指令，增加了选择电路和唤醒电路的面积和延迟，分布式为每一个FU配备一个发射队列，所以每个发射队列容量小，简化选择电路设计，但当一个发射队列满了，即使其他发射队列还有空间，也不能继续向其中写入新的指令，需要暂停流水线，所以现代处理器一般结合两种，使得某种FU共同使用一个发射队列</p>
<h2 id="数据捕捉VS非数据捕捉"><a href="#数据捕捉VS非数据捕捉" class="headerlink" title="数据捕捉VS非数据捕捉"></a>数据捕捉VS非数据捕捉</h2><p>数据捕捉：在发射前读取寄存器，这种方式设计重命名后读取寄存器，然后将读取的值写入发射队列，如果有些寄存器没被计算出来，就把编号写入以此供唤醒电路使用，他会被标记为无法获得，之后通过bypass获得值（一般结合ROB重命名）</p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729761311665.png" alt="1729761311665"></p>
<p>非数据捕捉：</p>
<p>被重命名的指令不会去读取物理寄存器堆，而是在发射队列被选中后，将读取值送入FU执行，不需要payloadRAM，省空间（一般结合统一PRF）</p>
<h2 id="压缩VS非压缩"><a href="#压缩VS非压缩" class="headerlink" title="压缩VS非压缩"></a>压缩VS非压缩</h2><p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729762087736.png" alt="1729762087736"></p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729762098732.png" alt="1729762098732"></p>
<p>压缩队列优点：分配电路简单，选择电路简单，但面积大，功耗大</p>
<p>非压缩：写入空闲位置即可，但空闲位置随机，一个周期找到多个空闲位置也不简单</p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729762226487.png" alt="1729762226487"></p>
<p>这种电路：</p>
<p>要实现old-first，需要更复杂的电路</p>
<p>分配电路负载，需要扫描所有空间写入发射队列</p>
<h2 id="发射阶段流水线"><a href="#发射阶段流水线" class="headerlink" title="发射阶段流水线"></a>发射阶段流水线</h2><p>简单介绍，之后着重介绍每个流水线要操作的事情</p>
<p>非数据捕捉</p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729762789556.png" alt="1729762789556"></p>
<p>数据捕捉</p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729762808596.png" alt="1729762808596"></p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729762967889.png" alt="1729762967889"></p>
<h2 id="分配"><a href="#分配" class="headerlink" title="分配"></a>分配</h2><p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729763031739.png" alt="1729763031739"></p>
<p>对于4-way，需要每周期找到四个空闲位置，首先扫描空间找到四个空闲表项，为了更快，也可以按照下面的设计</p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729763121408.png" alt="1729763121408"></p>
<p>但缺点就是如果一个段有空间，但其他段有空间，仍然无法使用其他的段，而且如果最老的A写入不了指令队列，之后的BCD也写入不了</p>
<h2 id="仲裁"><a href="#仲裁" class="headerlink" title="仲裁"></a>仲裁</h2><h3 id="1-of-M仲裁"><a href="#1-of-M仲裁" class="headerlink" title="1-of-M仲裁"></a>1-of-M仲裁</h3><p>对于非数据捕捉，要实现old-first需要ROB的帮助，可以通过读取ROB的指针来得出年龄，然后作为指令年龄信息，ROB本质就是FIFO，如果直接使用指针，无法得出正确值，需要加入一个指针位，具体就是下面情况</p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729766055564.png" alt="1729766055564"></p>
<p>这样就实现了old-first基础，分发阶段，将重命名之后的指令写入ROB和发射队列，然后一并将地址信息写入发射队列，然后就有年龄信息了，就可以仲裁选择最老指令，实际要考虑以下情况：</p>
<p>如何屏蔽发射队列没准备好的指令？</p>
<p>将其年龄信息设置为无限大，但无限大不现实，可以采用下面方法，当两个ready为1，进行年龄比较，只有一个ready为1，选择ready为1的那条</p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729767391050.png" alt="1729767391050"></p>
<p>如何根据年龄值找到指令呢</p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729767561728.png" alt="1729767561728"></p>
<h3 id="N-of-M仲裁"><a href="#N-of-M仲裁" class="headerlink" title="N-of-M仲裁"></a>N-of-M仲裁</h3><p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729768263657.png" alt="1729768263657"></p>
<p>这种方案整个延迟就是1-of-M，但无法实现理想功能，如下图，本周期有五条准备好的指令，每个FU对应的仲裁电路只能选择一个属于他的指令，所以本周期只能选择三条，可以增加FU数量，但又引入该分配到那个ALU，一种实现就是轮换分配，本周期ALU0，下周期ALU1</p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729768400078.png" alt="1729768400078"></p>
<h2 id="唤醒"><a href="#唤醒" class="headerlink" title="唤醒"></a>唤醒</h2><h3 id="单周期唤醒"><a href="#单周期唤醒" class="headerlink" title="单周期唤醒"></a>单周期唤醒</h3><p>唤醒电路如下，</p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729768916559.png" alt="1729768916559"></p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729769259348.png" alt="1729769259348"></p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729769416310.png" alt="1729769416310"></p>
<p>单周期指令唤醒主要：</p>
<ol>
<li>被仲裁电路选中的指令将目的寄存器送入对应总线</li>
<li>总线跟发射队列所有源寄存器对比，如果相等，将这个源寄存器设置为准备好</li>
<li>当发射队列指令所有操作数准备好了，并且没有向仲裁电路发过请求，他就可以发送请求</li>
<li>如果有更高优先级发出了请求信号，则这条指令不会得到响应，等下个周棋继续发，如果已经选中，就会标记为ISSUED，表示已经选中，但不离开</li>
<li>发射队列指令收到响应信号，将目的寄存器送入对应总线，唤醒其他指令</li>
</ol>
<h2 id="多周期唤醒"><a href="#多周期唤醒" class="headerlink" title="多周期唤醒"></a>多周期唤醒</h2><p>唤醒其实就是将被选中的指令的目的寄存器编号送到总线上，然后将总线值与源寄存器对比，所以要将唤醒延迟，就有两种方法：</p>
<p>延迟唤醒和延迟广播，</p>
<p>延迟广播如下图，如果发现被仲裁电路选中指令执行数大于1（N），就延迟N-1周期，然后唤醒</p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729771089390.png" alt="1729771089390"></p>
<p>但这可能会导致其他指令也使用这个总线，导致冲突</p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729771292722.png" alt="1729771292722"></p>
<p>可以增加tag bus解决，但情况多的时候，需要大量bus，如果不加总线，就要记录每个指令执行周期，后续被选中的指令如果发现冲突，不会送入FU</p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729771352672.png" alt="1729771352672"></p>
<p>上图做法访问表格和仲裁同时工作，即使B被仲裁选中，也可能被表格给毙了，然后下个周期参加仲裁，接下来讲延迟唤醒，被仲裁指令会正常的将目的寄存器送往总线，但比较相等的寄存器不一定马上置为准备好的状态，而是根据这条指令执行周期，进行相应的延迟，然后再改变发射队列的源寄存器状态，这种方法不会出现总线竞争，如下图，延迟唤醒本质就是在ready位前➕延迟寄存器，其中一种实现如下：</p>
<p>采用移位寄存器，解码阶段可得知指令执行周期数，将执行周期进行编码，称为DELAY，然后每条存在的目的寄存器分配一个物理寄存器，每个物理寄存器含有一个DELAY值，每次写发射队列，这个DELAY也会写入</p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729776477690.png" alt="1729776477690"></p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729776856037.png" alt="1729776856037"></p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729776942292.png" alt="1729776942292"></p>
<h2 id="推测唤醒"><a href="#推测唤醒" class="headerlink" title="推测唤醒"></a>推测唤醒</h2><p>主要针对执行周期不确定的，如load和一些可以early out的CPU，一种最简单的方法就是等指令执行完再进行其他指令唤醒，Cache命中率一般较高，所以可以先推测load指令命中，这样就可以按照下面的方式执行</p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729777336923.png" alt="1729777336923"></p>
<p>但一旦A缺失，B就不能通过旁路网络获得操作数，也就无法在FU中执行，而且B还不能停，一停下来FU无法接受其他指令了，最好的方法就是把B重新放回发射队列，等到从L2得到数据，再对其进行唤醒</p>
<p>假设load缺失，就要进行恢复，此时被唤醒的寄存器重新变为未准备好，还有的已经出去发射队列了，需要在流水线抹掉，然后放入发射队列，然后load预测L2周期唤醒</p>
<p>不同结构的DCache对于推测唤醒的过程是有影响的，假设流水线结构如下，load电路被仲裁电路选中后，需要等待两个周期才可以唤醒，这两个周期可以放一些无相关性的指令称为IW，然后后面两个周期是load从唤醒其他指令到检测到自身是否缺失，而且SW窗口的指令不一定和load有相关性，IW也不一定和load无关，因为他可能是其他load的SW</p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729778055320.png" alt="1729778055320"></p>
<p>下图就是Load1和Load3的IW窗口重合了，这两个周期被仲裁电路选中的指令未必可以获得操作数，取决于load1是否命中，当发现缺失，load的SW窗口指令就要被抹除，被抹除的指令会重新回到发射队列</p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729778268240.png" alt="1729778268240"></p>
<p>不同DCache结构的IW和SW结构不同，但处理方式相似</p>
<p>这种方法主要两种：</p>
<p><strong>Issue Queue Based Replay</strong></p>
<p>这种指令被选中后不会立马离开发射队列，只有等指令被确定正确执行，才可以离开发射队列，这也就是之前的issued位</p>
<p>前文介绍的load指令的DCache缺失只是replay的一种情况，比如DCache的bank冲突，store、load违例，load、load违例</p>
<p>，只有指令执行正确才可以离开，对于load、store完全乱序，即使load命中，甚至load执行完毕，但只要没有离开流水线，就有可能被送回去，而部分乱序和完全顺序则不会出现这个问题,此时只有和load相关的才会被replay，跟精确说就是SW内的指令才可能被replay，这种方法缺点就是造成发射队列的可用容量减少，所以要进行tradeoff</p>
<p>可以只对load指令采取基于发射队列的replay，一旦load指令在执行阶段得到了DCache的结果，就可以将发射队列相关指令释放，但对于store、load违例等，如果发生，那些被刷去的指令可能回不去发射队列（满了），这时，可以将需要replay指令抹除，重新取指令</p>
<p>load的replay仍然需要replay：</p>
<p>一种方法就是将所有在load指令之后被仲裁电路选中的指令全部放回发射队列。这种方法不会发生错误，但可以改进，比如IW内指令与该load无关，SW有的也无关，所以可以non-selective REPLAY，他是无差别选指令</p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729779388679.png" alt="1729779388679"></p>
<p>假设DATA阶段，得到DCache是否命中，那么如果没有命中，将Data和wake-up阶段全部抹除，但只有OR和SUB和load有相关性，改进：IW窗口中cal和TLB阶段不需要抹除，只需抹除SW窗口的，将所有和load有相关性的放回发射队列置为not ready，其他不用关心，他们仍然准备好了，可在下周其参与仲裁，这要求可以识别相关性，</p>
<p>一是直接相关性，也即是OR，二是间接相关性，也即是SUB，可以采用一个load-vector来实现这个位数表示流水线最多可以存在几条指令</p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729779730582.png" alt="1729779730582"></p>
<p>每个物理寄存器都有一个这个，非load存在目的寄存器，他的向量值就是两个源寄存器向量值异或的结果，load指令，除了来自源寄存器，他还会占用向量一个新的位，这样可以得到目的寄存器的向量值，更新到表格，指令被重命名，就可以将每个源寄存器的向量值写入发射队列，每当laod缺失，就根据这条指令在向量中对应位，找出有相关性的指令，这个适合流水线浅的，深的话需向量宽度增加，不然经常暂停</p>
<p>load指令只有在SW窗口的才和他有相关性，为了识别相关性，使用一个5位的值，表示load位于哪一位值,称为LPV，每当load被选中，LPV为10000，表示load处于select，这个周期进行唤醒（延迟唤醒），然后所有比较结果相等的都会获得这个值，每个周期，发射队列LPV右移一位</p>
<p>为了识别相关性，每条指令被选中后，唤醒其他指令都会讲LPV赋值给被唤醒的寄存器，这样就可以识别那个和load有相关性，当load到data阶段发现缺失，直接将LPV最低位为1的送入发射队列</p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729780555348.png" alt="1729780555348"></p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729780570220.png" alt="1729780570220"></p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729780601171.png" alt="1729780601171"></p>
<p>注意上图需要注意：AND指令的LPV是两个源寄存器或</p>
<p>如果直接清除SW，然后选择性清除LPV最低为1的指令，就是non-selective，如果SW窗口的也选择性清除LPV最低为1，则是selective</p>
<p>这个方法适合数据捕捉，因为replay指令少</p>
<p><strong>Replay Queue Based Replay</strong></p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729782039186.png" alt="1729782039186"></p>
<p>指令被选中，立刻离开发射队列，进入RQ，当一个指令退休时，就可以将RQ指令退出，如果发生访存违例，抹去指令，将RQ相关指令唤醒并向仲裁电路发出申请，而且RQ优先级高，这样可以将replay指令重新送回FU执行（他们更老）适合非数据捕捉，S-》E时间长，replay指令多</p>
<h1 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h1><p>执行阶段最主要的就是旁路网络设计和存储指令加速</p>
<h2 id="旁路网络"><a href="#旁路网络" class="headerlink" title="旁路网络"></a>旁路网络</h2><p>当处理器只有两个FU，其旁路网络如下</p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729822603681.png" alt="1729822603681"></p>
<p>但当FU个数较多，就会出现下面情况</p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729822701469.png" alt="1729822701469"></p>
<p>而且会出现，乘法32个周期，但逻辑操作只需要1个周期，那么就是可能会在一个周期同时想用这个旁路网，导致冲突，也就是下面情况</p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729822820249.png" alt="1729822820249"></p>
<p>这种情况该如何处理呢，最简单的方法就是按照推测唤醒讲解的思路，先假设不会冲突，然后按正常流程唤醒和仲裁，一条指令到FU，首先检查FU是否空闲，比如FU接受了latency&#x3D;3的，本周期就不能接收2的，如果本周期是2的就要返回到IQ</p>
<p>假设一个仲裁电路对应的FU可以计算3种类型的指令，延迟分别为1，2，3</p>
<p>则：<img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729824235650.png" alt="1729824235650"></p>
<p>在发射队列每个表项增加两个信号，分别指示它其中的指令latency的值是1还是2</p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729824249996.png" alt="1729824249996"></p>
<p>这种设计可以执行延迟为1，2，3的三种指令，但只需要对延迟为1，2的指令请求处理：</p>
<ol>
<li>本周期选中延迟为3的，下周期无法选择延迟为2的，下下周期无法选择延迟为1的，所以下周期需要将仲裁电路对应的寄存器设置为10，这个寄存器每周期向右移位，下下周期为01，表示不允许执行周期为1的进入,如果本周期选择延迟3的下周起还选择延迟3的，那么</li>
</ol>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729824793132.png" alt="1729824793132"></p>
<ol start="2">
<li>本周期选择的是2的，下周起不允许选择延迟为1的，在下周期设置控制寄存器为01</li>
<li>本周期选择的1的，只需设置控制寄存器为00</li>
</ol>
<h3 id="复杂设计的旁路网络"><a href="#复杂设计的旁路网络" class="headerlink" title="复杂设计的旁路网络"></a>复杂设计的旁路网络</h3><p>这种流水线如下图</p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729825343021.png" alt="1729825343021"></p>
<p>旁路网络如下图</p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729825375607.png" alt="1729825375607"></p>
<p>下图更直观</p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729825603709.png" alt="1729825603709"></p>
<p>下图情况是两条指令相邻和相差一个周期</p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729825805188.png" alt="1729825805188"></p>
<p>当相差两个周期时，这个阶段只能在Write back到Source Drive</p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729825891282.png" alt="1729825891282"></p>
<p>实际上，并不需要所有FU设置旁路网络，比如load的AGU和普通指令的，AGU会使用ALU结果，但ALU不会使用AGU结果，所以旁路只需要ALU到AGU，而store都不需要旁路</p>
<h2 id="操作数选择"><a href="#操作数选择" class="headerlink" title="操作数选择"></a>操作数选择</h2><p>使用scoreboard</p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729838363954.png" alt="1729838363954"></p>
<p>记录了两个内容：</p>
<p>#FU：从哪个FU计算出来</p>
<p>R：物理寄存器已经计算出来并且写入PRF</p>
<p>在流水线加入这个scoreboard</p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729838485740.png" alt="1729838485740"></p>
<p>这个是将读取scoreboard放在执行阶段，如果对频率要求高可能不太行，可以放在读寄存器阶段</p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729838640102.png" alt="1729838640102"></p>
<p>这种方法虽然减少对于处理器时间影响，但却引入了新的问题，</p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729839438577.png" alt="1729839438577"></p>
<p>指令C本应该从PRF得出结果，但可看出，此时scoreboard还没更新，所以会认为需要从旁路网络获得操作数，导致出错，这时就需要在scoreboard加上检测模块，主要就是当读取和写入的寄存器一样，就将控制信号设置为从PRF获得操作数，这个随着流水线复杂度增高，会越来越复杂</p>
<p>一种更简单的方法就是在FU计算出一条指令结果，送入旁路网络同时，对目的寄存器进行广播，此时可以在每个FU输入添加比较电路，将比较结果作为控制信号</p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729839782176.png" alt="1729839782176"></p>
<h2 id="Cluster"><a href="#Cluster" class="headerlink" title="Cluster"></a>Cluster</h2><p>这种东西的诞生就是因为流水线越来越复杂，多端口器件导致处理器面积功耗显著增大</p>
<h3 id="Cluster-IQ"><a href="#Cluster-IQ" class="headerlink" title="Cluster IQ"></a>Cluster IQ</h3><p>采用这种结构优点：</p>
<p>减少每个队列的端口数</p>
<p>每个队列的仲裁电路只需要从少量指令仲裁，仲裁电路小</p>
<p>而且由于容量小，所以唤醒快</p>
<p>但缺点就是被选中的指令唤醒其他IQ需要更长时间，需要额外的周期</p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729840337794.png" alt="1729840337794"></p>
<p>这种数据捕捉的方式就需要研究指令分配问题</p>
<h3 id="Cluster-Bypass"><a href="#Cluster-Bypass" class="headerlink" title="Cluster Bypass"></a>Cluster Bypass</h3><p>集中式的旁路网络复杂度很高，所以需要分布式</p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729840697257.png" alt="1729840697257"></p>
<p>但这个有些缺点：就是两条相关指令在同一个FU，就可以背靠背执行，但如果不在同一个，那么得等一个周期，由于复杂度降低，所以Source Drive和Result Drive可以去掉</p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729840833894.png" alt="1729840833894"></p>
<p>如果两指令在同一个Cluster，那么就可以背靠背执行，如果不在同一个Cluster，那么只能通过寄存器来读，需要间隔一个周期</p>
<h2 id="存储器指令加速"><a href="#存储器指令加速" class="headerlink" title="存储器指令加速"></a>存储器指令加速</h2><h3 id="Memory-Disambiguation"><a href="#Memory-Disambiguation" class="headerlink" title="Memory Disambiguation"></a>Memory Disambiguation</h3><p><strong>完全顺序执行</strong></p>
<p>最保守，但性能不保证</p>
<p><strong>部分乱序</strong></p>
<p>store按照顺序执行，但处于store之间的load可以乱序，当store被仲裁选中，他后面的load就可以参与仲裁了（直到下一个store），使得load尽可能先执行</p>
<p>，这种方法的本质就是当store指令所携带的地址被计算出来后，之后的load就可以判断RAW了，每个load将地址与store比较，这个需要Store Buffer保存这些已经被仲裁电路选中，但没有退出流水线的store指令，如果load发现地址相等的store，直接从缓存取出数据，如果没有发现地址相等指令，load需要访问DCache</p>
<p>这种方法的store就像一扇门，store地址计算出或者被仲裁电路选中，就可以打开门</p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729841881400.png" alt="1729841881400"></p>
<p>这种执行会出现当B,D被仲裁选中，store buffer除了前面的A，还有了他们后面的E，当B或D与E地址相等他们也没有RAW相关性，所以需要知道哪些store在自己前面，哪些在自己后面因此需要对load和store标号：</p>
<ol>
<li>PC值，但store之后有一个向前跳指令，这个就不好判断了</li>
</ol>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729842269918.png" alt="1729842269918"></p>
<ol start="2">
<li>ROB编号，这个可以，但ROB只有一部分是load，不需要全部加编号，浪费面积</li>
<li>解码阶段，为每个load和store分配编号，类似于分支指令</li>
</ol>
<p><strong>完全乱序</strong></p>
<p>store按照制定顺序，但load乱序执行，只要load操作数准备好，就可以出去，这两个类型指令可以共用一个IQ，也可以分开，共用一个的话，需要相互独立的仲裁电路，store要in-order的，load要采用old-first，按照乱序方式选择</p>
<p>两个也可以使用不同的IQ，这样store只用FIFO结构</p>
<p>完全乱序执行load，load指令操作数只要准备好了，就可以参与仲裁，这样可以尽快唤醒其他指令</p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729843311894.png" alt="1729843311894"></p>
<p>上图是发生了store&#x2F;load违例，需要预测这种情况，这种算法称为LOAD&#x2F;STORE相关性预测，一旦发现LOAD和之前的store存在RAW，就记录下来，之后再次遇到就不能让他提前执行</p>
<h3 id="非阻塞Cache"><a href="#非阻塞Cache" class="headerlink" title="非阻塞Cache"></a>非阻塞Cache</h3><p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729843737898.png" alt="1729843737898"></p>
<p>要支持非阻塞Cache，需要使用一个MSHR</p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729843794779.png" alt="1729843794779"></p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729843819581.png" alt="1729843819581"></p>
<p>而load&#x2F;stroe table有五项内容：</p>
<ol>
<li><p>V：表示一个表项是否被占用，无论首次缺失还是再次缺失</p>
</li>
<li><p>MSHR entry，表示一条缺失的指令属于MSHR哪个表项，可能许多产生缺失位于同一line，他们在MSHR占用一个表项，但在这个表占用不同表项</p>
</li>
<li><p>dest.reg：对于load，这部分记录目的寄存器的编号，对于store，存储store在Store Buffer的编号</p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729844117837.png" alt="1729844117837"></p>
</li>
<li><p>Type：记录是SW,LW,SB等</p>
</li>
<li><p>offset：在数据块位置，64位就是6位</p>
</li>
</ol>
<p>发生缺失时，首先查找MSHR本体：</p>
<p>如果有相同表项，表示这个缺失正在处理，只需将这次缺失写入LOAD&#x2F;store Table</p>
<p>如果没发现，则还需写入MSHR</p>
<p>如果这两个表任意一个满了，就暂停流水线</p>
<p>需要注意的是，在超标量中，由于乱序，导致有些load位于分支预测失败路径，这样从下级存储得出的数据就不能写入目的寄存器</p>
<h3 id="关键字优先"><a href="#关键字优先" class="headerlink" title="关键字优先"></a>关键字优先</h3><h3 id="提前开始"><a href="#提前开始" class="headerlink" title="提前开始"></a>提前开始</h3><h1 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h1><h2 id="主要就是ROB"><a href="#主要就是ROB" class="headerlink" title="主要就是ROB"></a>主要就是ROB</h2><p>一种一般结构</p>
<p><img src="/2025/02/05/%E8%B6%85%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1/1729844989157.png" alt="1729844989157"></p>
<p>如果需要为分支预测设置编号，这里面还会有编号信息</p>
<p>这个看书上例子，大概就可以</p>
]]></content>
      <categories>
        <category>处理器设计</category>
      </categories>
  </entry>
</search>
